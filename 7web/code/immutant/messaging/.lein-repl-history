(use 'immutant.dev)
(current-project)
(require '[immutant.messaging :as msg])
(msg/start "queue.urls")
(msg/publish "queue.urls" "http://pragprog.com/")
(msg/receive "queue.urls")
(msg/listen "queue.urls" #(println %))
(msg/publish "queue.urls" "i am in you")
(msg/start "queue.done")
(msg/listen "queue.urls" #(msg/publish "queue.done" (str "echo: " %)))
(msg/publish "queue.urls" "foo")
(msg/receive "queue.done")
(msg/receive "queue.done" :timeout 1000)
(msg/start "topic.everyone")
(.println System/out "foo")
(msg/listen "topic.everyone" #(println (str "one: " %)))
(msg/listen "topic.everyone" #(println (str "two: " %)))
(msg/listen "topic.everyone" #(println (str "three: " %)))
(msg/publish "topic.everyone" "beep beep")
(msg/publish "queue.urls" "http://pragprog.com/")
(msg/publish "queue.urls" ["http://immutant.org" "http://clojure.org"])
(msg/receive "queue.urls")
msg
(require '[immutant.messaging :as msg])
(msg/publish "queue.urls" "http://pragprog.com/")
(msg/receive "queue.urls")
(msg/start "queue.urls")
(msg/receive "queue.urls")
(msg/publish "queue.urls" "http://pragprog.com/")
(msg/receive "queue.urls")
(msg/unlisten "queue.urls")
(msg-stop "queue.urls")
(msg/stop "queue.urls")
(msg/unlisten "queue.urls" nil)
(msg/unlisten "queue.urls")
(msg/start "queue.test")
(msg/publish "queue.test" "http://pragprog.com/")
(msg/publish "queue.test" ["http://immutant.org" "http://clojure.org"])
(msg/receive "queue.test")
(msg/start "queue.listen")
(msg/listen "queue.listen" #(println "i heard:" %))
(msg/publish "queue.listen" [1 2 3])
(msg/publish "queue.listen" #{:a :b :c}))
(msg/publish "queue.listen" #{:a :b :c})
(msg/start "queue.multi")
(msg/listen "queue.multi" #(println "worker a:" %))
(msg/listen "queue.multi" #(println "worker b:" %))
(msg/listen "queue.multi" #(println "worker c:" %))
(msg/publish "queue.multi" "hello 1")
(msg/publish "queue.multi" "hello 2")
(msg/publish "queue.multi" "hello 3")
(Thread/sleep 1000)
(msg/listen "queue.multi" #(do (println "worker a:" %) (Thread/sleep 5000))
)
(msg/listen "queue.multi" #(do (println "worker b:" %) (Thread/sleep 5000)))
(msg/listen "queue.multi" #(do (println "worker c:" %) (Thread/sleep 5000)))
(range 5)
(dotimes [i (range 5)] (println i))
(dotimes [i (range 5)] (println (str i)))
(dotimes 5 (println (str i)))
(dotimes 5 (println "foo"))
(dotimes [i 5] (println "foo"))
(dotimes [i 5] (println "foo" i))
(dotimes [i 3] (msg/publish "queue.multi" (str "hello " i)))
(Thread/currentThread)
(.id Thread/currentThread)
(bean (Thread/currentThread))
(.getId (Thread/currentThread))
(defn worker ]
(defn worker []
  (let [id (.getId (Thread/currentThread))]
))
(defn worker [m]
  (let [id (.getId (Thread/currentThread))]
    (println "worker" id ":" m)
    (Thread/sleep 5000)))
(worker "foo")
(msg/listen "queue.multi" worker :concurrency 5)
(dotimes [i 3] (msg/publish "queue.multi" (str "hello " i)))
(msg/start "topic.multi")
(msg/listen "topic.multi" worker :concurrency 5)
(dotimes [i 3] (msg/publish "topic.multi" (str "hello " i))
)
(require '[immutant.jobs :as jobs])
(jobs/schedule "repeat.hello" #(println "Hello!") :in 1000 :every 500 :repeat 3)
(jobs/schedule "repeat.hello" #(println "Hello!") :in 5000 :every 2000 :repeat 3)
(jobs/schedule "repeat.hello" #(println "Hello!"):in 5000 :every 2000 :repeat 3)
(jobs/schedule "repeat.hello" #(println "Hello!")
    :in 5000 :every 2000 :repeat 4)
(jobs/schedule "say.hello" #(println "Hello!" :in 3000)
)
(jobs/schedule "say.hello" #(println "Hello!") :in 3000)
(jobs/schedule "weekly.hello" #(println "Hello!") "0 15 8 ? * 2")
(jobs/unschedule "weekly.hello")
(defn get-email [username] {:username username :email "user@example.com"})
(defn make-msg [{:keys [username email]}]
  {:to email:from "system@example.com"
)
(defn make-msg [{:keys [username email]}]
  {:to email
   :from "system@example.com"
   :subject "Greetings!"
   :body (str "Hello, " username)})
(defn send-msg [msg] (Thread/sleep 5000) true)
(require '[immutant.pipeline :as pl])
(def email-pipe
  (pl/pipeline "email"
    get-email
    make-msg
    send-msg
    :concurrency 5))
(def result1 (email-pipe "fred"))
(def result2 (email-pipe "jack"))
result1
@result1
@result2
