<?xml version="1.0" encoding="utf-8"?>
<!--
 ! Excerpted from "XSL Jumpstarter",
 ! published by The Pragmatic Bookshelf.
 ! Copyrights apply to this code. It may not be used to create training material, 
 ! courses, books, articles, and the like. Contact us if you are in doubt.
 ! We make no guarantees that this code is fit for any purpose. 
 ! Visit http://www.pragmaticprogrammer.com/titles/djkxsl for more book information.
-->
<!-- -*- xml -*- -->
<!DOCTYPE book SYSTEM "H:/ppsvn/Bookshelf/titles/djkxsl/Book/local/xml/markup.dtd">
<?location book.pml@2 ?>
<book xmlns:pml="http://pragprog.com/ns/pml">

<?location ../bookinfo.pml@3 ?>


<bookinfo code="djkxsl" in-beta="no" production-status="initial-development">
  <booktitle>XSL Demystified</booktitle>
  <booksubtitle/>
  <authors>
        <person>
      <name>David J. Kelly</name>
    </person>
      </authors>
  <copyright>
    <copyrightholder>The Pragmatic Programmers, LLC</copyrightholder>
    <copyrightdate>2011</copyrightdate>
  </copyright>
  <isbn13>pending</isbn13>
  <printing>
    <printingnumber>B1.0</printingnumber>
    <printingdate>Monthname, yyyy</printingdate>
  </printing>
   <production-info>
    <editor/>
    <indexer/>
    <copyeditor/>
    <typesetter>David J Kelly</typesetter>
    <producer>Janet Furlow</producer>
    <rights>Juliet Benda</rights>
    <support>Ellie Callahan</support>
  </production-info>
</bookinfo>

<!-- Check the screen PDF size to determine whether to add COMPRESS_PDF = true to the Rakefile. -->

  <frontmatter>
<?location Preface.pml@3 ?>

<chapter>
  <title>Preface</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p>The Martian language, as I have said, is extremely simple, and in a week I could make all my wants
        known and understand nearly everything that was said to me.</p>
    </epitext>
  </epigraph>
  
  <p>Why a new book now? XSLT, or Extensible Stylesheet Language for Transformations, has been around as a
    specification since late 1999, and the first books about it started appearing not long after. The most
    well-known books arrived in the early 2000s, providing guidance for many an XSLT novice in the duration.
    With the publication of XSLT 2.0, new editions arrived, and then, for a long time, the land of XSLT books
    has been quiet.</p>
  
  <p>As one of those novices back in 2005, I found myself struggling with the basics of XSLT. I was dealing
    with the massive DITA Open Toolkit stylesheets donated by IBM to the OASIS organization in the late 90s,
    trying to understand it and customizing it for the company I worked for. There were many layers to tease
    out—ANT, XSLT, XSL-FO, and the occasional bit of Java. But it was the XSLT that tickled my brain
    the most, and I found myself dreaming at night of long sequences of XSLT transformations moving through
    complicated fields of XML. And sometimes those dreams were like one of those nightmares where you're lost
    in some elaborate, inescapable maze. Not a good feeling.</p>
  
  <p>The early documentation on XSLT (books and Internet sources alike) spent much of their bulk describing
    the elements of the language in a tone that suggested deep familiarity with the specification, but much
    less interest in the kinds of problems XSLT might solve. As I dealt with the requirements given by our
    tech pubs department, I struggled to assemble the bits and pieces into larger solutions. It was like being
    given a bucket of electronic components and being asked to assemble a radio without a schematic. I didn't
    need academic discourses, I needed to see how to apply it in real life.</p>
  
  <p>Of course, programming often requires creative problem-solving, and there was no obligation on the part
    of those early authors to provide cookbook solutions to my particular issues. But wouldn't it have been
    nice if some of the examples went into more elaborate sort of real-world situations? Wouldn't it have been
    nice to see some big problems being solved in detail? </p>
  
  <p>I thought it was just wishful thinking on my part, because my background was more in writing than
    programming. Then I began to meet other people with much more programming background who had had similar
    experiences with XSLT's learning curve. Simon Bate, an accomplished software toolsmith who I worked with
    at another company, used to lament along with me that it would be nice to have a book that showed XSLT in
    action on real-world problems. Brian Hogan, who teaches college-level computer science, and who writes and
    edits books for Pragmatic Bookshelf, talked about the difficulty he had when he first encountered XSLT. If
    these guys were frustrated, pity the poor student!</p>
  
  <p>And that made me begin to wonder: what made XSLT so difficult to learn?</p>
  
  <p>I don't know that there is a single good answer to that, but here are a few guesses:</p>
  
  <ul>
    <li>
      <p>An uncommon, verbose syntax</p>
    </li>
    <li>
      <p>The relative immaturity of the language when most of the books first appeared</p>
    </li>
    <li>
      <p>A narrow range of applications, and therefore a narrow range of audience, and therefore a relatively
        small community of support, which in turn means not much documentation</p>
    </li>
  </ul>
  
  <p>And in reflecting on these issues, it seemed to me that a book centered around a progressive set of
  examples could go a long way toward helping people get over the big bump of the XSLT learning curve.</p>
  
  <p>I've been using XSLT for 7 or 8 years, and I have had to solve some fairly thorny problems along the way.
    The DITA Open Toolkit was an excellent training ground, although I wouldn't recommend it to the faint of
    heart. Other projects took me through a conversion of markup for ancient Greek manuscripts, timesheet
    applications, NROFF conversions, and a variety of conversions from different markup languages to PDF and
    ebook formats. </p>
  
  <p>But for all those experiences and the familiarity they gave me with XSLT, I can't claim that my knowledge
    of XSLT is my primary qualification for writing this book. As an XSLT programmer, I can safely claim that
    there are a lot sharper tools in the shed than me! But what I do bring to the task is a number of decades
    (no need to get too specific) of experience as a technical writer and documentation tools user and
    developer. If there's one thing I enjoy, it's taking difficult, complex information and making it
    accessible to other people. One of the most gratifying (and thankless) comments I get after explaining or
    documenting something is, "Man, and I thought it was complicated. There's really nothing to it, is there." </p>

  <p>So after all that time learning how to put the pieces together, with the generous help of many others, I
    decided it was time to give something back. My hope is that it will make the XSLT learning experience a
    little less puzzling and a little more fun, because in the long run, XSLT can be an excellent tool for
    dealing with XML, with surprising power and scope. That has proven true for me, at any rate, and I hope it
    will for you as well.</p>
  
  <p>I hope that by making the first stage of your XSLT education a little easier, you will be able to put the
    language to work with more creative solutions than I could ever imagine.</p>
</chapter>
  </frontmatter>

  <mainmatter>
<?location Introduction.pml@3 ?>

<chapter>
  <title>Introducing XSLT</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p>“I closed my eyes, stretched out my arms toward the god of my vocation and felt myself drawn
        with the suddenness of thought through the trackless immensity of space.”</p>
    </epitext>
  </epigraph>
<!--
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>To understand what XSLT is and why I should read this book.</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>The basic purpose of the XSLT language, the basics of how it works, how it compares to other XML
          processing options, and what this book is going to help you with.</p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>From this point, you'll be able to get started getting your hands on the basics of the language
          with an idea about why you're doing it and where you're going to wind up. </p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>We're going to put our hands on a simple example and, from that, learn more details about the
          processing model that gives XSLT its value.</p>
      </dd>
    </dl>
  </storymap>
  --> 
  <p>What is XSLT? As the name says, it is an Extensible Stylesheet Language for Transformations. Tells you a
    lot, right?</p>
  <p>Not really.</p>
  <p>If I had my way, I'd switch all those letters around a little to make them more descriptive. It's a
    Language using Stylesheets to Transform XML, and it's eXtensible. LSTX. That's better.</p>

  <p>The extensible part is sort of a throw-away---that's not a particularly important part of XSLT, but it
    comes first in the acronym. The X always throws people off, like it was an X-Man with strange unknown
    powers. The only reason for the X is to make XSLT look like "XML," to which it is strongly related.)</p>

  <p>Let's make it even more specific. XSLT is a language designed to transform XML<footnote>
    <p>In this book I'm assuming you know what XML is. If you don't, you'll need to find out, or this book
      will get mysterious pretty fast. Try X or Y to get started.</p>
    </footnote> into other kinds of stuff. The other stuff is text-based: plain text, different XML, HTML,
    SVG, or pretty much any text-based output you could imagine. But whatever it does, the intent is for XSLT
    to operate on XML and produce text-based output.</p>

  <sect1>
    <title>A Purpose Under Heaven</title>

    <p>Why is XSLT important? Why should we care about transforming XML into "other stuff?" you say?</p>

    <p>Apparently it's important enough that every major web browser out there has a built-in XSLT
      processor!</p>

    <p>XSLT is important because XML is important. XML provides the structure for markup languages in data
      storage, documentation, and information interchange in a broad range of industries. The number of XML
      standards that have appeared since the late 1990s is staggering.<footnote>
      <p>See <url>http://en.wikipedia.org/wiki/Category:XML-based_standards</url> for a listing of XML-based
        standards. I'm especially intrigued by the "Emotion Markup Language."</p>
      </footnote> XML is used for mathematics, graphics, document contents and formatting, medical records,
      broadcasting, business, sports statistics, music, and on and on. You name it, there's probably a way to
      get it into XML. And with all that XML around, people have to manage it and use it for something. XSLT is
      just one of those ways, but it was designed for the purpose early in the history of XML, and it's still
      one of the best options.</p>

    <p>One misperception of XSLT is that it is just a glorified form of CSS. In a way, there's some truth to
      that, because one of its basic functional characteristics is similar to CSS: the execution of the XSLT
      code is dependent on the order of elements in the document being processed. In fact, you could use XSLT
      very much like CSS, simply making stylistic modifications to a source document without changing the
      order of the tags. But if you did that, you would very much miss out on the power and potential of
      XSLT.</p>

    <p>The kinds of transformations that XSLT can perform are practically limitless. Want to turn a numbered
      process list into a flowchart? Transform your XML into SVG. Want to perform calculations based on the
      source, set up conditional processing, play hob with the document order, access external documents, test
      for patterns, and perform functions like sorting and grouping? You probably won't be doing that with
      CSS, but XSLT is designed to make these tasks easy. </p>

    <p>Experts claim that XSLT is a Turing-complete language,<footnote>
      <p>(Kepser, Stephan. "A Simple Proof for the Turing-Completeness of XSLT and XQuery". Proceedings of
        Extreme Markup Languages.)
        <url>http://conferences.idealliance.org/extreme/html/2004/Kepser01/EML2004Kepser01.html</url></p>
      </footnote> <footnote>
      <p>^ "Universal Turing Machine in XSLT". <url>http://www.unidex.com/turing/utm.htm</url>. You can use
        the code here to run the proof yourself!</p>
      </footnote> meaning that it can perform any kind of function that a Turing machine can complete.
      Basically, it means that it's a fully qualified computer language, the same as most others, and it can
      probably do anything we're likely to ask of it. But what we usually use it for is---yep---turning XML
      into other stuff.</p>

  </sect1>

  <sect1>
    <title>Presto Change-o</title>

    <p>What does it mean to transform XML? Let's look at an example, something relatively simple. Here's an
      XML document that I want to turn into HTML:</p>

<processedcode language="xml" showname="Introduction/caution1.xml" style="normal" url="Introduction/caution1.xml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="caution1.xsl"?&gt;</codeline>
<codeline/>
<codeline><cokw>&lt;note</cokw> type=<costring>"caution"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p&gt;</cokw></codeline>
<codeline>    The potential for intergalactic broadcast while</codeline>
<codeline>    using the <cokw>&lt;bold&gt;</cokw>AZGuard Protaxis<cokw>&lt;/bold&gt;</cokw> unit</codeline>
<codeline>    has not yet been determined.</codeline>
<codeline>  <cokw>&lt;/p&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;p&gt;</cokw></codeline>
<codeline>    Please avoid transmitting information that could place the</codeline>
<codeline>    human race at risk.</codeline>
<codeline>  <cokw>&lt;/p&gt;</cokw></codeline>
<codeline><cokw>&lt;/note&gt;</cokw></codeline>
</processedcode>
<?location Introduction.pml@107 ?>


    <p>And here's what I want it to look like in the browser:</p>

    <figure id="fig.browser-view">
      <title>The HTML Output in the Browser</title>
      <imagedata border="yes" fileref="images/Introduction/caution-1.png"/>
    </figure>

    <p>Looking a little closer, here's the HTML source for what's rendered in the browser:</p>

<processedcode language="html" showname="Introduction/caution1.html" style="normal" url="Introduction/caution1.html">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline><cokw>&lt;html</cokw> xmlns=<costring>"http://www.w3.org/1999/xhtml"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;head&gt;</cokw></codeline>
<codeline>  <cokw>&lt;title&gt;</cokw>Caution!<cokw>&lt;/title&gt;</cokw></codeline>
<codeline><cokw>&lt;/head&gt;</cokw></codeline>
<codeline>  <cokw>&lt;body&gt;</cokw></codeline>
<codeline>    <cokw>&lt;h2&gt;</cokw>WAIT JUST A SECOND THERE!!!<cokw>&lt;/h2&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p&gt;</cokw></codeline>
<codeline>      USE EXTREME CAUTION: The potential for intergalactic</codeline>
<codeline>      information broadcast while using the AZGuard</codeline>
<codeline>      Protaxis unit has not yet been fully determined.</codeline>
<codeline>    <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p&gt;</cokw></codeline>
<codeline>      Please avoid transmitting any information that</codeline>
<codeline>      could place the human race at risk.</codeline>
<codeline>    <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/body&gt;</cokw></codeline>
<codeline><cokw>&lt;/html&gt;</cokw></codeline>
</processedcode>
<?location Introduction.pml@118 ?>


    <p>So what's the magic spell that gets us from the XML to the web view? XSLT, right? Well, yes and no. At
      a very high level, several things have to happen to get the HTML to come out:</p>
    <ol>
      <li>
        <p>An XML parser reads in the XML and constructs a complete XML tree structure for the XSLT processor
          to use.</p>
      </li>
      <li>
        <p>An XSLT processor reads in the XSLT stylesheet.</p>
        <!-- This may not be completely accurate. -->
      </li>
      <li>
        <p>The XSLT processor moves through the XML tree and applies the appropriate rules from the XSL
          stylesheet to what it finds in the XML.</p>
      </li>
      <li>
        <p>As it applies the rules, the XSLT processor assembles the HTML (or whatever sort of output we're
          constructing) that is specified in the rules, then writes it out somewhere---hopefully somewhere we
          can use it!</p>
      </li>
    </ol>
    <p>That's a way oversimplified description of the XSLT process, but it will get us through for the moment.
      The point is that to get our HTML output, we need XSLT, but we also need some tools to run the XSLT.
      We'll get to the tools later; for the purpose of our example, let's just look at the XSLT that the tools
      will run:</p>

<processedcode language="xml" showname="Introduction/caution1.xsl" style="normal" url="Introduction/caution1.xsl">
<codeline>&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring></codeline>
<codeline>  xmlns=<costring>"http://www.w3.org/1999/xhtml"</costring></codeline>
<codeline>  version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"note[@type='caution']"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;html&gt;</cokw></codeline>
<codeline>    <cokw>&lt;head&gt;</cokw></codeline>
<codeline>      <cokw>&lt;title&gt;</cokw>Caution!<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/head&gt;</cokw></codeline>
<codeline/>
<codeline>    <cokw>&lt;body&gt;</cokw></codeline>
<codeline>      <cokw>&lt;h2&gt;</cokw>WAIT JUST A SECOND THERE!!!<cokw>&lt;/h2&gt;</cokw></codeline>
<codeline>      <cokw>&lt;p&gt;</cokw><cokw>&lt;b&gt;</cokw>USE EXTREME CAUTION:<cokw>&lt;/b&gt;</cokw><cokw>&lt;/p&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/body&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/html&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"p[not(position() = 1)]"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/p&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"bold"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;b&gt;</cokw><cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw><cokw>&lt;/b&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location Introduction.pml@146 ?>


    <p>First, taking a high-level look at the XSLT example, let's see what we can learn from it.</p>

    <p>You can see that XSLT is itself a form of XML. An XSLT document must be a well-formed XML document;
      however, unlike XML, XSLT can contain a lot of other stuff, so it can't really be validated against a
      DTD or schema. However, it must still fit the definition of a well-formed XML document.<footnote>
      <p>See <url>http://www.w3schools.com/xml/xml_dtd.asp</url> for a short comparison between a well-formed
        XML document and a valid XML document.</p>
      </footnote> </p>

    <p>For another thing, an XSLT transform always has the <xmltag>xsl:stylesheet</xmltag> tag as its root
      element. The stylesheet is the XSLT equivalent of a program, and the <xmltag>xsl:stylesheet</xmltag> tag
      contains the details of the program. Later we'll see that we can import multiple stylesheets into a
      single stylesheet, but the point is still valid: everything in XSLT takes place inside
      <xmltag>xsl:stylesheet</xmltag> tags.</p>

    <p>Within the <xmltag>xsl:stylesheet</xmltag> tag, there can be a variety of other tags, but there is
      usually always at least one <xmltag>xsl:template</xmltag> tag. Templates do most of the heavy lifting in
      XSLT. We'll dig into the structure of templates in the next chapter.</p>

    <p>You'll also notice that the XSLT tags (in this book) all begin with the <string>xsl:</string> string.
      This string identifies the XSL tags as belonging to the XSL namespace.<footnote>
      <p><string>http://www.w3.org/1999/XSL/Transform</string></p>
      </footnote> You'll frequently find yourself using other namespaces in an XSL document---in fact, the
      example document uses the xhtml: namespace for outputting HTML tags. The namespace prefix helps
      distinguish the XSL elements from other namespace elements. You could set up a stylesheet to omit the
      xsl: prefix, but then you'd have to deal with namespace issues for other kinds of tags you might want to
      use. Do yourself a favor: stick with the xsl: prefix and don't worry about it. </p>

    <!-- Strictly speaking, if you declare the namespace at the top of the stylesheet, you don't need
      to show the namespace for each tag, but I find it can get very confusing when you are working in the
      same stylesheet with XSLT elements and HTML elements or other XML elements for output. In this book, I
      will always show the namespace of XSLT elements, just so there's no question about what is what. -->

    <p>In <ref linkend="chap.creatingoutput"/>, we'll have a closer look at the example I showed above. But at
      the moment, let's take a look at XSLT from a slightly broader perspective, starting with the XSLT
      processor. </p>

  </sect1>

  <sect1>
    <title>Processing XSLT</title>

    <p><author>add a quick rundown on what the XSLT processor is and what it does.</author></p>

    <p>There are a number of ways to handle XML besides XSLT: brute-force programming with your language of
      choice, XSLT-based add-ons to other languages (such as Java's XSLT Module or JAXP, the Android
      XmlPullParser, and Ruby's Nokogiri parser), conversion tools, and so forth. I won't go into those a lot
      except to say that many of the concepts discussed in this book will transfer readily to those tools
      because they all need to deal with the same problems.</p>

    <p>The XSLT covered in this book is mostly XSLT 1.0, which has been around a long time (since 1999, which
      is forever in the software world). The reason for spending time with this version of XSLT is not only
      that it forms the basis for later versions of XSLT, but most web browsers only support XSLT 1.0. So if
      your intent is to let the browser do the processing, you're stuck with XSLT 1.0. And to tell you the
      truth, until you start wanting to do fairly complex things like sorting and grouping, XSLT 1.0 will
      accomplish most of what you need.</p>

    <p>(That being said, XSLT 2.0 includes some very cool stuff that will make your life much easier when you
      hit some of the more difficult problems. We'll have a quick look at XSLT 2.0 later in this book.)</p>

    <p>If you don't need a browser to do your processing, and you're free to use stand-alone processors, there
      are a variety of options. Some XSLT processors even support subsets of the yet-to-be released XSLT 3.0.
      We'll cover a range of the available XSLT processors when we get ready to install a stand-alone
      processor in X<!-- <ref linkend="chap.otherstuff"/> -->. Some are free, while others will be the subjects
      of painfully long corporate acquisition committee meetings. For this book, we'll go with free.</p>

    <p>In this book, you'll need a stand-alone processor eventually because we're going to want to see the
      interim results of the transformations, not just the renderings that the browser gives. And in many
      cases, we won't be transforming the content into HTML at all.</p>

    <p>For the first couple of chapters, though, we're going to do it the easy way. We'll use a standard web
      browser so you don't have to install anything to get started. Just check it out and enjoy the magic.</p>

    <joeasks id="joe.why-not-chrome">
      <title>What Browsers Will Run XSLT?</title>
      <p>To find out more about which browsers support XSLT, 
        check out  <url>http://www.w3schools.com/xsl/xsl_browsers.asp</url>. You'll find plenty to choose from---but be careful 
        about using Google Chrome. </p>
      <p>Although Chrome is listed as supporting XSLT 1.0, it contains a controversial bug/feature that
        prevents it from working with local XSLT files (see
        <url>http://code.google.com/p/chromium/issues/detail?id=111905</url> for the painful details). 
        It will run XSLT if the XSLT is running on a server somewhere, but not if the XSLT is a local file.
        For this reason, I do not recommend trying to use Google Chrome for the examples in this book---because it
        won't work.</p>
    </joeasks>
    <!-- 
      Update: IBM's WebSphere 7 XML Feature Pack
        such as Saxon 9.x,<footnote><p><url>http://www.saxonica.com/welcome/welcome.xml</url></p></footnote>
      Gestalt,<footnote><p><url>http://gestalt.sourceforge.net/</url></p></footnote> Altova RaptorXML,<footnote><p><url></url></p></footnote> 
      There are six known XSLT 2.0 processors at this date:
      
      Saxon 9.x by Michael Kay, Java
      Altova(XMl-SPY)'s AltovaXML2009.exe, non-Java 
      Gestalt by Colin-Paul Adams, Eifel
      IBM's WebSphere 7 XML Feature Pack, Java :RETIRED
      Intel's SOA Expressway
      XQSharp 2.0 by Clinical & Biomedical Computing Ltd, non-Java (.NET)
      
      Of these Saxon and IBM's xslt processor are written in Java. Altova2009 is said to have "Java interface".
    
    -->
    <!-- <p>With XSLT being so old, and XML being everywhere out there in the world</p>
    preface stuff -->
  </sect1>
  
  <sect1>
    <title>A Few Words about This Book</title>

    <p>XSLT does not have a large vocabulary, but it's still a fairly complex language. I can't cover
      everything there is to cover about XSLT in this book, even if I had the knowledge to do so. Instead, I
      hope to help make your first steps along the path of learning this language a little easier than it was
      for me and a lot of others like me. To that end, this book will necessarily simplify a few concepts,
      avoid deep dives into certain areas (it can get pretty gnarly down in those rat-holes!), and
      occcasionally use idealized examples when we all know that the real world just isn't that easy.</p>

    <p>Honestly, I would say that a large percentage of what you'll encounter in your daily work will be
      easily managed with the aspects of XSLT that we cover in this book. But there's no question that you're
      going to run into some serious groaners. My hope is that by getting through the first phases of the
      learning process a little more quickly, you'll be better prepared to handle the Gordian knots of the
      trickier problems you're likely to encounter. (Hint: get a sharper sword!)</p>

    <p>XSLT has the reputation of being difficult to learn at the beginning because it seems like you need to
      learn everything all at the same time. It's difficult to start with just one little piece. But that's
      what we're going to do---to work with a basic concept (how to output data), then build slowly on that.
      I'll rely heavily on examples so you can see the ideas in action. </p>

    <p>Because XSLT and XML tend to be verbose, I will occasionally refer to the code repository maintained by
      the Pragmatic Bookshelf (for which much thanks) to show more elaborate examples in full. You'll find
      URLs and links to these code examples throughout the book.</p>

    <p>I want to keep the examples as "real-world" as possible (although in the world of computing, anything
      is possible). To this end, I'll frequently use examples taken from my own working life and from examples
      I've encountered from other people. Even when we are breaking things down into little bits, I'll try to
      show how these bits connect to the larger picture, and why these bits are important.</p>

    <p>Toward the end of this book we'll go beyond the building-block lessons of the basic mechanics of XSLT.
      We'll explore established techniques for solving common types of problems, we'll look at troubleshooting
      strategies, and we'll think in large-scale terms about how to set up extended transformational systems
      with an eye toward re-usability, maintenance, and documentation.</p>

    <p>Let's take a look at the specific chapters, then, and where they will take us.</p>

  </sect1>

  <sect1>
    <title>And So Forth...</title>
  </sect1>


</chapter>
<?location howitlooks.pml@3 ?>

<chapter id="chap.howitlooks">
  <title>XSLT in Action</title> 
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext><p>Instead of progressing in a sane and dignified manner, my attempts to walk resulted in a variety of hops which took me clear of the ground a couple of feet at each step and landed
      me sprawling on my face at the end of each second or third hop...and so I hit upon the unique plan of reverting to first principles in locomotion, creeping.</p></epitext>
  </epigraph>
  <!-- 
   <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>To get my hands on an XSLT stylesheet, run it, and see how it works in real life. Also to develop a
          deeper understanding of the XSLT processing model, at the template level.</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>How to run an XSLT stylesheet against and XML file, what templates are, and how they match against
          the XML file to process XML content.</p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <ul>
          <li>
            <p>Run an XSLT stylesheet to process an XML file and display the results in a web browser.</p>
          </li>
          <li>
            <p>Understand how templates match against XML structures to process the XML content.</p>
          </li>
        </ul>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>Now that we understand the processing model, we're going to apply the model to different methods of
          getting output from the source XML.</p>
      </dd>
    </dl>
  </storymap>
 -->
  <p>Enough preliminaries. Time to do some real work.</p>

  <p>In the following sections we’re going to set up a simple stylesheet, apply it against a simple XML
    document, and get a simple result. In the process, we're going to do a deep dive into how the XSLT
    processor simultaneously handles an XSLT stylesheet and an XML document, working its way through both of
    them in a concerted fashion to get the final results.</p>

  <p>Understanding how the XSLT processor moves through the XML file and matches the XML with templates in the
    XSLT stylesheet will give you a good foundation for understanding how the rest of XSLT works.</p>

  <p>While we're covering these basic concepts, we'll look at the roles of the <xmltag>xsl:template</xmltag>
    tag, the <xmlattr>match</xmlattr> attribute, and the <xmltag>xsl:apply-templates</xmltag> tag, three XSLT
    components at the core of how XSLT functions.</p>

  <p/>
  
  <sect1>
    <title>The Parts of a Transformation</title>
   
    <p>To get a sense of how XSLT works on an XML document, we'll start with a small example of XML, then apply 
    some XSLT to it to get a result.  Our example XML is a customer address.  Perhaps we've been asked to make a “heat map”
    of where our customers live, so we need to produce a list of our customer postal codes. </p>

  <sect2>
    <title>Starting with XML</title>
    
      <p>First let’s have a look at the first XML document we’ll transform with our stylesheet. For clarity in
      our first example, we'll use an entry for a single customer's profile information:</p>

    <figure id="code.bib1.xml">
      <title>XML for a Customer</title>
<processedcode language="xml" showname="no" style="normal">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="bib1.xsl"?&gt;</codeline>
<codeline>   <cokw>&lt;customer&gt;</cokw></codeline>
<codeline>      <cokw>&lt;name&gt;</cokw></codeline>
<codeline>        <cokw>&lt;first&gt;</cokw>Sherlock<cokw>&lt;/first&gt;</cokw></codeline>
<codeline>        <cokw>&lt;middle&gt;</cokw><cokw>&lt;/middle&gt;</cokw></codeline>
<codeline>        <cokw>&lt;last&gt;</cokw>Holmes<cokw>&lt;/last&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;address&gt;</cokw></codeline>
<codeline>        <cokw>&lt;street&gt;</cokw>221b Baker Street<cokw>&lt;/street&gt;</cokw></codeline>
<codeline>        <cokw>&lt;city&gt;</cokw>London<cokw>&lt;/city&gt;</cokw></codeline>
<codeline>        <cokw>&lt;state&gt;</cokw><cokw>&lt;/state&gt;</cokw></codeline>
<codeline>        <cokw>&lt;country&gt;</cokw>England<cokw>&lt;/country&gt;</cokw></codeline>
<codeline>        <cokw>&lt;postalcode&gt;</cokw>W1U<cokw>&lt;/postalcode&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/address&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/customer&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@93 ?>

    </figure>

    <p>The first two lines set up the file. The first line alerts any file processor that this is an XML file,
      using XML version 1.0 and a character encoding of UTF-8, all standard XML stuff. The second line is more
      important to our XSLT interests: it instructs an XSLT processor to use a particular stylesheet if one has
      not already been specified. We'll take advantage of this line to run our XML and XSLT files in a web
      browser. This will eliminate the need, for the moment, to set up a stand-alone XSLT processor. </p>

    <p>Now we get to the substance of the file. In our little XML file, you can see that the XML has a root
      tag, <xmltag>customer</xmltag>, which contains a <xmltag>name</xmltag> tag and a <xmltag>title</xmltag>
      tag. The <xmltag>name</xmltag> tag in turn contains three other tags, which contain text for the
      customer's first, middle, and last names. The <xmltag>address</xmltag> tag, naturally, contains
      additional tags for the text of the customer's address.</p>

    <p>The structure of this file will be important for how our stylesheet transforms it, so take a little
      time to check it out.</p>

    <p>In fact, understanding the structure of the source is a good habit that we should carry over to all of our XSLT work:
       XSLT stylesheets work best
      with known XML structures. The XML source should have a DTD, schema, or other structured definition, so
      we know what elements and attributes we'll need to deal with in our XSLT stylesheet. Without being based
      on a known structure, the stylesheet may encounter bits of XML structure that it's not set up to
      handle.</p>
      
      <p>If you are confronted with a piece of XML and don't have a DTD or schema for it, you can create one
        by running appropriate software against your XML samples. XML editing software such as oXygen and Stylus Studio often have this capability built into them,
        and various standalone DTD generators are available.<footnote><p><url>http://stackoverflow.com/questions/1815216/how-to-derive-dtd-or-other-xml-spec-format-from-xml-file-samples</url></p></footnote> </p>

  </sect2>

  <sect2>
    <title>Setting Up an Example XSLT Stylesheet</title>
    <p>Now let’s set up a stylesheet to transform the XML into something else. Suppose we just want to see
Now let’s set up a stylesheet to transform the XML into something else. Suppose we just want to see
      only the postal codes of where our orders are going to. The stylesheet might look like this: </p>


<processedcode id="code.bib1.xsl" language="xml" showname="no" style="normal">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline id="code.first-xsl" lineno="2" prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw> </codeline>
<codeline id="code1.template1" lineno="3" prefix="-">    <cokw>&lt;xsl:template</cokw> match=<costring>"/customer"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code1.apply-template1" lineno="4" prefix="-">        <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="5">    <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-">    <cokw>&lt;xsl:template</cokw> match=<costring>"address"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"postalcode"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="10"/>
<codeline prefix="-">    <cokw>&lt;xsl:template</cokw> match=<costring>"postalcode"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code1.match-author" lineno="15" prefix="15">    <cokw>&lt;xsl:template</cokw> match=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@151 ?>


    <p>That's a lot of stuff to understand right out of the box. At the moment, though, I'd like you to focus
      on the fact that there are four <xmltag>xsl:template</xmltag> tags, and each of them has a <xmlattr value="something">match</xmlattr> attribute. We're going to walk through what those mean and how they
      work to process the XML document. </p>

    <p>But hey, first let's see whether this thing actually works.</p>

    <p>To run the XSLT stylesheet, let's just open the XML document with a web browser. As we said, the second
      line in our XML file tells the browser what stylesheet to run against the XML.</p>

    <p>To keep things easy, we've stored our <filename>bib1.xsl</filename> file in the same directory as the
      XML file, so the <xmlattr>href</xmlattr> attribute in the <xmltag>?xml-stylesheet</xmltag> tag (in line
      <cref linkend="code.first-xsl"/> of the XML file) only gives the name of the stylesheet. All we have to
      do is put the path to the XML file (including the file name) into the URL area of the browser. In my case, 
      it's <string>C:/dkxslt/Book/code/howitlooks/bib1.xml</string>.
    </p>
      
    
    <p>If you're lazy like me, and your operating system allows it, you could just drag the file icon from a
      file browser to the open web browser. Here's how it looks in Mozilla Firefox:</p>

    <figure id="fig.example1">
      <title>The Results of Our First XSLT Transformation</title>
      <imagedata border="yes" fileref="images/howitlooks/bib1.png"/>
    </figure>

    <p>Great! That's what we wanted, all right. But how did we get it? </p>
 

    
   
  </sect2>
<sect2>
 
    <title>Following the Transformation in Detail</title>

    
    <p>This example probably looks easy, but a lot of stuff had to work for us to get the result. Check it
      out:</p>

    <ol>
      <li>
        <p>The web browser had to know the document was an XML document. The first line in the XML file took
          care of that for us.</p>
      </li>
      <li>
        <p>The web browser had to know what stylesheet to apply to the XML document. The second line took care
          of that for us.</p>
      </li>
      <li>
        <p>The web browser had to know how to run an XSLT stylesheet against an XML document. Fortunately, most
          web browsers these days have XSLT processors built into them, which is convenient. Setting up an XSLT
          processor isn't difficult (in fact, we'll do it in <ref linkend="chap.standalone"/>. But if you're learning or
          just want to check out a simple piece of XSLT, bang!, it's a quick solution.
          <!--The only
          caveat is that most web browsers support only XSLT 1.0. That's fine for us- - -we're just learning,
          and for the most part, XSLT 1.0 will take care of almost anything you're likely to encounter for a
          while.  --></p>

      </li>
      <li>
        <p>The stylesheet had to specify which parts of the XML document we wanted to keep, and which parts we
          wanted to ignore. The main body of the stylesheet, the <xmltag>xsl:template</xmltag> tags, provided
          those instructions to the XSLT processor.</p>
      </li>
      <li>
        <p>Finally, the XSLT processor had to send some output to the web browser to display and tell it how to
          format the output. We didn't do a lot of output manipulation with this particular example---we just
          sent it a single line of text. But eventually we're going to need to create some complex forms of
          output, so it will pay us to learn a little bit about the output process and how it is controlled.
          We'll cover some output controls later in this chapter and more advanced output controls in <ref linkend="chap.creatingoutput"/>.</p>
      </li>
    </ol>

    <p>Those are background details that the browser and the XSLT processor take care of. Most of this happens
      automatically. For instance, we don't really need to know where the browser's XSLT processor is located
      and how the browser invokes it. What we're more interested in are the parts we control ourselves, in
      particular those <xmltag>xsl:template</xmltag> tags, their contents, and how they gave us our result. </p>

    <p>So first let's look at the overall XSLT process for our example. Then let's look at some details of the
      <xmltag>xsl:template</xmltag> tag, the <xmlattr>match</xmlattr> attribute, and the
      <xmltag>xsl:apply-templates</xmltag> tag.</p>
</sect2>
   </sect1>

    <sect1>
      <title>XSLT Processing: Looking under the Hood </title>

      <p>One way to think about XSLT processing is to think of the XML as a stream of coins or tokens, all
        sizes and shapes, and the XSLT templates as a series of slots of corresponding sizes and shapes. </p>

      <p><ref linkend="fig.conceptual-process-diagram" thispage="yes"/> shows the XML as a group of connected
        objects, essentially a set of connected tokens. The different parts of the XML appear in this diagram
        with different shapes. At the same time, the XSLT side of the figure contains slots of corresponding
        shapes that allow the different parts of the XML to “fall through.”</p>

      <figure id="fig.conceptual-process-diagram" place="top">
        <title>An XML structure matched by XSLT templates</title>
        <imagedata fileref="images/howitlooks/conceptual-process-diagram.pdf" width="85%"/>
      </figure>

      <p>A couple of things you'll note immediately:</p>

      <ul>
        <li>
          <p>The stylesheet doesn't have templates for all of the XML elements.</p>
        </li>
        <li>
          <p>The templates in the stylesheet aren't structured the way the XML is structured. In fact, they
            aren't explicitly connected at all. We'll see the advantage of this arrangement in a moment.</p>
        </li>
      </ul>

      <p>To understand how our example worked, let's see what happens when we start “dumping” the
        XML into the stylesheet. For this analogy to work, you might think of the XML as being turned upside
        down, with gravity pulling the <xmltag>customer</xmltag> tag in first, then everything else following
        in <firstuse>document order</firstuse>. The term document order describes the order the XML is handled by the XSLT processor,
      and it's worth spending a little time to understand what it means.</p>

          <p>The XSLT processor typically parses the XML document into a document tree. The document tree for our
          sample document, for instance, would look like this:</p>

        <imagedata fileref="images/howitlooks/bib1-tree.png"/>
    
      <p>If the document were processed in hierarchical order, the top-level tag in the document
        (<xmltag>bibliography</xmltag>) would be processed first, followed by the two tags at the next level in
            the document (<xmltag>author</xmltag> and  <xmltag>title</xmltag>), followed by the third-level tags, and so forth. 
            In document order, the order of processing is from the top branch down and to the right as
            far as possible, then back up to the next-topmost, unprocessed element in the
            tree, and so forth.  It seems too sensible to be true, but every now and then there is a
            reassuring sense of order in XSLT.</p>
      

      
 <p>So now let's walk through the process in detail, with our XML being dumped into the stylesheet in document order:</p>

      <ol>
        <li>
          <p>The document root and <xmltag>customer</xmltag> tag come first, and immediately we find a
            template that matches both in the stylesheet. In the XSLT, this template looks like this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/customer"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@298 ?>


          <p>Great! With this match, we have changed the context for execution to the
            <xmltag>customer</xmltag> tag. The rest of the XML “falls through,” and gets processed
            according to the instructions inside the template. In this case, the instructions are
            <xmltag>xsl:apply-templates</xmltag>, so the XSLT processor looks for templates to match whatever
            comes next in the XML document.</p>
        </li>
        <li>
          <p>Next, the processor comes to the <xmltag>name</xmltag> tag and finds a template that matches
            it:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@313 ?>


          <p> Also fine---except we didn't want any of the name in our report. So this template is empty. We
            don't do any more processing, and the <xmltag>first</xmltag>, <xmltag>middle</xmltag>, and
            <xmltag>last</xmltag> tags are forever after ignored.</p>
        </li>
        <li>
          <p>The XML keeps streaming along, and next up is the <xmltag>address</xmltag> tag. Yep, we find a
            template that fits, so we do whatever the template says:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"address"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"postalcode"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@327 ?>


          <p>The template for <xmltag>address</xmltag> has an instruction to apply templates, but it includes
            a qualifier, the <xmlattr value="postalcode">select</xmlattr>. This instruction tells the XSLT
            processor to go off looking for templates again, but this time, it will only look for a template
            that matches <xmltag>postalcode</xmltag>.</p>

          <p>If we left off the <xmlattr value="postalcode">select</xmlattr> attribute, the XSLT processor
            would apply templates for all of the XML that it finds inside the <xmltag>address</xmltag> tag.
            Since we're only interested in the postal code, we use the <xmlattr>select</xmlattr> attribute to
            narrow the scope of what will be processed inside the <xmltag>address</xmltag> tag.</p>
          <p>In fact, you can try this yourself. Going back to the stylesheet in <ref linkend="code.bib1.xsl"/>, delete the template that matches on <xmltag>address</xmltag>, then process the XML file again.
            (If your browser is still up from the first time you ran it, and the result is still visible, you
            can just refresh the browser.) Do you see what happens?</p>
        </li>
        <li>
          <p>We sent the processor off to match against the <xmltag>postalcode</xmltag> tag, and now we've
            found it. Our stylesheet does only one thing: return the value of the <xmltag>postalcode</xmltag>
            tag. The <xmltag>xsl:apply-templates</xmltag> in the template for <xmltag>postalcode</xmltag>
            returns the text for us---we'll get to how that works in a short while. In the meantime: mission
            accomplished. We have the value of the postal code from the file.</p>
        </li>
      </ol>

      <p>That's the general outline of how XSLT processing works: match some XML with a template, do some work
        inside the template, then get instructions inside the template for what next to do with the XML.
        But it can also do a lot of complicated stuff within this basic processing pattern.</p>

      <p>The interesting trick here is that we don't necessarily need to know how many of a given tag there
        are in the XML, or in what order they occur. Because of the <xmltag>xsl:apply-templates</xmltag> tag,
        and because the templates aren't explicitly connected to each other, the XSLT processor just takes
        things in the order they come, and does its best to find templates to match. If it finds a match, it
        follows the instructions then goes to the next piece of XML; if it doesn't, the processing stops
        following the branch at that point in the structure of the XML, then goes on to whatever branch in the
        XML comes next. It's this flexibility to follow XML wherever it goes that gives XSLT a big part of its
        power.</p>

    </sect1>

    <sect1>
  <title>XSLT Components at the Heart of the Process</title>
  
  <p>We've now seen the core components that animate the XSLT process:</p>
  <ul>
    <li><p>Templates, defined by the <xmltag>xsl:template</xmltag> tag, contain most of the action instructions for the stylesheet.</p></li>
    <li><p>The <xmlattr>match</xmlattr> attribute of <xmltag>xsl:template</xmltag> associates a template with nodes in the XML document.</p></li>
    <li><p><xmltag>xsl:apply-templates</xmltag> and its <xmlattr>select</xmlattr> attribute send the processor to 
      find more templates and continue processing the XML document.</p></li>
  </ul>
  
  <p>Let's take a look at each of these core XSLT components in more detail to understand the ins and outs of how they work.</p>  
    

  <sect2 id="sect2.template-in-detail">
      <title>The <xmltag>xsl:template</xmltag> Tag in Detail</title>

      <p>Templates are the basic working unit of a stylesheet. As we saw, an XSLT stylesheet is made up mostly
        of templates. In our example, the templates were defined by <xmltag>xsl:template</xmltag> tags with
        <xmlattr>match</xmlattr> attributes. These templates corresponded, in turn, to pieces of our XML file. </p>

      <p>Templates provide three types of functions in the XSLT process, not all of which have to be present in
        a given template:</p>

      <ul>
        <li>
          <p>The <xmlattr>match</xmlattr> or <xmlattr>name</xmlattr> attribute (or both) tells the XSLT process
            when to use the template.</p>
        </li>
        <li>
          <p>Inside the template, some additional work gets done. This work might be any of the following
            types of functions:</p>
          <ul style="compact">
            <li>
              <p>Creating output</p>
            </li>
            <li>
              <p>Setting up variables</p>
            </li>
            <li>
              <p>Performing calculations or other functions</p>
            </li>
            <li>
              <p>...And a host of others</p>
            </li>
          </ul>
        </li>
        <li>
          <p>One or more instructions invoke other templates to process more of the XML document.</p>
        </li>
      </ul>

      <p>Templates can be used in other ways than just matching elements. You can call them explicitly to do
        work of different sorts, and you can specify <firstuse>modes</firstuse> for them to enable you to
        process a given XML element more than one way. Most of the work we'll do in XSLT takes place in
        templates, as we will see throughout the rest of this book.</p>

      <p>At the moment, though, let's concentrate on the most important aspect of templates for the purposes
        of the XSLT process: the <xmlattr>match</xmlattr> attribute. </p>
    </sect2>

    <sect2>
      <title>The <xmlattr>match</xmlattr> Attribute</title>

      <p>The <xmlattr>match</xmlattr> attribute is one of the functions that makes XSLT flexible enough to
        handle the flexibility of an XML document. As we saw, it provides the means for the XSLT processor to
        identify which template is appropriate for processing a given piece of XML. </p>

      <p>Here are a few points to keep in mind about the <xmlattr>match</xmlattr> attribute to keep our XSLT
        happy:</p>

      <dl style="bold">
        <dt newline="yes">Matches in the XSLT occur within the current context of the XML.</dt>
        <dd>
          <p>A given piece of XML matches on the template only when that piece of XML is within the current
            context of the XSLT processor. In our example, when we've already matched on the
            <xmltag>customer</xmltag> tag, the current context is <xmltag>customer</xmltag>; when we specify
            <xmltag>xsl:apply-templates</xmltag>, the XSLT processor looks for a template that matches anything
            in the current context.</p>
          <p>XML items within the current context include attributes of the element we have matched, any text
            immediately inside the matched element, and any elements that are immediate children of the
            current context. In our example, the <xmltag>name</xmltag> and <xmltag>address</xmltag> tags are
            within the current context; however, the <xmltag>postalcode</xmltag> tag is not. If we don't match
            on the <xmltag>address</xmltag> tag at this point, the XSLT processor will never have the
            <xmltag>postalcode</xmltag> tag within its current context, and it will never get to our template
            that matches <xmltag>postalcode</xmltag>.</p>
        </dd>

        <dt newline="yes">Using XPath in the <xmlattr>match</xmlattr> attribute, you can match any part of the
          XML document from any other part of the XML document.</dt>
        <dd>
          <p><firstuse>XPath</firstuse>? I thought we'd already mentioned all the X-languages in this
            book!</p>
          <p>XPath is a language that provides a syntax for referring to the parts of an XML document. In a
            way, it's a lot like the syntax you use for describing files in a file system, but tailored to
            refer to XML nodes instead. </p>
          <p>Let's take a look at our example again. We wanted our stylesheet to retrieve only the contents of
            the <xmltag>postalcode</xmltag> tag. We could actually have done that much more easily if we had
            used the / symbol from the XPath syntax in the <xmlattr>match</xmlattr> attribute. (We'll learn more about 
            XPath in <ref linkend="chap.xpath-order"/>, but for now just think about the slash acting like it does in a file path.) Using the / symbol, 
            we can string together nodes to represent parents followed by children, followed by subchildren, like this:</p>
            

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/customer/address/postalcode"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@474 ?>


          <p>The only thing that gets matched in this example is the <xmltag>postalcode</xmltag> tag, but here we are matching it when the current node is the document root.
            If the root contains a <xmltag>customer</xmltag> with an <xmltag>address</xmltag> inside it and a <xmltag>postalcode</xmltag> inside that, we have a match.
            And that's it! Using XPath, we could retrieve the postal code with a single template!</p>
          
          <p>The / is just one of many operators and functions that XPath offers. As mentioned, it allows you to address practically any node or node set 
            when the current context is any other node.  And that makes it incredibly powerful.
          </p>
          
          <p>
            For the moment, the fact to take away is that XSLT is not limited to processing
            the XML in the order it is given. With XPath, you can turn the XML around into completely new
            forms. And the <xmlattr>match</xmlattr> attribute is one of the pivotal points that helps make
            that happen.</p>
        </dd>

        <dt newline="yes">When the XSLT processor matches an element, the current context changes to that
          element.</dt>
        <dd>
          <p>Only two instructions in XSLT can change the node currently being pointed to by the XSLT: the
            <xmltag>xsl:template</xmltag> tag with a <xmlattr>match</xmlattr> attribute, and an instruction
            called <xmltag>xsl:for-each</xmltag>, which we will see later. </p>

          <p>For this reason, the <xmlattr>match</xmlattr> attribute is absolutely necessary for the XSLT
            processor to work its way through the XML file in the order of the XML nodes.</p>

          <p>You could explicitly change the context by means of XPath within other instructions, but that
            would go against the design principles of XSLT. In general, it's best to use the combination of
            <xmltag>xsl:apply-templates</xmltag> and <xmltag attrs="match=“some-tag”">xsl:template</xmltag> to allow the XSLT processor to follow the order of the XML nodes as they
            occur in the file...because who knows what shape those XML files are going to be in?</p>
        </dd>
      </dl>
    </sect2>

    <sect2>
      <title>The <xmltag>xsl:apply-templates</xmltag> Instruction</title>
      <p>We've seen that the central processing model in XSLT is to match XML, do some work, then keep going
        through the XML. The primary means by which the processing "keeps going" is by the use of the
        <xmltag>xsl:apply-templates</xmltag> instruction.</p>

      <p>When the XSLT processor encounters <xmltag>xsl:apply-templates</xmltag>, it uses its current position
        in the XML to look for what XML node is next for it to process. It then looks at what templates are
        available in the stylesheet to see whether there is a match for the next XML node. If it finds a
        matching template in the XSLT, it applies it to that node. And that's all perfectly straightforward.
        Cake, right? </p>
      <p>Well...it turns out that <xmltag>xsl:apply-templates</xmltag> comes with a few zingers. But that's
        what we're here for, right? To de-zingify---er, <emph>demystify</emph> these things.</p>
      <p>As we did with the <xmlattr>match</xmlattr> attribute, we'll list some points to remember about
        <xmltag>xsl:apply-templates</xmltag>. </p>

      <dl style="bold">
        <dt newline="yes">Used without modifiers, <xmltag>xsl:apply-templates</xmltag> tells the XSLT processor to find a
          match for the next XML node of any type, looking for any template available.</dt>
        <dd>
          <p>The plain old <xmltag>xsl:apply-templates</xmltag> is indiscriminate: it takes any XML that comes
            its way and uses any template match it can get its hands on. This is useful when you have no idea
            what's coming, and you want to handle all of it.</p>
        </dd>

        <dt newline="yes">The <xmlattr>select</xmlattr> attribute limits the scope of what XML tags
          the <xmltag>xsl:apply-templates</xmltag> instruction processes.</dt>
        <dd>
          <p>What if you don't want to handle all of the XML that comes along? </p>

          <p><xmlattr>select</xmlattr> specifies the XML node or <firstuse>node-set</firstuse> that will be
            processed. (A node-set is a group of nodes that can be identified by a description using
            XPath---which we'll see more of later.)</p>
          <p>The node or node-set specified by <xmlattr>select</xmlattr> need not necessarily be within the
            current context. </p>

          <p>In our example, once we matched on <xmltag>address</xmltag>, we only wanted to match on the
            <xmltag>postalcode</xmltag> tag and ignore the rest of the elements at that level. In that case,
            we used the <xmlattr>select</xmlattr> attribute to narrow down what we wanted to match within that
            context.</p>

          <p>Going back to our coins and slots, think of the <xmlattr>select</xmlattr> attribute as a
            "hole-maker" that stamps a slot only for the shapes of tokens we're interested in. Items that
            don't match the slots we've stamped out at that point don't make it through. They get discarded
            into that bin at the bottom where the bent coins, slugs, and foreign look-alikes fall out. For 
            our needs, they're worthless.</p>
        </dd>

        <dt newline="yes">The <xmlattr>mode</xmlattr> attribute allows you to create multiple templates that match the same
          element, with each template doing different work. </dt>

        <dd>
          <p>The <xmlattr>mode</xmlattr> attribute on <xmltag>xsl:apply-templates</xmltag> says to match only
            on templates that also have a <xmlattr>mode</xmlattr> attribute with the same name.</p>

          <p>A common example of how this is used is when creating a table of contents for a document.
            Templates without nodes might be used to process the body of the document, but templates for the
            table of contents need to operate on the same set of XML tags. To operate on the XML for the table
            of contents, you would create the instruction <ic>&lt;xsl:apply-templates
            mode="contents"/&gt;</ic> where you wanted the table of contents inserted. Then you would create a
            separate set of templates with the <xmlattr value="contents">mode</xmlattr> attribute. These
            templates would match the elements to be represented in the table of contents.</p>
          <p>We'll see examples of the <xmlattr>mode</xmlattr> attribute at work once we get far enough along
            to create more complicated stylesheets.</p>
        </dd>

        <dt newline="yes"><xmltag>xsl:apply-templates</xmltag> invokes XSLT's hidden <emph>default templates</emph>.</dt>
        <dd>
          <p>Here we dip into one of XSLT's dirty little secrets: in addition to the templates that are
            explicitly defined in our stylesheet, XSLT handily (and at times confusingly) includes something
            called <emph>built-in template rules</emph> or <emph>default templates</emph>. These hidden
            templates are always included by default when the XSLT processor runs.</p>

          <p>Referring back to our example, if you match on <xmltag>postalcode</xmltag> and then use
            <xmltag>xsl:apply-templates</xmltag>, you might think there are no further templates to process
            anything within the <xmltag>postalcode</xmltag> tag, so nothing is going to happen. Well, you
            would be wrong (but not alone by any means!).</p>

          <p>The built-in template rules say to the processor, if you find an element and you can't find a
            template, run <string>&lt;xsl:apply-templates/&gt;</string> on that element's children. If you find
            text, output the text and keep going.</p>

          <p>These rules mean that sometimes we get results we might not expect. For
            example, suppose we had put this in our sample stylesheet:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location howitlooks.pml@599 ?>


          <p>The contents of <xmltag>name</xmltag> are <xmltag>first</xmltag>, <xmltag>middle</xmltag>, and
            <xmltag>last</xmltag>; since we don't have any templates that match these, that
            <xmltag>xsl:apply-templates</xmltag> should be ineffective, right? Ah, but don't take my word for
            it, go ahead and alter the sample stylesheet by adding <ic>&lt;xsl:apply-templates/&gt;</ic> into
            the last template, then process the XML again. What you'll see is something like: </p>

          <imagedata fileref="images/howitlooks/default-template-results.jpg"/>

          <p>Possibly useful, but it's not what we said we wanted. The contents of <xmltag>name</xmltag> come
            through, including the text of all its descendants. To prevent the unwanted content, we have to
            stub out that branch of the XML by matching it at the top (<xmltag>name</xmltag>) and then
            purposely omitting <xmltag>xsl:apply-templates</xmltag>.</p>

          <p> This a case where XSLT tries to be a little too helpful behind the scenes, but, to be fair, it's
            also a useful feature if you want to get a all the text from a complex bit of XML, and you don't
            want to have to write templates for every element.</p>

          <p>We can override the default templates by creating our own templates that explicitly match on the
            same things as the default templates. By creating templates for text nodes and for all of the
            elements we're likely to find in an XML document, we can control all the XSLT operations and not
            have to worry about unexpected XML content leaking through into our output. But sometimes that's
            easier said than done! We'll see a couple of safeguards in <ref linkend="chap.troubleshooting"/> that will help us control any
            “overlooked” XML nodes.</p>
        </dd>
      </dl>

      <p>And that's the <xmltag>xsl:apply-templates</xmltag> instruction. It provides the gravity for our
        stream of tokens, to keep the flow going through our XSLT machine. Get used to the look of it, because
        we're going to use this one a lot. </p>
    </sect2>

</sect1>

  <sect1>
    <title>What We Did</title>
    <p>Wow! That was a lot of work to get a one-line result. We had a lot of new concepts to deal with, so we
      can't expect to have gotten a whole lot done to begin with. The nice thing is that with these basic concepts
      under our belts, we've laid the groundwork for a lot of what we're going to see going forward. </p>

    <p>We went into a good bit of detail about how the XSLT processor handles an XML file and its related XSLT
      stylesheet. The important concept to take away here is how the XSLT processor coordinates between XSLT
      stylesheet templates and the current context of the XML file. There's a lot more to XSLT than that, but
      this is the basic process that makes XSLT go.</p>

    <p>For all the complexity of what the XSLT processor had to do, our example was simple. It
      contained a template that matched the root element of the XML file, which gave the stylesheet an entry
      point into the document. It contained a template that matched one of the root element's child elements,
      but then did nothing. And it matched another child element and rendered the text inside it by using a
      hidden feature of XSLT, a built-in template rule. The result was exactly what we were looking for.</p>

    <p>The example demonstrates some of the basic working principles behind XSLT. The good news is that you'll
      probably only need to read this chapter once. It's a conceptual framework, but it will be helpful for
      understanding many of the complexities that follow. The other good news is that while the
      example in this chapter may have been simple, XSLT has a rich and subtle array of controls that will be
      needed for some of the ridiculously complex XML you are likely to encounter in the real world. These
      controls will be the subject the rest of this book.</p>
  </sect1>
</chapter>
<?location standalone.pml@3 ?>

<chapter id="chap.standalone">
  <title>Installing, Testing, and Using <if-inline target="pdf"><newline/></if-inline> a Stand-Alone XSLT
    Processor</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p>As a matter of fact, it was the only kind of logic that could be brought to bear upon my problem.</p>
    </epitext>
  </epigraph>
<!-- 
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>So far we have only worked with browsers for processing XSLT. Installing a stand-alone XSLT
          processor enables you to process XML/XSLT independently from the browser and to be able to see
          different kinds of output that a browser might not let you see. In the long run, this type of
          processor also enables you to start the XSLT processing by a variety of methods. </p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>What processors you could install (with notes about what each one offers), how to install the Saxon
          home edition (HE) processor, how to test the installation, and different methods for using the Saxon
          HE processor.</p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>Evaluate the different XSLT processors, install the Saxon HE processor, and execute XSLT
          stylesheets using the Saxon HE processor.</p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>We're going to put the stand-alone XSLT processor to use in the chapter on creating output.</p>
      </dd>
    </dl>
  </storymap>
 -->
 
  <p>XSLT processors are the engines that drive XSLT transformations. Without an XSLT processor of some sort,
    XSLT stylesheets accomplish nothing. We can do a limited amount of work with the XSLT processors that are
    built into web browsers, but once we get beyond HTML and text, we're going to want to see results that the
    browser may not be able to display. For example, while developing an XSLT stylesheet, we might
    occasionally make a mistake (yes, it happens). We'd like to see the results for troubleshooting, but the
    erroneous results may not be displayable in a browser. Also, getting the browser to display XML is not
    always as simple as it sounds. </p>

  <p>In this chapter we're going to cover:</p>
  <ul style="compact">
    <li>
      <p>Which XSLT processors are available</p>
    </li>
    <li>
      <p>How to install the Saxon XSLT processor</p>
    </li>
    <li>
      <p>How to test the processor</p>
    </li>
    <li>
      <p>Typical methods of using the processor</p>
    </li>
  </ul>

  <sect1>
    <title>What Processors Are Out There?</title>

    <p>Different people have implemented XSLT processors based on their own needs or the needs of the
      communities they serve. The good news is that there are only a few XSLT processors in widespread use, so
      choosing between them isn't that difficult.</p>

    <p>The differences between XSLT processors are fairly moderate. In general, an XSLT processor is required
      to support, at a minimum, the specification for whatever XSLT version it claims to support, although
      complete support for the specification isn't always a given. In addition, XSLT processors usually offer
      extensions to the XSLT instruction set that you might find useful, and each processor differs.
      Performance is another area where the processors differ (sometimes dramatically). The execution platform
      varies from processor to processor (although two of the most popular, Xalan and Saxon, work with Java).
      And finally, the amount of ongoing support for the different processors varies widely. </p>

    <p>In the following entries, I list the major XSLT processors currently available, with notes about each
      that may affect your own selection of a processor. </p>

    <webresources>

      <webresource>
        <resname>Saxon</resname>
        <resurl>http://saxon.sourceforge.net/</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Supports XSLT 1.0, 2.0, and much of 3.0 (as currently defined)</p>
            </li>
            <li>
              <p>Available in open-source and commercial versions.</p>
            </li>
            <li>
              <p>EXSLT and Saxon XSLT extensions supported in commercial versions.</p>
            </li>
            <li>
              <p>Supported on Java and .NET.</p>
            </li>
            <li>
              <p>A client edition adds XSLT 2.0 support to browsers.</p>
            </li>
            <li>
              <p>Actively supported by Michael Kay, who edited the XSLT 2.0 specification.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>Xalan</resname>
        <resurl>http://xml.apache.org/xalan-j/index.html</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>An open-source XSLT processor supporting XSLT 1.0.</p>
            </li>
            <li>
              <p>Implemented in C++ and Java.</p>
            </li>
            <li>
              <p>Actively supported by the Apache community.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>libxslt</resname>
        <resurl>http://xmlsoft.org/XSLT/</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>libxslt is a free library for the C language.</p>
            </li>
            <li>
              <p>Implements most of the EXSLT extension library<footnote>
                <p> <url>http://www.exslt.org/</url> </p>
                </footnote> as well as a subset of Saxon's XSLT extensions.</p>
            </li>
            <li>
              <p>Considered one of the faster XSLT processors.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>XT</resname>
        <resurl>http://www.blnz.com/xt/index.html</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Supports XSLT 1.0 only.</p>
            </li>
            <li>
              <p>Java-based</p>
            </li>
            <li>
              <p>Advertises itself as "fast."</p>
            </li>
            <li>
              <p>No updates since 2005.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>Altova RaptorXML Server</resname>
        <resurl>http://www.altova.com/raptorxml.html</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Supports XSLT 1.0, 2.0, and a subset of 3.0, as well as other XML-related processing
                specifications.</p>
            </li>
            <li>
              <p>Only available under commercial license.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>MSXML</resname>
        <resurl>http://msdn.microsoft.com/en-US/data/bb190600.aspx</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Window-only application</p>
            </li>
            <li>
              <p>Supports XSLT 1.0 and 2.0.</p>
            </li>
            <li>
              <p>Intended for use with Visual Basic, C, C++, or scripting languages.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>System.Xml in the .NET Framework.</resname>
        <resurl>http://msdn.microsoft.com/en-us/library/2bcctyt8.aspx</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Window-only application</p>
            </li>
            <li>
              <p>Supports XSLT 1.0.</p>
            </li>
            <li>
              <p>Intended for use with managed code targeting the .NET Framework in C#, Visual Basic, J#,
                managed C++, or other managed languages.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>Xuriella</resname>
        <resurl>http://common-lisp.net/project/xuriella/</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>A Lisp-based XSLT processor</p>
            </li>
            <li>
              <p>Supports XSLT 1.0.</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
      <webresource>
        <resname>Web browsers</resname>
        <resurl>http://www.w3webtutorial.com/xslt/xslt-browser-support.php</resurl>
        <resdesc>
          <ul style="compact">
            <li>
              <p>Supported by Safari, Chrome, Firefox, Opera and Internet Explorer.</p>
            </li>
            <li>
              <p>Typically support only XSLT 1.0</p>
            </li>
          </ul>
        </resdesc>
      </webresource>
    </webresources>

    <p>In this book, we're going to install a version of the Saxon processor that supports XSLT 1.0. We'll use
      the free, open-source version. I've used Saxon and Xalan extensively, and both give excellent support
      for the XSLT 1.0 specification. However, Saxon is more actively supported, and it offers a broad range
      of possibilities for expanding your processor functionality once you progress beyond the confines of
      XSLT 1.0. The home edition of Saxon gives an excellent stepping-off point if you later find you need
      additional functionality from your XSLT processor.</p>

    <p>Although we show how to install the Saxon processor in this book, you're welcome to explore and install
      any other XSLT processor you find convenient. The examples in this book should all run identically with
      any processor that supports XSLT 1.0. Also, you can later swap out processors when you get ready for
      real-world implementations. For example, you might find you want a faster processor than the Java-based
      Saxon and Xalan processors, so you might then opt for xsltproc instead.</p>
  </sect1>


  <sect1>
    <title>Installation</title>

    <p>In this section, we're going to download and install Saxon 6.5.5. This is not the latest and greatest
      from Saxon, but it is the last version that supports XSLT 1.0 and not 2.0. Running an XSLT 2.0 processor
      against an XSLT 1.0 stylesheet is possible, but it opens up the possibility of inconsistencies when the
      XSLT 2.0 processor runs in "backwards compatibility mode."  So we'll use a straight XSLT 1.0 processor to
      keep things simple.</p>

    <p>To run Saxon 6.5.5, we'll also need to have Java installed and available in our Path environment variable. And,
      naturally, you'll need to follow the Java installation instructions for the operating system you're
      running for these exercises. However, once Java is installed, the installation for Saxon is a breeze. </p>

    <sect2>
      <title>Installing Java for the Saxon XSLT Processor</title>
      <p>Chances are you already have Java installed on your computer. It seems like everything uses Java these days. 
        To check whether you have Java installed and called out in you Path environment variable, open a terminal 
      window and enter <ic>java -version</ic> at the command prompt.</p>
      
      <p>You should get a message back telling you which version of Java you have installed.  The version of Saxon we'll be using is
        fairly old, and it is advertised to be compatible with Java JDK 1.2 through 1.5, but it works in Java 1.6 
        (Java SE 6) just fine, and I suspect it will be fine with later versions of Java as well.</p>
      
      <p>You may get a message to the effect <ic>'java' is not recognized as an internal or external command, operable program or batch file.</ic>
      If you get this, you need to install Java and get the path to it into your Path environment variable.  Rather than repeat the installation procedures 
      for Java here, you can go the the web page at <url>http://www.oracle.com/technetwork/java/javase/downloads/index.html</url> and follow the instructions from that point. 
      Select the latest version labeled “JDK,” and that should give you what you need.
      </p>
      
      <p>Once you get Java set up, you'll need to set your Path environment variable to include the path to the Java executable. 
        The executable is located in the JDK folder for the version of Java that you installed. (You do remember which directory you installed Java in, don't you?) 
        For example, I installed Java SE 8 in <dir>C:\Program Files\Java</dir> on my machine.  Within that folder, 
        I find the <filename>java.exe</filename> file for the JDK located in <dir>C:\Program Files\Java\jdk1.8.0_05\bin</dir>.  
        This is the path that I put into my Path variable. (Yours will likely differ from mine).
      </p>
      
      <p>For additional information on setting the Path environment variable for Java, take a look at <url>http://java.com/en/download/help/path.xml</url>.</p>
      
      <p>If you are running Java 1.4 or later, you shouldn't have any problems. With earlier versions of Java, 
        you would need to specify additional files for classpaths on the command line.<footnote><p><url>http://saxon.sourceforge.net/saxon6.5.5/index.html</url></p></footnote>
        Let's make all of our lives easier and just assume that you're not using an ancient version of Java.
      </p>
      
      <p>Again, once Java is installed, you can check the installation by opening a new terminal window and entering <ic>java -version</ic>.
        (Don't use a terminal window that was open before you changed the path, because it won't pick up the change.) Now you should see the Java version
        message smiling back at you, similar to mine:</p>
      
<processedcode showname="no" style="normal">
<codeline>C:\&gt;java -version</codeline>
<codeline>java version "1.8.0_05"</codeline>
<codeline>Java(TM) SE Runtime Environment (build 1.8.0_05-b13)</codeline>
<codeline>Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)</codeline>
</processedcode>
<?location standalone.pml@315 ?>

      
      <p>Cool.  We've set the groundwork for installing Saxon.  Now let's move on---just one more package to install.</p>
    </sect2>

    <sect2>
      <title>Getting and Installing Saxon 6.5.5</title>
      <p>To get Saxon 6.5.5:</p>

      <ol>
        <li>
          <p>Visit the Saxon XSLT and XQuery Processor page at <nobreak><url>http://saxon.sourceforge.net/</url>.</nobreak></p>
        </li>
        <li>
          <p>On this page, scroll down to the “Older Products” section and find the “Saxon
            6.5.5” section.</p>
        </li>
        <li>
          <p>Click on the link labeled “Download (3265 Kbytes).” This will take you to the
            Sourceforge download page, and your download should start automatically after a few seconds.</p>
        </li>
      </ol>

      <p>Now you're ready to install Saxon. You call install Saxon 6.5.5 with the instructions below.</p>

      <ol>
        <li>
          <p>Create a folder for your Saxon installation. You might want to create a general <dir>Saxon</dir>
            folder, and within that a folder for the specific version you're installing. In my case, I created
            a folder called <dir>Saxon</dir>, then another folder within it called <dir>Saxon6-5-5</dir>.</p>
        </li>
        <li>
          <p>Locate the downloaded .zip file for the Saxon 6.5.5 installation file. Using a zip application of
            your preference, unzip the file to the destination directory you just created.</p>
        </li>
        <li>
          <p>Check the destination directory to make sure the files are present. Your directory should look
            something like <ref linkend="fig.Saxon_installation_directory"/>.</p>

          <figure id="fig.Saxon_installation_directory" place="top">
            <title>Directory content for installed Saxon files</title>
            <imagedata border="yes" fileref="images/standalone/Saxon_installation_directory.jpg"/>
          </figure>
        </li>
      </ol>
      <p>And that's it. Saxon is now ready, willing, and able to process XSLT. Now all we have to do is
        construct a command line to make it go! (Rubs hands together gleefully.)</p>
    </sect2>

  </sect1>

  <sect1>
    <title>Testing</title>
    <p>
      Before we launch into the meat of our story, let's make sure the XSLT processor is working. 
      We're not quite ready to demo in front of the CEO. (You weren't actually going to do that, right???)
    </p>

    <p>To test the processor, you're going to need an XSLT stylesheet and an XML file to work on. I've
      placed a couple of files on the website for this book that you can test with. Download the
      files from the two following links and save them together in the same directory somewhere on your computer: </p>

    <ul>
      <li>
        <p><url>http://media.pragprog.com/titles/djkxsl/code/standalone/streamline.xsl</url></p>
      </li>
      <li>
        <p><url>http://media.pragprog.com/titles/djkxsl/code/standalone/multiple_accounts.xml</url></p>
      </li>
    </ul>

    <p>Once you've got that, use the following steps to run the test:</p>

    <ol>
      <li>
        <p>Open a terminal window on the computer.</p>
      </li>
      <li>
        <p>Change directories to the directory containing the two files you downloaded.</p>
      </li>
      <li>
        <p>Enter the following at the command line. (Note that the line return in the command line is 
          artificially placed to take into account the width of this book. Don't enter a line return 
          within the command line text.)</p>
        
<processedcode language="plain" showname="no" size="small" style="normal">
<codeline>java -jar <cocomment>[absolute path to the saxon.jar file/]</cocomment>saxon.jar  -o output.xml</codeline>
<codeline>     multiple_accounts.xml streamline.xsl</codeline>
</processedcode>
<?location standalone.pml@403 ?>


        <p>You will need to supply the absolute path to the <ic>saxon.jar</ic> file that we placed during the
          installation procedure. For example, for my Windows computer, I use the following:</p>

<processedcode language="plain" showname="no" size="small" style="normal">
<codeline>java  -jar C:/Saxon/Saxon6-5-5/saxon.jar -o output.xml accounts.xml streamline.xsl</codeline>
</processedcode>
<?location standalone.pml@410 ?>


        <p>The <ic>-o output.xml</ic> option tells the processor to send the output to a file called <filename>output.xml</filename>, in
          the same directory where it is currently processing. <filename>multiple_accounts.xml</filename> is the name of
          the XML file we want to process, and <filename>streamline.xsl</filename> is the name of the file containing our
          stylesheet. (We'll use this same stylesheet and XML file in a later chapter, but at the moment,
          don't worry about the details. We're just proving high-level functionality in this step, not
          learning XSLT.) </p>
      </li>
      <li>
        <p>When the command executes, you should see something like the following in the terminal window.  </p>
        
<processedcode language="plain" showname="no" size="small" style="normal">
<codeline>H:/djkxsl/Book/code/standalone&gt;java -jar C:/Saxon/Saxon6-5-5/</codeline>
<codeline>     saxon.jar -o output.xml accounts.xml streamline.xsl</codeline>
<codeline/>
<codeline>H:/djkxsl/Book/code/standalone&gt;</codeline>
</processedcode>
<?location standalone.pml@427 ?>

        
        <p>Basically, you see nothing. And that's a good thing. No news is good news. If
          there were a problem with our setup, we'd be seeing error messages instead of a blank line.
          (And if you are seeing error messages, don't panic. We'll address some of the gotchas in <ref linkend="sect2.goes.wrong"/>.)</p>
      </li>
      <li>
        <p>To double-check that the processor ran properly, go to the directory containing the XML and XSL
          file, and find the file called <filename>output.xml</filename>. Opening this file, you should see something like the following:</p>
        
<processedcode language="xml" showname="no" size="small" style="normal">
<codeline> &lt;?xml version="1.0" encoding="utf-8"?&gt;<cokw>&lt;accounts&gt;</cokw></codeline>
<codeline>   <cokw>&lt;account</cokw> id=<costring>"100007"</costring> name=<costring>"Jorge Luis Borges"</costring><cokw>&gt;</cokw></codeline>
<codeline>     <cokw>&lt;transaction&gt;</cokw></codeline>
<codeline>       <cokw>&lt;date&gt;</cokw>June 6, 1984 12:00:00<cokw>&lt;/date&gt;</cokw></codeline>
<codeline>       <cokw>&lt;amount&gt;</cokw>$14.99<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>       <cokw>&lt;product&gt;</cokw>B-5643A<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>     <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>     <cokw>&lt;transaction&gt;</cokw></codeline>
<codeline>       <cokw>&lt;date&gt;</cokw>July 23, 1966 23:47:12<cokw>&lt;/date&gt;</cokw></codeline>
<codeline>       <cokw>&lt;amount&gt;</cokw>$12.95<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>       <cokw>&lt;product&gt;</cokw>A-2345B<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>     <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>   <cokw>&lt;/account&gt;</cokw></codeline>
<codeline><cokw>&lt;/accounts&gt;</cokw></codeline>
</processedcode>
<?location standalone.pml@453 ?>

        
        <p>If your output.xml file contains this content, you're golden.  You can skip over the next section and keep going. 
          If you're running into problems, go on to the next section and let's see if we can sort them out.</p>
      </li>

    </ol>
    <sect2 id="sect2.goes.wrong">
      <title>What if It All Goes Wrong?</title>
      
      <p>In the world of software, sometimes things go wrong. Hard to believe, I'm sure...</p>
      
      <p>In the case of our installation and test of the XSLT processor, the number of things that might go wrong is fortunately not
      that huge. The following sections list some of the main issues you're likely to encounter, with suggestions for fixes.</p>
      
      <dl>
        <dt bold="yes" newline="yes">Java doesn't run.</dt>
        <dd>
          <p>Still getting <ic>'java' is not recognized as an internal or external command, operable program or batch file</ic>?
            Are you sure you set the Path environment variable correctly? Check the path to the <filename>java.exe</filename> file.
          </p>
          <p>To check what the Path environment variable is set to, open a terminal window and do one of the following, based on your operating system:</p>
          <ul>
            <li><p>In Mac OSx, Unix, or Linux, enter <ic>echo $PATH</ic>.</p></li>
            <li><p>In Windows, enter <ic>set Path</ic>.</p></li>
          </ul>
          <p>In the Path variable, is there any other Java path that precedes the Java path you intended to point to?  
            If so, does that path point to a directory containing <filename>java.exe</filename>?  
            The Path variable only uses the first instance of paths that point to executables of the same name. 
            You may need to clean up your Path variable.</p>
        </dd>
        
        <dt bold="yes" newline="yes">Saxon does not run.</dt>
        <dd><p>If Java is running, but Saxon does not run when you enter the command line above, you will get an error message like this:</p>
<processedcode showname="no" style="normal">
<codeline>Error: Unable to access jarfile C:/Saxon/Saxon6-5-5/saxon.jar</codeline>
</processedcode>
<?location standalone.pml@489 ?>

          <p>Check again.  Is the <filename>saxon.jar</filename> file in the location you specified on the command line?
          If so, you might try installing the Saxon files again.
          </p>
          
          <p>Does the error message mention some other jar file as missing?  If so, you may be using Java 1.3 or earlier, 
            in which case you'll want to install a later version of Java.</p>
        </dd>
        
        <dt bold="yes" newline="yes">The source XML and/or XSL stylesheet file is missing.</dt>
        <dd><p>If you get a message reading <ic>Source file account.xml does not exist</ic> or <ic>Stylesheet file streamline.xsl does not exist</ic>, 
          check the directory where the command prompt is located. 
          (In OSx, Unix, and Linux, enter <ic>pwd</ic>; in Windows, enter <ic>echo %cd%</ic>.) Is the current directory for the command window the same
          as where the files exist?  If not, change the directory to where the files exist.</p>
        </dd>
        <dt bold="yes" newline="yes">The output file cannot be created.</dt>
        <dd><p>You might get a message along these lines:</p>
        
<processedcode showname="no" style="normal">
<codeline>Error</codeline>
<codeline>Failed to create output file: H:\djkxsl\Book\code\standalone\output.xml</codeline>
<codeline>(The process cannot access the file because it is being used by another process)</codeline>
<codeline>Transformation failed: Run-time errors were reported</codeline>
</processedcode>
<?location standalone.pml@512 ?>

          
          <p>If you have the output.xml file open in an editor application, the file may be locked so 
            Saxon can't write to it.  Close the file and try again.</p>
        </dd>
      </dl>
      <p>Once we get beyond these relatively simple issues, if you are still having problems, it might be best 
        to get online and post your problems to a support community for your operating system or computer. Java and Saxon are relatively easy, but---what was that we started with?
        “In the world of software, sometimes things go wrong.”  Too true, too true...
      </p>
    </sect2>
  </sect1>
  
  <sect1>
    <title>General Usage</title>
    <p>
      Before we move along, let's go over the command line so you have a little more understanding of how it works.  That way you can adapt the command line to your circumstances, if needed.
    </p>
    <p>Take a look again at the example of what I entered for the Saxon test command line:</p>
    
   <imagedata fileref="images/standalone/command-line.pdf"/>
    
    <p>
     The numbered parts of the command line in this diagram are as follows:
    </p>
    
    <table>
      <colspec col="1" width="5%"/>
      <row>
        <col><p>①</p></col>
        <col><p>The command to execute Java. The file location for the java executable must be 
          contained in the Path environment variable for this to work.</p></col>
      </row>
      <row>
        <col><p>②</p></col>
        <col><p>The label or switch for the option that specifies where the <filename>saxon.jar</filename> file is located. 
          If you later find that you need to list other <fileextension>.jar</fileextension> files, you would provide them, 
          separated by spaces, after this option label.</p></col>
      </row>
      <row>
        <col><p>③</p></col>
        <col><p>The absolute path to the <filename>saxon.jar</filename> file.</p></col>
      </row>
      <row>
        <col><p>④</p></col>
        <col><p>The option switch for the output option. An output file name must be given if you use this switch.
        </p>
          <p>If you leave off this option, the output will be directed to the terminal window where you enter the command.  
            If you're processing a really long XML file---just sit back and enjoy the fireworks.</p></col>
      </row>
      <row>
        <col><p>⑤</p></col>
        <col><p>The path and name of the output file. If you just give a filename, the file is created in the directory where 
          you are executing the command.  You can also use a relative or absolute path to place the output file somewhere else.</p></col>
      </row>
      <row>
        <col><p>⑥</p></col>
        <col><p>The name of the input file.  This is a required entry. As with the output file, you can use a relative or absolute path along
          with the filename. (If the path or filename contains spaces, try enclosing the complete path and filename in quotation marks.)
        </p></col>
      </row>
      <row>
        <col><p>⑦</p></col>
        <col><p>The name of the file containing the XSLT stylesheet.  Again, relative and absolute paths can be included.</p></col>
      </row>
    </table>
    
    <p>The command line can get tedious if you move between a lot of different XSLT files, like we're going to do in this book.  
      If you get tired of typing the absolute path to the Java executable, 
      you could create a command script (specific to your operating system, of course) that allowed you 
      to abbreviate what you have to enter for the execution.  </p>
    
    <p>There are a variety of things you can do with the command line that go beyond what we need for this book.  You can invoke Saxon from within another program, for instance.
    You can set up the command line to use classpaths rather than the absolute path to the <filename>saxon.jar</filename> file.  There are good reasons for all of these
    variants, but you'll have to discover your own particular needs as you grow in your experience with XSLT. For a good summary of how to invoke Saxon, and all things Saxon-related,
    I recommend looking at the Saxon documentation, available on the Saxonica website.<footnote><p> <url>http://www.saxonica.com/documentation/documentation.xml</url></p></footnote>
    </p>
  </sect1>
  
  <sect1>
    <title>What We Did</title>
    
    <p>For a short chapter, we covered a lot of ground.  We had a look at the list of available XSLT processors and settled on using Saxon 6.5.5 for this book.
    We installed Java, installed Saxon, and tested it.  Those of use who weren't so lucky had to do a little troubleshooting. (Sorry about that!)  And then we had a look 
    at the command line for executing the XSLT processor, trying to give ourselves a little flexibility for ease of use down the road.
    </p>
    <p>So now we're set! We're able to process XSLT two different ways: with a qualified web browser, or with a standalone XSLT processor.
      I always like to use the standalone processor, but there's no denying that a web browser is much easier.  
      However, as we get into some more complex situations with XSLT processing, we're going to want to use the standalone processor almost exclusively.</p>
    
    
  </sect1>
  <sect1>
    <title>Where We Go from Here</title>
    <p>Let's put our spiffy new processing tools to work.  In the next part of this book, we're going to look at XSLT from the perspective of how it solves certain classes of problems.
    We'll see how to control output, how to change the order and structure of documents, and how to use values for decisions, selections, and other kinds of control. We'll spend some time
    manipulating text---always such a joy (not!). We'll take a look at more large-scale issues such as grouping, sorting, and stylesheet organization.  We'll take a look at some specific
    “tricks of the trade”---interesting methods for solving certain kinds of problems.  And finally, we'll encounter some strategies for the inevitable and necessary topic 
    of troubleshooting XSLT.  
    </p>
    <p>Ready to jump in?</p>

  </sect1>
  

</chapter>
<?location creating_output.pml@3 ?>

<chapter id="chap.creatingoutput">
  <title>Beginning with the End: Creating Output</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p>During the early years of the discovery of this ray many strange accidents occurred before the
        Martians learned to measure and control the wonderful power they had found.</p>
    </epitext>
  </epigraph>
  <!-- 
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>To get a quick sense of gratification from the XSLT templates by performing the most common
          operations for which people are interested in using XSLT.</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>Different methods of getting output from XML, and some of the reasons to use the different
          methods.</p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>Get output from XML in the order the XML appears in the source document.</p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>Next, we'll find out how to access parts of the XML document in whatever order we need them, so we
          won't be bound to the order of the source document.</p>
      </dd>
    </dl>
  </storymap>
 -->

  <p>Ouput is what it's all about. In <ref linkend="chap.howitlooks"/>, we saw how the XSLT processor finds
    XSLT templates to match against the elements in an XML document. But what can we do in the templates once
    they match an element? In almost all cases, the goal is eventually to create some output.</p>

  <p>To craft the output to our needs, we're going to need controls over how we create output. Our output file
    might be XML very similar to what we started with, or it might be a massive reconstruction to convert it
    to something that bears little resemblance to the original. It might be HTML, or maybe even another XSLT
    stylesheet. We might want to add or subtract content, or we might want to use the document data to do
    calculations and make decisions about how to modify other data. Yes, we can do all that.</p>

  <p>How are we going to do all that?</p>

  <p>It turns out there are a number of different ways of using XSLT to ouput data, and the different methods
    are appropriate to different situations. In this chapter we're going to learn some of the patterns for
    creating different kinds of output. We'll learn new instructions as well as check back in on our old
    friend <xmltag>xsl:apply-templates</xmltag>. We'll find subtle differences between different instructions
    that allow us to output content in various ways. </p>

  <p>The methods of getting output that we'll cover in this chapter include:</p>

  <ul style="compact">
    <li>
      <p>Different methods for getting existing text out of a node in the source</p>
    </li>
    <li>
      <p>Literal text that we add</p>
    </li>
    <li>
      <p>Adding elements and attributes to the output as static text</p>
    </li>
    <li>
      <p>Dynamically adding element and attribute names and values during runtime</p>
    </li>
  </ul>

  <p>There are a few other types of output to learn, but we'll save those for later. I'd like for you to get
    comfortable with these basic output methods before we get into the refinements.</p>

  <sect1>

    <title>Reaping the Flow: Built-in Template Rules</title>
    <p>As we've seen, one way of getting text out of an XML file is to use the
      <xmltag>xsl:apply-templates</xmltag> instruction and rely on the built-in template rules to retrieve the
      text that is already there.</p>

    <p>Let's set up a simple XML document and XSLT template to retrieve its text. Here's the XML:</p>

<figure id="code.handlingcontent.caution1.xml">
  <title>Example XML for a Cautionary Note</title>
<processedcode language="xml" showname="handlingcontent/caution1.xml" style="normal" url="handlingcontent/caution1.xml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="caution1.xsl"?&gt;</codeline>
<codeline><cokw>&lt;caution</cokw> type=<costring>"Intergalactic"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;paragraph&gt;</cokw>The potential for intergalactic broadcast while using</codeline>
<codeline>    the <cokw>&lt;product&gt;</cokw>AZGuard Protaxis<cokw>&lt;/product&gt;</cokw> unit</codeline>
<codeline>    has not yet been determined.<cokw>&lt;/paragraph&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;paragraph&gt;</cokw>Please avoid transmitting information that could place</codeline>
<codeline>    the human race at risk for alien invasion.<cokw>&lt;/paragraph&gt;</cokw></codeline>
<codeline><cokw>&lt;/caution&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@88 ?>

</figure>


    <p>Here's a stylesheet that will give us all the text in the <xmltag>caution</xmltag> tag:</p>

<processedcode id="code.handlingcontent.caution1.xsl" language="xml" showname="handlingcontent/caution1.xsl" style="normal" url="handlingcontent/caution1.xsl">
<codeline>&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/caution"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@94 ?>


    <p>Since the &lt;?xml-stylesheet/&gt; processing instruction in the XML file points to the XSLT
      stylesheet, you could just open the XML file in a browser to see the results. Remember that the XSLT
      stylesheet should be in the same directory as the XML file for our examples.</p>

    <p>Here's the result you should see: an unformatted string that concatenates all the text in the file:</p>

    <imagedata border="yes" fileref="images/howitlooks/caution-1.png"/>

    <p>We've seen this before, and it's not particularly useful. This is a good way to get the text out in the
      order it appears in the document, if that's all you're interested in. All you need to do is create a
      template to match something and put an <xmltag>xsl:apply-templates</xmltag> in it. It will retrieve all
      the text in the element you matched, including the text of any descendant tags.</p>
    <p>If there are no descendant tags, this is a safe way to output the text, but usually we're going to need
      more than that. We're going to want to format the text, add stuff to it, maybe even leave things out.
      Let's see if we can get some help with that.</p>
  </sect1>

  <!-- xsl:value-of -->
  <sect1>
    <title>“Omit Needless Words” with <xmltag>xsl:value-of</xmltag></title>

    <p>We'll heed the famous admonition of <bookname>The Elements of Style</bookname> by Strunk and White.
      Instead of using <xmltag>xsl:apply-templates</xmltag> and the indiscriminate reaping machine of the
      default template, let's use something a little pickier: <xmltag>xsl:value-of</xmltag>. With this tag we
      can limit what we output a little more precisely.</p>

    <p>We'll continue using the XML document in <ref linkend="code.handlingcontent.caution1.xml"/>  
	for an example. Suppose we have a couple of
      hundred products, each with a library of caution statements, and we want to make sure all the products
      have the correct caution statements. We want to know which products are mentioned in various caution
      statements. So all we need from the XML file is the value of the <xmlattr>type</xmlattr> attribute and
      the text of any <xmltag>product</xmltag> tag.</p>

    <p>When we match on the <xmltag>caution</xmltag>, we can get the text of the <xmlattr>type</xmlattr>
      attribute with <xmltag attrs="select=“@type”">xsl:value-of</xmltag>. (The <ic>@</ic> symbol
      before a node name means that the node is an attribute. To select an attribute, you always have to use
      <ic>@</ic> before the attribute name.) </p>

    <p>That just leaves the value of the <xmltag>product</xmltag> tag. We match on <xmltag>paragraph</xmltag>
      but this time we need to prevent the output of the <xmltag>paragraph</xmltag> text, since we don't want
      it. We do this by using the <xmltag>xsl:apply-templates</xmltag> tag with a <xmlattr>select</xmlattr>
      statement that doesn't select for text. Instead, it selects only for the <xmltag>product</xmltag> tag,
      like so: <xmltag attrs="select=“product”">xsl:apply-templates</xmltag>. By defining what we
      want to select, we avoid invoking the default template for text.</p>

    <p>All we need now is a template for <xmltag>product</xmltag> that outputs its text, and we have what we
      wanted:</p>

<processedcode id="code.handlingcontent.caution2.xsl" language="xml" showname="handlingcontent/caution2.xsl" style="normal" url="handlingcontent/caution2.xsl">
<codeline>&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"caution"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"@type"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"descendant::product"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@144 ?>


    <p>Now the output looks like this:</p>

    <imagedata border="yes" fileref="images/handlingcontent/caution-2.png" width="45%"/>

    <p><xmltag>xsl:value-of</xmltag> has allowed us to fine tune the output, giving us only the parts we
      need.</p>

    <p>Of course, part of being able to do that was that we had to step away from using the bare
      <xmltag>xsl:apply-templates</xmltag> instruction. We'll find in XSLT that we often have to trade off
      between giving explicit instructions and allowing the templates to work in a more functional,
      take-it-as-it-lays method. Our working methods will be determined by what we're trying to
      accomplish.</p>

    <p>When outputting text, as we've done here, one thing to keep in mind: if the current content contains
      several text nodes that are separated by other nodes (such as elements or comments),
      <xmltag>xsl:value-of</xmltag> selects only the first node it finds. For example, in the following: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;p&gt;</cokw>Here is a point that <cokw>&lt;emph&gt;</cokw>must<cokw>&lt;/emph&gt;</cokw> be emphasized!<cokw>&lt;/p&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@165 ?>


    <p>If our template matches on the <xmltag>p</xmltag> tag and contains <xmltag attrs="select=&quot;text()&quot;">xsl:value-of</xmltag>, our result will be “Here is a point
      that”. So you'll need to exercise caution with this one.</p>

    <p>You could also say <xmltag attrs="select=&quot;.&quot;">xsl:value-of</xmltag>, but like
      <xmltag>xsl:apply-templates</xmltag>, this approach gives the contents of all the elements contained. Of
      course, that might be what we want. In the previous example, we'd get the contents of the
      <xmltag>emph</xmltag> tag as well as the content of the <xmltag>p</xmltag> tag, so the output would be
      “Here is a point that must be emphasized!”—without emphasis! </p>

    <p>The <xmltag>xsl:value-of</xmltag> instruction is useful for outputting a lot of things besides the text
      in the XML. Believe me, we'll wind up using this one a lot. The basic principle of
      <xmltag>xsl:value-of</xmltag> is that it will output whatever we tell it to. Its
      <xmlattr>select</xmlattr> attribute allows us to specify almost any type of location or expression that
      XSLT supports. It's the preferred method for expressing the value of variables, parameters, functions, or
      more complex expressions. You can even give it literal text to output.</p>




    <p><xmltag>xsl:value-of</xmltag> was just what we needed to get a specific slice of data out of our XML
      file. But you probably noticed that the output isn't exactly user friendly. The values of the
      <xmlattr>type</xmlattr> attribute and <xmltag>product</xmltag> tag are run together, and we don't have
      any indication of what type of data each part represents.</p>

    <p>It looks like we need to add some text to the output to indicate what the output is about. Fortunately,
      the next section shows a couple of ways of doing just that. </p>
  </sect1>

  <!-- supplying text -->
  <sect1>
    <title>More Is Better: Supplying Our Own Text</title>

    <p>As we saw in the last section, the content inside the tags isn't always enough to construct our output.
      XML content is sometimes terse because the document structure is intended to convey information to
      supplement the content. The structure of the XML allows the XSLT to derive clues about the content, and
      the XSLT can then supply additional text as needed. In our example, our clues were that the content we
      wanted was in the <xmlattr>type</xmlattr> attribute and the <xmltag>product</xmltag> tag.</p>

    <p>XSLT recognizes a certain rule for outputting things from the templates: </p>

    <p><emph>If it's in a template and it's not a recognized XSLT node, it goes into the output.</emph></p>
    <sidebar>
      <title>According to the Specification…</title>
      <p>With respect to recognizing the parts of the template that are intended to be output: “In a
        template, an element in the stylesheet that does not belong to the XSLT namespace and that is not an
        extension element (see [14.1 Extension Elements]) is instantiated to create an element node with the
        same expanded-name. The content of the element is a template, which is instantiated to give the
        content of the created element node. The created element node will have the attribute nodes that were
        present on the element node in the stylesheet tree, other than attributes with names in the XSLT
        namespace.” (See <url>http://www.w3.org/TR/xslt#literal-result-element</url>.) And that's why
        you're reading this book instead of the specification!</p>
    </sidebar>
    
    <p>We can put raw text for output pretty much anywhere within an <xmltag>xsl:template</xmltag> tag (as
      long as it doesn't screw up the syntax of any other tagging), but it's our responsibility to ensure that
      the text is valid within the structure of our output. We could code XSLT to output
      <xmltag>h2</xmltag><xmltag>/h2</xmltag><ic>WAIT JUST A SECOND...</ic>, and the XSLT processor would be as
      happy as a clam. The browser, on the other hand, would just snicker.</p>

    <p>Raw text anywhere: that's cool. And, of course, with great power comes...great potential for
      screw-ups.</p>

    <p>Let's go back to that output for the note type and product and add a little text to it, to give the
      output values some context. Here's what we're looking for: </p>

    <imagedata border="yes" fileref="images/handlingcontent/caution-3.png" width="55%"/>

    <p>You can probably figure this one out yourself:</p>

<processedcode language="xml" showname="handlingcontent/caution3.xsl" style="normal" url="handlingcontent/caution3.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"caution"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.add-type-label" lineno="4" prefix="-">Type: </codeline>
<codeline prefix="5"><cokw>&lt;xsl:value-of</cokw> select=<costring>"@type"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"descendant::product"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.add-product-label" lineno="10" prefix="10">Product: </codeline>
<codeline prefix="-"><cokw>&lt;xsl:value-of</cokw> select=<costring>"text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@237 ?>


    <p>Just add the text in lines <cref linkend="code.add-type-label"/> and <cref linkend="code.add-product-label"/>, and we're good to go.</p>

    <p>A point worth mentioning here: whitespace can be a little tricky. We now have spaces between the words
      because the text lines contain line returns, and the XML parser by default collapses any whitespace in
      text to a single space. That worked out fine this time, but it may not always be what we want. We'll see
      controls for whitespace in <ref linkend="chap.text"/>. And
      you'll be glad for it when you need it!</p>

    <p>I said you can add text anywhere inside a template as long as it doesn't mess up the XSLT tagging
      syntax. That's easier said than done, and it reinforces the need for having a good XML editor that is
      XSLT-aware. It will keep you out of all sorts of syntactical nightmares. But, in the absence of an
      XSLT-aware editor, here are some places to avoid adding text:</p>

    <ul>
      <li>
        <p>Inside the <xmltag>xsl:choose</xmltag> tag, except inside the <xmltag>xsl:when</xmltag> and
          <xmltag>xsl:otherwise</xmltag> tags</p>
      </li>
      <li>
        <p>Before the <xmltag>xsl:param</xmltag> tag inside a template</p>
      </li>
      <li>
        <p>Between an <xmltag>xsl:element</xmltag> tag and an <xmltag>xsl:attribute</xmltag> tag</p>
      </li>
    </ul>

    <p>These are the most common areas you might be tempted to place text. There are others, but you'll learn
      about those places as you learn more about XSLT in general.</p>

    <p>Of course, we still have a presentation problem. We're only seeing the text output in the browser. We
      don't have any HTML formatting in our output for the browser to interpret, so everything is still just
      text stretched out on a single line. If we had more than one caution in our file (which would be more
      often the case than not), we would need a way to output the results in a more readable format.</p>

    <p>It's time to stop dilly-dallying around. Let's output some HTML.</p>
  </sect1>

  <sect1 id="sect1.addingtags">
    <title>Adding Tags and Attributes as Text</title>

    <p>The ability to add raw text means we can also form elements and attributes by simple text entry, just
      using the standard angle brackets and <xmlattr value="">attribute_name</xmlattr> as needed.</p>


    <p>For our example, we're going to use this source markup:</p>


<processedcode id="code.handlingcontent.caution4.xml" language="xml" showname="handlingcontent/caution4.xml" style="normal" url="handlingcontent/caution4.xml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="caution4.xsl"?&gt;</codeline>
<codeline><cokw>&lt;caution&gt;</cokw></codeline>
<codeline>  <cokw>&lt;paragraph&gt;</cokw>The intergalactic broadcast range of</codeline>
<codeline>    the <cokw>&lt;product&gt;</cokw>AZGuard Protaxis<cokw>&lt;/product&gt;</cokw> unit</codeline>
<codeline>    has not yet been determined.<cokw>&lt;/paragraph&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;paragraph&gt;</cokw>Please avoid transmitting information that could place</codeline>
<codeline>    the human race at risk.<cokw>&lt;/paragraph&gt;</cokw></codeline>
<codeline><cokw>&lt;/caution&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@287 ?>


    <p> When we output the XHTML content, we might want to match on the <xmltag>caution</xmltag> tag and add a
      couple of other pieces of formatted text to draw attention to the cosmic consequences of the note, like
      the following figure:</p>

    <figure id="fig.handlingcontent.caution4.png">
      <title>The Formatted Caution Statement</title>
      <imagedata border="yes" fileref="images/handlingcontent/caution-4.png"/>
    </figure>

    <p>The additional text and formatting we supply helps to label and draw attention to the original content.
      (It may be a teensy bit heavy-handed in this case.)</p>

    <p>Where did all that extra text and formatting come from? Let's look at the stylesheet:</p>

<processedcode language="xml" showname="handlingcontent/caution4.xsl" style="normal" url="handlingcontent/caution4.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw></codeline>
<codeline prefix="-">  xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring></codeline>
<codeline id="caution4.stylesheet.line" lineno="4" prefix="-">  xmlns=<costring>"http://www.w3.org/1999/xhtml"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="5"/>
<codeline id="caution4.match-caution.line" lineno="6" prefix="-"><cokw>&lt;xsl:template</cokw> match=<costring>"/caution"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;html&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;head&gt;</cokw><cokw>&lt;title&gt;</cokw>Caution!<cokw>&lt;/title&gt;</cokw><cokw>&lt;/head&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;body&gt;</cokw></codeline>
<codeline id="caution4.h2.line" lineno="10" prefix="10">      <cokw>&lt;h2&gt;</cokw>WAIT JUST A SECOND THERE!!!<cokw>&lt;/h2&gt;</cokw></codeline>
<codeline id="caution4.caution.line" lineno="11" prefix="-">      <cokw>&lt;p&gt;</cokw> USE EXTREME CAUTION:<cokw>&lt;/p&gt;</cokw>  </codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/body&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/html&gt;</cokw></codeline>
<codeline prefix="15"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"paragraph"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;p&gt;</cokw><cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw><cokw>&lt;/p&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="20"/>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;b&gt;</cokw><cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw><cokw>&lt;/b&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@303 ?>


    <p>Line <cref linkend="caution4.stylesheet.line"/> declares the XHTML namespace as the stylesheet's
      default namespace. Once we do that, we're free to add XHTML tags inside the templates without
      referencing their namespace any more. We could specify the namespace on individual tags, but that gets
      tedious and repetitive. So we declare a default global namespace so we can use the XHTML tags without a
      URI prefix. We declare it using the <xmlattr>xmlns</xmlattr> attribute on the
      <xmltag>xsl:stylesheet</xmltag> element. That way, the processor understands that any tag without a
      namespace prefix inside the templates belongs to this default namespace.</p>

    <sidebar>
      <title>Do You Have Anything Else to Declare?</title>

      <p>As you can see, the <xmlattr>xmlns:xsl</xmlattr> attribute in line <cref linkend="caution4.stylesheet.line"/> of the XSLT example specifies a prefix for the XSL namespace, so
        we use xsl: as a prefix in our XSLT stylesheet.</p>

      <p>If we needed to output multiple namespaces, we would declare the namespaces in the
        <xmltag>xsl:stylesheet</xmltag> tag, similar to how we declare the xsl: namespace. We would also need
        to include the namespace prefix with the appropriate tags inside the templates to avoid collisions
        between namespaces.</p>

      <p>Until you start using multiple namespaces, you can get away with just using a default namespace, the
        way we have it set up here for XHTML.</p>
    </sidebar>

    <missing>Mention the occasional need for exclude-result-prefixes attribute on output tags.</missing>


    <p>In line <cref linkend="caution4.match-caution.line"/> of our example, we matched on the
      <xmltag>caution</xmltag> tag. Inside that template, we added some HTML tags and some literal text that
      we wanted to output. </p>

    <p>Since <xmltag>caution</xmltag> is the root element of the XML document, we put all the top-level HTML
      tags inside the template that matches on the <xmltag>caution</xmltag> element. This arrangement
      illustrates one of the basic principles of XSLT stylesheet design. Since the XSLT processor uses the
      templates to match the structure of the XML document, try to design your XSLT templates to take
      advantage of the XML structure when planning your output.</p>

    <p>For example, instead of placing “USE EXTREME CAUTION:” in the template that matches on the
      root element, <xmltag>caution</xmltag>, we could have created a template to match only the first
      paragraph of the XML, then added “USE EXTREME CAUTION:” in that template. But then we would
      have had to create another template to match all the other <xmltag>paragraph</xmltag> tags in the
      document, so they would not contain “USE EXTREME CAUTION:”. So why not just stick the
      one-time warning in the top-level template with all the other one-time set-up tags? We'll frequently
      find ourselves asking similar questions about content placement as we encounter more complicated
      patterns of mapping XML source to our required output.</p>

    <p>So what about attributes? Suppose our example needed us to output <xmltag attrs="class=&quot;caution&quot;">p</xmltag>. Could we just add it into the text for the
      <xmltag>p</xmltag> tag and hope it comes across, like this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;p</cokw> class=<costring>"caution"</costring><cokw>&gt;</cokw></codeline>
<codeline>  USE EXTREME CAUTION:</codeline>
<codeline><cokw>&lt;/p&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@361 ?>


    <p>You bet your sweet bippy (as they once said in a remote and colorful past). 
      Just pop in the attribute and its value as static text, and we're good to go.</p>

    <p>Other than setting up the namespace, there's no big trick to using text for output elements and
      attributes. As far as using them for creating static output, they're relatively straightforward. The
      main thing you have to watch out for is making sure the order of the output creates valid syntax for the
      type of output you are creating. It's sometimes easy to match on an element and create a block-level
      piece of output (like a <xmltag>p</xmltag>) and find out that its parent element is also a block level
      element tha added a <xmltag>p</xmltag>---so now you've got a <xmltag>p</xmltag> inside a
      <xmltag>p</xmltag>, and that won't work. Sometimes this situation means that you need to change the
      order of how things are output---a topic we'll deal with in detail in <ref linkend="chap.orderorder"/>. </p>

    <p>What we've seen here is how to create elements and attributes in static form, which is fine when we
      know what they're supposed to be in advance. But what if we don't know exactly what element or attribute
      to use? What if we don't know the value that needs to be supplied for the attribute? Suppose we can only
      find out those values at runtime, by testing other parts of the document or by using values supplied by
      the process that kicks off the XSLT processor? These are all perfectly valid questions. And, fortunately,
      XSLT has answers.</p>

    <p>As we'll see in the following section, XSLT provides the
      <xmltag>xsl:element</xmltag> instruction, <xmltag>xsl:attribute</xmltag> instruction, and the
      <emph>attribute value template</emph> as ways to dynamically create element names, attribute names, and
      attribute values during runtime. </p>
  </sect1>

  <!-- elements and attributes -->
  <sect1 id="sect1.addingelements">
    <title>Adding Elements and Attributes Dynamically</title>

    <p>Often we won't know what to name an element or attribute until we have determined some information at runtime. 
      Maybe when we match an element, we'll  need to place a new wrapper element around the content, and the name of that element will depend on
      some value that was passed in at runtime, or on the context structure, or on the contents of the
      text.</p>

    <p>Consider a set of part numbers that previously have been contained in a <xmltag>partno</xmltag>
      tag, and the prefix was contained in an attribute (for example, <xmltag attrs="prefix=&quot;EVG&quot;">partno</xmltag>7891-1246<xmltag close="yes">partno</xmltag>). The customer is now doing a big data migration, and for
      the sake of efficiency and clarity, the <xmltag>partno</xmltag> tag is going away. We now need the part
      number to be tagged with the part number prefix so the tag will no longer need the attribute. We create
      a template to match on <xmltag>partno</xmltag> and then create an element whose name is the value of the
      attribute:</p>

<processedcode language="xml" showname="handlingcontent/partno1.xsl" style="normal" url="handlingcontent/partno1.xsl">
<codeline id="partno.1" lineno="1" prefix="Line 1"><cokw>&lt;xsl:template</cokw> match=<costring>"partno"</costring><cokw>&gt;</cokw> </codeline>
<codeline id="partno.2" lineno="2" prefix="2">  <cokw>&lt;xsl:element</cokw> name=<costring>"{@prefix}"</costring><cokw>&gt;</cokw> </codeline>
<codeline id="partno.3" lineno="3" prefix="3">   <cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw> </codeline>
<codeline id="partno.4" lineno="4" prefix="4">  <cokw>&lt;/xsl:element&gt;</cokw> </codeline>
<codeline prefix="5"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@404 ?>


    <p>If our input is <xmltag attrs="prefix=&quot;EVG&quot;">partno</xmltag>7891-1246<xmltag close="yes"/>,
      our output is now <xmltag>EVG</xmltag>7891-1246<xmltag close="yes"/>. Using this template, source tags
      with different prefixes will be output with different tag names.</p>

    <p>Let's take a look at how we got that, one step at a time:</p>

    <ol>
      <li>
        <p>In line <cref linkend="partno.1"/>, we match on <xmltag>partno</xmltag></p>
      </li>
      <li>
        <p>In line <cref linkend="partno.2"/>, we create an open tag for the element. The element is named
          with the value of the <xmlattr>prefix</xmlattr> attribute. </p>
        <p>The @ symbol means that we're looking for an attribute; the name of the attribute is what follows
          the @.
          <!-- We'll see more about how to get attributes in paths in 
            <ref linkend="chap.nameeverything"/>.-->
          And those curly braces ({}) represent what we have called the <firstuse>attribute value
          template</firstuse>. The attribute value template places the value of its contents into the output.
          Think of them as meaning “the value of” whatever they contain.</p>
        <p>You'll use the curly braces a lot---the attribute value template is the preferred way to get
          dynamic values into an attribute in the output document's elements.</p>
      </li>
      <li>
        <p>In line <cref linkend="partno.3"/>, we output the value of the current context, which is the part
          number itself. From the paragraph above, the part number is 7891-1246.</p>
      </li>
      <li>
        <p>In line <cref linkend="partno.4"/>, we close the <xmltag>xsl:element</xmltag> tag. In the output,
          this creates the closing tag for the new element we've created.</p>
      </li>
    </ol>
    <p>And that's it! The <xmltag>xsl:element</xmltag> instruction captures the appropriate new tag name based
      on the value of the <xmlattr>prefix</xmlattr> attribute.</p>

    <joeasks>
      <title>What's the Big Deal with <ic>xsl:element</ic>?</title>
      <p>Isn't it possible to accomplish the same thing as <xmltag>xsl:element</xmltag> by creating the
        element's angle brackets with text, then putting the name of the tag inside the two angle
        brackets?</p>
      <p>Sure, you could do that, sort of like this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline>&amp;lt;<cokw>&lt;xsl:value-of</cokw> select=<costring>"@prefix"</costring><cokw>/&gt;</cokw>&amp;gt;</codeline>
</processedcode>
<?location creating_output.pml@452 ?>


      <p>Of course, we'd have to set up a similar statement for the closing tag, so we'd be duplicating
        effort. Never a good programming practice, if we can help it. And what happens when we try to add an
        attribute to the element using the <xmltag>xsl:attribute</xmltag> instruction? Nothing---the XSLT
        processor does not recognize what we've created as an element, so it can't add an attribute to it. Of
        course, we could set up an attribute dynamically using text the same way we did with the element, but
        at that point we're pretty much reinventing the wheel. And the <xmltag>xsl:element</xmltag> tag comes
        with a set of attributes we'll find useful, such as the <xmlattr>namespace</xmlattr> and
        <xmlattr>use-attribute-sets</xmlattr> attributes.</p>

      <p>The bottom line is, yes, we could do it, but it's easier to use the tool provided by XSLT. Use the
        tools the way they're intended, don't cheat, trim your nails, and keep your nose clean. All good rules to follow.</p>
    </joeasks>
    <p/>

    <p>We haven't done an example with <xmltag>xsl:attribute</xmltag> yet, so let's check it out. The best use
      of <xmltag>xsl:attribute</xmltag> is to create attribute names dynamically, as we did with
      <xmltag>xsl:element</xmltag>. One reason to do that might be to base an attribute name on the value of
      content elsewhere in the document.</p>

    <p>Suppose we're converting some XML for a customer. The input looks like this:</p>

<processedcode language="xml" showname="handlingcontent/employees1.xml" style="normal" url="handlingcontent/employees1.xml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="employees1.xsl"?&gt;</codeline>
<codeline><cokw>&lt;employees&gt;</cokw></codeline>
<codeline>  <cokw>&lt;person&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>David James Kelly<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>    <cokw>&lt;id&gt;</cokw>emp-123456789<cokw>&lt;/id&gt;</cokw></codeline>
<codeline>    <cokw>&lt;employee-type&gt;</cokw>permanent<cokw>&lt;/employee-type&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/person&gt;</cokw></codeline>
<codeline>  <cokw>&lt;person&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>Sherlock Holmes<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>    <cokw>&lt;id&gt;</cokw>temp-9876754321<cokw>&lt;/id&gt;</cokw></codeline>
<codeline>    <cokw>&lt;employee-type&gt;</cokw>consultant<cokw>&lt;/employee-type&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/person&gt;</cokw></codeline>
<codeline><cokw>&lt;/employees&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@475 ?>


    <p>The customer wants to tighten that up a bit so the <xmltag>person</xmltag> tag contains a single
      attribute and the <xmltag>id</xmltag> and <xmltag>employee-type</xmltag> tags go away. The name of the
      attribute will be based on the employee type, and the value of the attribute will be the ID number. That
      way, the <xmltag>name</xmltag> tag can also be eliminated, so the content of <xmltag>person</xmltag> is
      their name. Here's a way to handle that: </p>

<processedcode language="xml" showname="handlingcontent/employees1.xsl" style="normal" url="handlingcontent/employees1.xsl">
<codeline>&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline><cokw>&lt;xsl:stylesheet</cokw>  xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring>  version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline> <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"employees"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;employees&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"person"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/employees&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"person"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;person&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:attribute</cokw> name=<costring>"{employee-type}"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"id"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"name"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/person&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@483 ?>


    <p>And our output is the required, beautifully terse XML that we expect:</p>

<processedcode language="xml" showname="handlingcontent/employees1-output.xml" style="normal" url="handlingcontent/employees1-output.xml">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline><cokw>&lt;employees&gt;</cokw></codeline>
<codeline>   <cokw>&lt;person</cokw> permanent=<costring>"emp-123456789"</costring><cokw>&gt;</cokw>David James Kelly<cokw>&lt;/person&gt;</cokw></codeline>
<codeline>   <cokw>&lt;person</cokw> consultant=<costring>"temp-9876754321"</costring><cokw>&gt;</cokw>Sherlock Holmes<cokw>&lt;/person&gt;</cokw></codeline>
<codeline><cokw>&lt;/employees&gt;</cokw></codeline>
</processedcode>
<?location creating_output.pml@487 ?>


    <p><xmltag>xsl:element</xmltag> is usually required only when the element needs to be dynamically
      generated. But you'll use the <xmltag>xsl:attribute</xmltag> instructions and attribute value templates
      quite frequently, as they give great flexibility in processing values for output attributes, and these
      work best with the <xmltag>xsl:element</xmltag> tag. You can save yourself a lot of aggravation by using
      these the <xmltag>xsl:element</xmltag> and <xmltag>xsl:attribute</xmltag> instructions as partners.</p>
  </sect1>

  <sect1>
    <title>What We Did</title>

   
    <p>We've covered a lot of ground in this chapter, and there's a lot left to go. We learned the basics of
      putting together a stylesheet in <ref linkend="chap.howitlooks"/>, and in this chapter we've covered a
      pretty large chunk of what's involved in getting output with XSLT. Specifically, we have learned how
      to</p>

    <ul>
      <li>
        <p>Output data as we find it by means of the built-in template rules</p>
      </li>
      <li>
        <p>Select the value of specific elements by means of <xmltag>xsl:value-of</xmltag></p>
      </li>
      <li>
        <p>Use text to supply additional elements, attributes, and text where we want to add them into the
          output</p>
      </li>
      <li>
        <p>Supply elements and attributes with names and values generated on the fly</p>
      </li>
    </ul>

    <p>There's a lot of power in that short list, and you'll find that you use these techniques on a constant
      basis as you develop XSL stylesheets. None of it will go to waste.</p>

    <p>Still, we haven't yet covered everything there is to know about getting output using XSLT. What we have
      covered here will be enough to get us started, though---we're still learning to walk at the moment.
      We'll get to the fancier parts about running, jumping, and skipping rope later in this book. </p>

    <!-- 
    <ul>
      <li>
        <p><xmltag>xsl:copy</xmltag> and <xmltag>xsl:copy-of</xmltag> for copying bits of the source document
          to the output.</p>
      </li>
      <li>
        <p><xmltag>xsl:text</xmltag> to control whitespace in the text.</p>
      </li>
      <li>
        <p><xmltag>xsl:number</xmltag> for creating automated number sequences</p>
      </li>
      <li>
        <p><xmltag>xsl:comment</xmltag> for creating comments</p>
      </li>
      <li>
        <p><xmltag>xsl:processing-instruction</xmltag> for creating processing instructions</p>
      </li>
      </ul> -->

    <p>In the next chapter, we'll see a technique called the <emph>identity transform</emph> that allows us to
      do some quick fine-tuning to our document. As we learn this technique, we'll see some new parts of XSLT,
      including the <xmltag>xsl:copy</xmltag> and <xmltag>xsl:copy-of</xmltag> instructions mentioned above.
      Beyond that chapter, we'll go into the issue of changing the order of content...</p>

    <p>...But we're getting ahead of ourselves. First let's check out the identity transform and learn what it
      can do for us. </p>


    
  </sect1>


</chapter>
<?location to-identity-and-beyond.pml@3 ?>

<chapter id="chap.identity">
  <title>Filtering with the Identity Transform</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext><p>“You have been with us a few days, yet during that time you have by your prowess won a high position among us.”</p></epitext>
  </epigraph>
<!-- 
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd><p>This chapter extends the lesson of controlling output by means of more global types of output filtering.</p></dd>
      <dt>What will I learn?</dt>
      <dd><p>We will learn a simple transform for copying all of an XML document to another document, then we will learn some methods of making variations on that
      transform to make large-scale global changes to the document.
      </p></dd>
      <dt>What will I be able to do?</dt>
      <dd><p>You will be able to make a copy of an XML document, and you will be able to omit certain kinds of XML nodes and make selective changes to text on a global basis.
      While the examples shown in this chapter are relatively simple, you will be able to take the lessons from subsequent chapters and apply them to this strategy to make
      other, more complex kinds of global changes.
      </p></dd>
      <dt>Where are we going next?</dt>
      <dd><p>While the strategy in this chapter leaves the order of the XML content as it is, after this we will learn some techniques to start changing the order of the XML output.</p></dd>
    </dl>
  </storymap>
  --> 
 
  <p>We've seen how to get some basic output from the XSLT, but we haven't done much with it. In this chapter,
    we'll look at how to start manipulating the output with a simple, powerful technique called the
    <firstuse>identity transform</firstuse>. </p>
  
  <p>In its simplest form, the identity transform is a stylesheet that consists of a single template.  The template is written so it can match any node in the document, create an identical instance of that node
  in the output, then apply templates in such a way that it calls itself again.  With just this one template, the stylesheet works its way through the entire XML document and creates an output document that is
  identical to the input document.</p>
  
  <p>The output file is identical to the input file?  I mean, what's the point of that, right? But its usefulness down the road might be a little
    surprising.  For example, we can create additional templates that provide exceptions to the identical copy, so we can create output with subtle changes from the input---like 
    changing the name of one element in the document.  Or we can make changes that give us radical, global changes from the input---like stripping out all the XML tags, or stripping out all the text.</p>
  
<p>The identity transform provides a starting point for solving a variety of interesting problems.  But before we get to those problems, let's get a handle on how the basic identity transform works.
  We'll learn a couple of new XSLT tricks before we start making variations on the theme of the identity transform.  After that, we'll take a look at just a few of the variations that can be made on
  our “identity transform” theme:
</p>
  
  <ul style="compact">
    <li>
      <p>Remove all the tags</p>
    </li>
    <li>
      <p>Remove all the text</p>
    </li>
    <li>
      <p>Uppercase or downcase text</p>
    </li>
    <li>
      <p>Create an obfuscator, where text is translated to nonsense, preserving the structural and content
        qualities of the output while keeping the content unreadable</p>
    </li>
    <li>
      <p>Change specific tags or text</p>
    </li>
  </ul>
  
<p>That's all interesting and useful stuff...so let's get started!</p>  
  
    

  <sect1>
  <title>Output Equals Input: the Simplest Identity Transform</title>

  <p>
    In the simplest version of the identity transform, we'll see a single template at work, using
    a few XSLT components to build a stylesheet that creates output for a whole XML document.
    This template does one thing, and it does it really well: it makes an identical copy of everything in the
    source XML. </p>
    <p>Without further adieu, here is the identity transform:</p>
    
    <figure id="code.identity">
      <title>Stylesheet for the Identity Transform</title>
<processedcode language="xml" showname="to-identity/identity.xsl" style="normal" url="to-identity/identity.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="2"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.identity-match" lineno="3" prefix="3">  <cokw>&lt;xsl:template</cokw> match=<costring>"@* | node()"</costring><cokw>&gt;</cokw>  </codeline>
<codeline id="code.identity-copy" lineno="4" prefix="4">    <cokw>&lt;xsl:copy&gt;</cokw> </codeline>
<codeline id="code.identity-apply-templates" lineno="5" prefix="5">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"@* | node()"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="6">    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="7">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="8"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@82 ?>

  </figure>


  <p>That's it. You can run a document of a million XML nodes through this stylesheet, and the output will be
    the same as the input. (Okay, it won't copy comments or processing instructions---let's keep it simple for now.)</p>
    
  <p>So what's going on here? We saw some of the stylesheet structures in <ref linkend="chap.howitlooks"/>,
  but there are some new things, too. </p>
    
  <p>First, the <xmlattr>match</xmlattr> attribute in line <cref linkend="code.identity-match"/> includes
    <xmlattrval>@*</xmlattrval> and <xmlattrval>node()</xmlattrval>, separated by a pipe (|) character. The @
    at the beginning of a string signifies an attribute. For instance, you would refer to an
    <xmlattr>id</xmlattr> attribute by saying <xmlattrval>@id</xmlattrval>. In this case we add the asterisk
    (*) wildcard to get it to refer to <emph>all</emph> attributes. The <xmlattrval>node()</xmlattrval> is a
    kind of wildcard itself: it tells the <xmlattr>match</xmlattr> attribute to match any and all XML nodes in
    the current context. And the | character represent a logical OR. So, as you have probably guessed, the
    <xmlattr>match</xmlattr> attribute in line <cref linkend="code.identity-match"/> says, essentially, "Match
    all nodes or attributes found in the current context." </p>

  <p>To follow what happens when this stylesheet meets an XML document, let's remember the bit of XML we ran
    into earlier: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="bib1.xsl"?&gt;</codeline>
<codeline><cokw>&lt;bibliography</cokw> id=<costring>"i54321"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;book&gt;</cokw></codeline>
<codeline>        <cokw>&lt;author&gt;</cokw></codeline>
<codeline>            <cokw>&lt;given&gt;</cokw>Joe<cokw>&lt;/given&gt;</cokw></codeline>
<codeline>            <cokw>&lt;family&gt;</cokw>Armstrong<cokw>&lt;/family&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/author&gt;</cokw></codeline>
<codeline>        <cokw>&lt;title&gt;</cokw>Programming Erlang: Software for a Concurrent World<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/book&gt;</cokw></codeline>
<codeline><cokw>&lt;/bibliography&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@119 ?>


  <p>The XSLT processor looks in the stylesheet for matches starting from the XML document's root node. In our
    example, it matches the root node in the XML because our template matches any and all nodes in the current
    context with that <ic>node()</ic> wildcard. </p>
  <p>Great, we're in. But what happens next? </p>
  <p>Line <cref linkend="code.identity-copy"/> contains a single XSLT instruction: <xmltag>xsl:copy</xmltag>.
    This instruction tells the XSLT processor to make a copy of the current node, and that's it. So we copy
    the root node into the output and keep going.</p>
  <p> Next, line <cref linkend="code.identity-apply-templates"/> tells the XSLT processor to apply any
    templates, within the current context, that match any XML elements defined by the
    <xmlattr>select</xmlattr> attribute. In this case, the contents of the <xmlattr>select</xmlattr> attribute
    look exactly like the contents of our original <xmlattr>match</xmlattr> attribute. The
    <xmltag>xsl:apply-templates</xmltag> instruction is telling the XSLT processor, "Go find any templates
    that provide a match for attributes or nodes that you find in the current content in the XML document,"
    and the match is provided by the match statement in the same template. </p>
  <p>Since the <xmltag>xsl:apply-templates</xmltag> tag is inside the <xmltag>xsl:copy</xmltag> instruction,
    the results of applying any subsequent templates will also be inside the node that we just copied. That's as
    it should be for our example, but make a note: by moving the <xmltag>xsl:apply-templates</xmltag> tag
    outside the <xmltag>xsl:copy</xmltag> tag, you could change the structure of the output document---and
    there may be times when you need that.</p>
  <p>So far, the stylesheet has processed the root node, <xmltag>bibliography</xmltag> and created a copy of
    it. Note that the XSLT processor has only output the opening tag at this point. It won't create the
    closing tag for <xmltag>bibliography</xmltag> until it reaches the closint tag of
    <xmltag>xsl:copy</xmltag> in the template.</p>
  <p>Then, when the processor reaches <xmltag>xsl:apply-templates</xmltag>, the <xmlattr>select</xmlattr>
    attribute tells it to apply any template that matches any XML attribute or node in the current context. In
    the XML, there is one attribute, <xmlattr value="i54321">id</xmlattr>. So the XSL processor looks for a
    template to match that attribute. </p>
  <p>Well, since there's only one template in the stylesheet, it doesn't have to look far. And since the
    template matches any attribute or node, it matches our particular <xmlattr>id</xmlattr> attribute. So the
    template starts over again: the <xmltag>xsl:copy</xmltag> instruction copies the attribute and its value
    (they're considered a unit by the XML parser), the <xmltag>xsl:apply-templates</xmltag> tag kicks in
    again.</p>
  <p> This time around, there are no more attributes to match, so the <xmltag>xsl:apply-templates</xmltag>
    instruction matches on the next item in the XML document, in document order. The next thing is the
    <xmltag>book</xmltag> tag, so that gets matched and copied. Then the <xmltag>author</xmltag> tag. Then the
    <xmltag>given</xmltag> tag, and then the “Joe” piece of text.</p>
  <p>There's no more text to copy, nor any other XML elements inside <xmltag>given</xmltag>, so the XSL
    process begins to unwind---remember, we've been executing the <xmltag>xsl:apply-templates</xmltag> tag and
    haven't reached the closing <xmltag>/xsl:copy</xmltag> tag yet. The processor reaches the end tag for
    <xmltag>given</xmltag>, so the end tag for <xmltag>xsl:copy</xmltag> kicks in and outputs
    <xmltag>/given</xmltag>. </p>
  <p>You get the pattern. This goes on and on until the end of the document is reached. The template for the identity transform
       uses a pattern in which it calls itself to continue processing, and it continues processing until it runs
    out of XML nodes and attributes. It's just a quiet, efficient little copying machine.</p>
  <p>The result is a fine, upstanding replica of the XML file we started with. But what was the point of all
    that? How useful can a copy be? </p>
    <p>Well, it turns out the identity transform has a lot of uses. Sometimes we want to make a copy of a
      document with just a slight variation---changing British spellings to American spellings, for instance.
      Sometimes we want to make a copy of only some parts of of a document while discarding other parts. I
      once needed to show all the tags and structure of a document that was causing me problems, but the
      content was proprietary, so I couldn't share it. I used an identity transform with slight variation to
      translate all letters and numbers to Xs, and voila!</p>
    <p>So it turns out the identity transform can be quite useful, if we make some variations on it.  To make the point,
    let's try a few variations of our own.  In the following sections we're going to:
    </p>
    <ul>
      <li><p>Remove all tags from a document</p></li>
      <li><p>Remove all text from a document</p></li>
      <li><p>Uppercase a specific word in the document</p></li>
      <li><p>Change one word to another word</p></li>
    </ul>
    
</sect1>
 
  <sect1>
    <title>Variation on a Theme #1: Removing All Tags</title>
    
 <p>One variation on the identity transform occurs when we want to remove all the tags from the document. It sounds a bit drastic, but it does happen: 
   you might want to run the text through a voice translator, for instance, or you may need
 to prepare the text for an audio transcription. You may simply want a list of text values in a file for parsing 
 by some other software that works better with text than with XML.</p>
    
    <p>In any case, stripping the tags out is a piece of cake. We'll just need to add one template to act as an exception to the template that copies everything.</p>

   
    <p>Let's start with an XML file that will run nicely in a browser:</p>

<processedcode language="xml" showname="to-identity/acknowledgement1.xhtml" style="normal" url="to-identity/acknowledgement1.xhtml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="identity.xsl"?&gt;</codeline>
<codeline><cokw>&lt;html</cokw> xmlns=<costring>"http://www.w3.org/1999/xhtml"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;head&gt;</cokw></codeline>
<codeline>    <cokw>&lt;meta</cokw> http-equiv=<costring>"Content-Type"</costring> content=<costring>"text/html; charset=UTF-8"</costring> <cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;title&gt;</cokw>Acknowledgements<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/head&gt;</cokw></codeline>
<codeline>  <cokw>&lt;body&gt;</cokw></codeline>
<codeline>    <cokw>&lt;h1</cokw> class=<costring>"acknowledgements"</costring> id=<costring>"d24e12098"</costring><cokw>&gt;</cokw>Acknowledgements<cokw>&lt;/h1&gt;</cokw></codeline>
<codeline>    <cokw>&lt;ul&gt;</cokw></codeline>
<codeline>      <cokw>&lt;li&gt;</cokw>Bert<cokw>&lt;/li&gt;</cokw></codeline>
<codeline>      <cokw>&lt;li&gt;</cokw>Ernie<cokw>&lt;/li&gt;</cokw></codeline>
<codeline>      <cokw>&lt;li&gt;</cokw>Big Bird<cokw>&lt;/li&gt;</cokw></codeline>
<codeline>      <cokw>&lt;li&gt;</cokw>Mr. Snuffleupagus<cokw>&lt;/li&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/ul&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/body&gt;</cokw></codeline>
<codeline><cokw>&lt;/html&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@198 ?>


    <p>Sure, it's XHTML, but that's XML, too, so it works. It looks a little nicer in the browser---so let's
      see if we can mess that up a bit. </p>

    <p>Notice that the second line of this XML file points to <filename>identity.xsl</filename>.  If you open this file in a browser (and the <filename>identity.xsl</filename> file is in the
      same directory as the XML file), the stylesheet in <filename>identity.xsl</filename> is invoked. This stylesheet contains the identity transform, so the output looks like this:</p>

    <imagedata border="yes" fileref="images/to-identity/acknowlegement1.png"/>

    <p>The XSL stylesheet transforms the XML into a perfect copy of itself, as we saw in the previous section. 
      The resulting XHTML appears in the browser with all the text formatted as is should be, given the nature of the XHTML tags.
      </p>

    <p>Suppose we want to count the number of words in the text, or we need a version to give to someone who
      will read it for an audio book.  All we want is the text. To get just text, we could make our transformation a copy operation, but with a slight
      difference from the identity transform: it would drop all the tags during the copy process.
      </p>

    <p>So let's modify our identity transform to get that working:</p>

<figure id="code.strip-tags">
  <title>A Stylesheet to Strip Tags from XML</title>
<processedcode language="xml" showname="to-identity/acknowledgement2.xsl" style="normal" url="to-identity/acknowledgement2.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring></codeline>
<codeline prefix="-">  version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.strip-tags-match1" lineno="4" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/ | text()"</costring><cokw>&gt;</cokw>               </codeline>
<codeline prefix="5">    <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline id="code.strip-tags-apply" lineno="6" prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | text()"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.strip-tags-match2" lineno="10" prefix="10">   <cokw>&lt;xsl:template</cokw> match=<costring>"*"</costring><cokw>&gt;</cokw>                            </codeline>
<codeline id="code.strip-tags-apply2" lineno="11" prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | text()"</costring><cokw>/&gt;</cokw>  </codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@221 ?>

</figure>

    <p>It's similar to the identity transform, but with a difference.
      Check out the differences between this piece of code and <ref linkend="code.identity"/>. 
      As you can see, the first template looks like the identity transform, but with a change to the <xmlattr>match</xmlattr> and <xmlattr>select</xmlattr> attributes.
      And then we've added a second template that matches on “*”, but doesn't make a copy of anything.  
      </p>
    
    <p>Let's go through it in detail to understand what we've accomplished, and how it works.</p>

    <p>In line <cref linkend="code.strip-tags-match1"/> of our tag-remover, we're now matching on the document
      root ("/") or any text node ("text()"). Before, we used <xmlattrval>node()</xmlattrval> to represent the
      root node, element nodes, and text nodes, because we wanted to treat all those kinds of nodes the same
      way---we just wanted to copy them. Now we want to treat the element nodes differently, so we discard
      <xmlattrval>node()</xmlattrval> from the match and we substitute / and <xmlattrval>text()</xmlattrval>.
      These are the two kinds of nodes that we want to continue copying. </p>

    <p>We've also discarded the <xmlattrval>@*</xmlattrval> from the match, because if we're not going to copy
      elements, we certainly don't need to copy attributes. And since there is nothing inside an attribute, we
      don't need to process them, either.</p>

    <p>In line <cref linkend="code.strip-tags-apply"/>, our <xmltag>xsl:apply-templates</xmltag> tag has new
      <xmlattr>select</xmlattr> value. It includes <xmlattrval>text()</xmlattrval>, but it also includes
      <xmlattrval>*</xmlattrval>, the two of them separated by a pipe. The * is a wildcard for all XML
      <emph>elements</emph>. So now we're telling the XSL processor, “Apply any templates that match the
      element nodes or text nodes that you find within the current context.” </p>

    <p>In the last version, we had only one template. In this version, we have two templates. Now, when the
      XSLT processor finds an element in the document, it will find the new template in the stylesheet that
      matches elements (the one in line <cref linkend="code.strip-tags-match2"/>). And when it processes that
      template it won't have the <xmltag>xsl:copy</xmltag> instruction. Instead, it finds only the
      <xmltag>xsl:apply-templates</xmltag> in line <cref linkend="code.strip-tags-apply2"/>.</p>

    <p>The XSLT processor goes off and finds a template to match whatever it finds next---element or text
      node. If it's a text node, the XSLT processor finds a matching template in line <cref linkend="code.strip-tags-match1"/>. The templates continue churning through the XML document, as before,
      as long as the XSLT processor continues to find matches.</p>

    <p>With the tags stripped out, you'll see this in the browser:</p>

    <imagedata border="yes" fileref="images/to-identity/acknowlegement2.png"/>

    <p>Success! None of that extraneous XHTML formatting for us! Just the pure sweet text.
    </p>

   <p>Okay, that was fun. We did something halfway interesting with the identity transform. And I suspect we
   won't need to do much explaining when we see the template that strips out text in the next section.</p>
    
    <sidebar>
      <title>Template Matching as Functional Programming</title>
      <p>Comparing the simple identity transform with this example, you can see that we haven't really given
        the XSLT processor many instructions of what to do. We've described conditions under which the XSLT
        processor is to take actions (with the <xmlattr>match</xmlattr> attributes). In one condition we've
        told it to make a copy of an element then keep processing, and in another condition we've told it just
        to keep processing. We know nothing about when those conditions will arise, so we haven't specified
        any order in which to handle those conditions.</p>
      
      <p>This sort of programming is called <emph>declarative</emph> or <emph>functional</emph> programming.
        In the first stylesheet we only had one condition; in the second stylesheet we defined two conditions,
        and related actions. We haven't actually told the XSLT processor <emph>how</emph> to do its work---and
        in fact, different XSLT processors will accomplish these instructions in different ways. </p>
    </sidebar>
  </sect1>

  <sect1>
    <title>Variation on a Theme #2: Omitting Content</title>
    <!-- Explain why this might be useful. -->

    
    <p>In the reverse situation from stripping out tags, suppose we need to strip out the text from a document. Maybe we need help troubleshooting our
      markup, but the content is confidential.  Maybe we want to set up a template for use by other systems (or even human beings!). We'd like a general
      method to remove all the text from the document.  That sounds like a variation on the identity transform, to me.</p>
    
    <p>Before I show you my answer, can you give it a try?  I'll give you a hint: you're going to need to use *, @*, and text() in your matches,
      and you're going to want a template that doesn't copy the text.  It's not that different from the example in <ref linkend="code.strip-tags"/>.
    </p>

    <p>How did it work for you?  Here's what I did:</p>

<figure id="code.acknowledgement3">
  <title>A Stylesheet to Strip Text from a Document</title>
<processedcode language="xml" showname="to-identity/acknowledgement3.xsl" style="normal" url="to-identity/acknowledgement3.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring></codeline>
<codeline prefix="-">  version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.strip-text-match1" lineno="4" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/ | * | @*"</costring><cokw>&gt;</cokw>               </codeline>
<codeline prefix="5">    <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | @* | text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.strip-text-match2" lineno="10" prefix="10">   <cokw>&lt;xsl:template</cokw> match=<costring>"text()"</costring><cokw>&gt;</cokw>                            </codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"</costring> <costring>* | @* | text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@303 ?>

</figure>
    
    <p>See the difference? In line <cref linkend="code.strip-text-match1"/>, we've removed <ic>text()</ic> and
      added * and @* so the elements and attributes get copied. And in line <cref linkend="code.strip-text-match2"/>, 
      we've matched on <ic>text()</ic> in the template that doesn't do any copying. So now the elements
      and attributes are output, but the text is not.</p>

    <p>In both templates we've used <xmltag>xsl:apply-templates</xmltag> with <xmlattr>select</xmlattr>
      attributes that direct the XSLT processor to look for templates that match elements, attributes, or
      text. Only the <xmlattr>match</xmlattr> values and the <xmltag>xsl:copy</xmltag> tags are different
      between the two templates. </p>

    <p>We've taken the identity transform a little way down the road, but there's lots more. For instance,
      suppose we want to keep the tags <emph>and</emph> the text, but we need to alter the text a little. That
      sounds like another variation on the identity transform waiting to happen. </p>
  </sect1>

  <sect1 id="sect1.uppercasing">
    <title>Variation on a Theme #3: Using a Function to Uppercase the Text</title>


    <p>Leaving out content was way simple. Let's take a look at something a bit harder: changing the text
      content. Because, you know, writers, editors, marketing gurus, management, customers, and standard
      committees always seem to be changing their minds about how to say things. Chances are you're going to
      need to do a variety of things with content: add it, remove it, tweak the case, swap words, the
      works. </p>
    
    <p>In this section, we're going to make one particular kind of change: we're going to change words in a certain tag
      to be all uppercase letters.</p>
    
    <p>As part of the solution, we'll learn a new type of XSLT mechanism: the XSLT <firstuse>function</firstuse>. 
      An XSLT function is an operator that performs some work and returns a value. See <ref linkend="chap.xpath.sect1.functions"/> and <ref linkend="app.functions"/>
      for more of the lowdown on functions.
    </p>
   
     
    <p>XSLT 1.0 has only a few rudimentary functions for string manipulation. The good news is that the available functions 
      are adequate for most of the problems you run into, if you apply the right techniques. So let's see what it can do for our
      uppercasing example. </p>
    
    <p>Here's the problem: you have an XML file full of terms that are used in a technical document. One of
      the sections is called <emph>admonitions</emph>, which contains all the standardized terms for warnings,
      dangers, cautions, and the like. In fact, you might have several files like this, one for each language
      the document is translated into. (We'll only deal with the English language, since the principle here
      will be the same for all languages.) An abbreviated version of the file might look like this:</p>

<processedcode language="xml" showname="to-identity/uppercase1.xml" style="normal" url="to-identity/uppercase1.xml">
<codeline>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="identity.xsl"?&gt;</codeline>
<codeline><cokw>&lt;terms&gt;</cokw></codeline>
<codeline><cokw>&lt;proprietary&gt;</cokw></codeline>
<codeline>  <cokw>&lt;product&gt;</cokw>FabBooster<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>  <cokw>&lt;feature&gt;</cokw>Sir Prize<cokw>&lt;/feature&gt;</cokw></codeline>
<codeline><cokw>&lt;/proprietary&gt;</cokw></codeline>
<codeline><cokw>&lt;admonitions</cokw> language=<costring>"en-us"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> name=<costring>"caution"</costring><cokw>&gt;</cokw>Caution<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> name=<costring>"warning"</costring><cokw>&gt;</cokw>Warning<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> name=<costring>"danger"</costring><cokw>&gt;</cokw>Danger<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> name=<costring>"uh-oh"</costring><cokw>&gt;</cokw>Now You've Done It<cokw>&lt;/term&gt;</cokw></codeline>
<codeline><cokw>&lt;/admonitions&gt;</cokw></codeline>
<codeline><cokw>&lt;/terms&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@350 ?>


    <p>And, just to satisfy our curiosity, if we run this file against the identity transform and view it in the browser, the output will
      look like this:</p>

    <imagedata border="yes" fileref="images/to-identity/identity-terms1.png" width="75%"/>

    <p>All that looks fine, but today just isn't our day. The manager from tech pubs comes along and says, "We
      need the admonitions always to be in uppercase so it will get people's attention. What can you do?" </p>

    <p>No problem. We have the identity transform and a function called <ic>translate()</ic> to take care of
      that little issue.</p>

    <p>The XML file has two areas where <xmltag>term</xmltag> is used, so we'll need to be careful---if we
      uppercase all of those proprietary terms, someone will pitch a fit about it. So in this example, we'll
      need a way to make a template that selects for an element that has specific ancestors. (This is another
      example of how we tell XSLT what we want done, but not necessarily how to do it.) </p>

    <p>As we've done before, let's have a look at the solution then talk about why it worked:</p>

<processedcode language="xml" showname="to-identity/uppercase2.xsl" style="normal" url="to-identity/uppercase2.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.uppercase-text-match1" lineno="3" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/ | * | @*"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline prefix="5">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | @* | text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.uppercase-text-match2" lineno="9" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"admonitions/term/text()"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="10">    <cokw>&lt;xsl:value-of</cokw> select=<costring>"translate(.,'abcdefghijklmnopqrstuvwzxyz',</costring></codeline>
<codeline id="code.uppercase-text-translate" lineno="11" prefix="-">          <costring>'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@370 ?>


    <p>We point our XML file to this stylesheet, and the result make the tech pubs manager happy:</p>

    <imagedata border="yes" fileref="images/to-identity/identity-terms2.png" width="75%"/>

    <p>The first template is the spitting image of the identity transform we ran in <ref linkend="code.acknowledgement3"/>, where we completely omitted the text. It's the second template where
      things take a completely different turn. Starting at line <cref linkend="code.uppercase-text-match2"/>,
      the template looks similar to before, but with a difference: we've added something in the
      <xmlattr>match</xmlattr> attribute.</p>
    <p>What we've added is information about the context of the text that we're looking for. Instead of saying
      that we just want all text, we're now saying that we want text that is in a <xmltag>term</xmltag> tag,
      and that tag has to be inside an <xmltag>admonitions</xmltag> tag. This type of arrangement is called a
      XPath path, and it gets used in a lot of places in XSLT stylesheets. For the moment, though, all we need
      to know is that by matching on <xmlattrval>admonitions/term/text()</xmlattrval>, the only text this
      template will match will be the admonitions terms, not the proprietary terms.</p>


    <p>We've matched our terms in the admonitions area, but now what do we do with them? The broken line of
      code that ends in line <cref linkend="code.uppercase-text-translate"/> appears to do the job, but what
      the heck's with all that alphabet soup? </p>

    <p>First, we have the <xmltag>xsl:value-of</xmltag> instruction, which we've seen before. It's just going
      to give us the value of whatever is specified by the <xmlattr>select</xmlattr> attribute. In this case,
      the attribute contains an XSLT function that will give us a value.</p>


    <p>The <ic>translate()</ic> function takes three arguments. The first argument is the string to be
      translated. The second argument is a list of characters to be found in the string given by the first
      argument. And the third argument is a list of characters to be substituted for the characters specified
      by the second argument. The position of the substitute character in the third argument matches the
      position of the selected character in the second argument. In our example, any <emph>a</emph> in the
      first argument will be replaced by <emph>A</emph>, any <emph>b</emph> by <emph>B</emph>, and so forth.
      The translation works only by single characters; you can't substitute <emph>AA</emph> for
      <emph>a</emph>, for instance. (You'll need another trick for that!)</p>

    <p>Given the match in line <cref linkend="code.uppercase-text-match2"/> and the translation in line <cref linkend="code.uppercase-text-translate"/>, our work is done. Everything is copied exactly the way it is
      except for text nodes that are within <xmltag>term</xmltag> tags inside the <xmltag>admonitions</xmltag>
      tag. Just the way we want it. So it's time to move on to the next example, right?</p>

    <p>Well, wait a second. What about those text tags that aren't in the admonitions section? We don't have a
      template that matches any other <ic>text()</ic> nodes, so how did the text get processed into the result
      document?</p>

    <p>Ah, our old friend the default template raises its hand in the back of the room. We always forget the
      quiet ones who do all their work behind the scenes, don't we?</p>
 
    <sidebar>
      <title>...And May the Best Match Win</title>
      <p>What would have happened if we had our template that matched <ic>admonitions/term/text()</ic> and
        another template that matched only <ic>text()</ic>? Both templates match text nodes---who wins?</p>
      
      <p>In all cases, the template that provides the most specific match to a given node will take priority
        over less specific matches. In this case, the text inside <ic>admonitions/term</ic> would get the
        match with the <ic>admonitions/term/text()</ic> template. </p>
      
      <p>This is another example of functional processing patterns at work in XSLT. We can set up a number of
        parallel templates with similar, but slightly different matches, and the XSLT processor sorts it all
        out for us. No worries, eh?</p>
    </sidebar>
 
  </sect1>

  <sect1>
    <title>Variation on a Theme #4: Changing One Word to Another</title>
    
    <p>We've seen the identity template make some pretty sweeping changes, but how about changing just a single word in a particular element?</p>
    
    <p>You've seen it happen before. The Marketing department has decided at the last minute that
      <emph>Vorblatz</emph> is probably not a great name for the company's outstanding new feature. Now they
      want to call it <emph>ForeKast</emph>. Vorblatz appears throughout the text, within different XML
      elements, like <xmltag>p</xmltag>, <xmltag>div</xmltag>, and <xmltag>note</xmltag>. And to make matters
      worse, the feature code can't change in the database, so any <xmltag>part-number</xmltag> tag still
      needs to start with the prefix <emph>Vorblatz</emph>.</p>

    <p>We could have easily handled this with a regular expression, but since the substitution is dependent on
      the XML tags, it's useful to have an XML-context-aware solution. There's nothing for it but write a
      stylesheet to handle that little problem. Let's check it out, then figure out how it works:</p>

<processedcode id="code.change-text1" language="xml" showname="to-identity/change-text1.xsl" style="normal" url="to-identity/change-text1.xsl">
<codeline prefix="Line 1">&lt;?xml version="1.0" encoding="utf-8"?&gt;</codeline>
<codeline prefix="-"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.change-text-match1" lineno="3" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/ | * | @*"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline prefix="5">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | @* | text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.change-text-match2" lineno="9" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"text()"</costring><cokw>&gt;</cokw> </codeline>
<codeline id="code.change-text-choose" lineno="10" prefix="10">    <cokw>&lt;xsl:choose&gt;</cokw> </codeline>
<codeline id="code.change-text-when" lineno="11" prefix="-">      <cokw>&lt;xsl:when</cokw> test=<costring>"contains(.,'Vorblatz') and not(parent::part-number)"</costring><cokw>&gt;</cokw>  </codeline>
<codeline id="code.change-text-substring-before" lineno="12" prefix="-">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before(.,'Vorblatz')"</costring><cokw>/&gt;</cokw></codeline>
<codeline id="code.change-text-text" lineno="13" prefix="-">        <cokw>&lt;xsl:text&gt;</cokw>ForeKast<cokw>&lt;/xsl:text&gt;</cokw>                          </codeline>
<codeline id="code.change-text-substring-" lineno="14" prefix="-">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-after(.,'Vorblatz')"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="15">      <cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline id="code.change-text-otherwise" lineno="16" prefix="-">      <cokw>&lt;xsl:otherwise&gt;</cokw> </codeline>
<codeline prefix="-">        <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline prefix="-">          <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"* | @* | text()"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline prefix="20">      <cokw>&lt;/xsl:otherwise&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:choose&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location to-identity-and-beyond.pml@451 ?>


    <p>That's a lot of new stuff, but you'll find that you use this technique to solve a lot of different
      problems in XML manipulation. So let's check it out.</p>

    <p>First, we see that the first template repeats our basic identity transform pattern. This is starting to
      feel like <emph>Groundhog Day</emph>.<footnote>
      <p><url>http://en.wikipedia.org/wiki/Groundhog_Day_%28film%29</url></p>
      </footnote></p>

    <p>But what happens inside the template at line <cref linkend="code.change-text-match2"/> is a pattern we
      haven't seen before. Here we encounter an <xmltag>xsl:choose</xmltag> tag, and within that tag we do
      several new things.</p>

    <p>With the <xmltag>xsl:choose</xmltag>, all sorts of new programming possibilities open up. The
      <xmltag>xsl:choose</xmltag> instruction is a conditional that allows the logic to make choices based on
      different conditions that you set within <xmlattr>test</xmlattr> attributes. The
      <xmltag>xsl:choose</xmltag> instruction can contain two types of XSLT instructions:</p>

    <ul>
      <li>
        <p><xmltag>xsl:when</xmltag>, of which there must be at least one. We can add as many of these as we
          need inside the <xmltag>xsl:choose</xmltag>. The <xmlattr>test</xmlattr> attribute is required; it
          contains an expression that evaluates to a Boolean <xmlattrval>true</xmlattrval> or
          <xmlattrval>false</xmlattrval>. We'll learn more about expressions as we go along. </p>
        <p>When the expression evaluates to <xmlattrval>true</xmlattrval>, the XSLT processor executes the
          contents of the <xmltag>xsl:when</xmltag> instruction <emph>as long as no <xmltag>xsl:when</xmltag>
          instruction before it evaluates to true.</emph> The trick to the <xmltag>xsl:choose</xmltag>
          instruction is that only the first <xmltag>xsl:when</xmltag> that evaluates to true is executed;
          after that, the XSLT processor goes on to the next instruction in the template, if there are
          any.</p>
      </li>
      <li>
        <p><xmltag>xsl:otherwise</xmltag>, which is optional. The contents of this instruction are executed
          only if none of the previous <xmltag>xsl:when</xmltag> instructions are executed. </p>

        <p>If <xmltag>xsl:otherwise</xmltag> is not present and none of the <xmltag>xsl:when</xmltag>
          instructions are true, nothing gets executes inside the <xmltag>xsl:choose</xmltag> instruction.</p>
      </li>
    </ul>

    <p>In our example, the <xmltag>xsl:when</xmltag> has a <xmlattr>test</xmlattr> expression that is slightly
      complicated. Basically, it's saying, "If the current context contains the string <emph>Vorblatz</emph>,
      and the parent element is <emph>not</emph> a <xmltag>part-number</xmltag> tag, evaluate to
      <ic>true</ic>."</p>

    <p>The first part of the expression, <xmlattrval>contains(.,'Vorblatz')</xmlattrval>, is a function. We
      saw a function before when we did our uppercasing transform, but that was the <ic>translate()</ic>
      function, and it returned a string. The <ic>contains()</ic> function simply returns a boolean value,
      true or false, based on its arguments.</p>

    <p><ic>contains(.,'Vorblatz')</ic> has two arguments: the first argument represents the string in which we
      will search for the target. In this case, the string is represented by the period (.), which is a
      shorthand way of saying "the current context." Our context at the moment is the text we've matched on;
      the entire piece of text will be searched.</p>

    <p>The second argument follows the comma and gives the target string that the processor will look for
      inside the first argument. Here the target is <ic>'Vorblatz'</ic>. (The single quotes tell the XSLT
      processor that the argument is a literal string.) If <emph>Vorblatz</emph> occurs inside the current
      text, the first part of the overall expression is true.</p>

    <p>The second part of the expression, which appears after the <ic>and</ic>, is also a function, the
      <ic>not()</ic> function. If the expression inside the <ic>not()</ic> function is true, the value of the
      function is false, and vice-versa. There's nothing tricky about it. In this case, the expression inside
      the function is <ic>parent::part-number</ic>. And guess what: this is another piece of XPath that we're
      using inside XSLT. The <ic>parent::</ic> is an <emph>axis</emph> that points to the parent node of the
      current context, and the part after it says what sort of node that parent is expected to be. (An axis is
      one of thirteen types of directional pointers in XPath that we'll learn about later.)</p>

    <p>Add it all up, and the <xmlattr>test</xmlattr> attribute gives a condition that must be true for the
      <xmltag>xsl:when</xmltag> instruction to execute: "If the current context (which is text) contains the
      string <emph>Vorblatz</emph>, and the parent element is <emph>not</emph> <xmltag>part-number</xmltag>,
      evaluate to <xmlattrval>true</xmlattrval>." Just what we said we needed. </p>

    <p>So what happens when it's true? Let's take a look at those three lines of code inside the
      <xmltag>xsl:when</xmltag>:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline id="code.change-text-substring-before2" lineno="1" prefix="Line 1"><cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before(.,'Vorblatz')"</costring><cokw>/&gt;</cokw></codeline>
<codeline id="code.change-text-text2" lineno="2" prefix="2"><cokw>&lt;xsl:text&gt;</cokw>ForeKast<cokw>&lt;/xsl:text&gt;</cokw>                          </codeline>
<codeline id="code.change-text-substring2" lineno="3" prefix="3"><cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-after(.,'Vorblatz')"</costring><cokw>/&gt;</cokw> </codeline>
</processedcode>
<?location to-identity-and-beyond.pml@532 ?>


    <p>We want to replace "Vorblatz" with "ForeKast," so we need to do some slicing and dicing on the text
      string. We'll output all the part of the text before "Vorblatz," then we'll substitute "ForeKast," then
      we'll output all of the text after "Vorblatz." </p>

    <p>To get that output, we're going to need two more functions: <ic>substring-before()</ic> and
      <ic>substring-after()</ic>. We use the <xmltag>xsl:value-of</xmltag> instruction to---you guessed
      it---output the value of whatever is selected by the <xmlattr>select</xmlattr> attribute. In <cref linkend="code.change-text-substring-before2"/>, the <ic>substring-before()</ic> function starts with its
      first argument (again, in this case, the period (.)), then it returns everything from the first argument
      that appears before the first occurrence of the second argument ("Vorblatz"). So part one of our
      fiendish plot of slicing and dicing is accomplished.</p>

    <p>In part two of the plot (line <cref linkend="code.change-text-text2"/>), we simply use the
      <xmltag>xsl:text</xmltag> instruction to output, literally, whatever its contents are. Since we are
      taking everything before and after "Vorblatz", all we want to substitute is "ForeKast". We use
      <xmltag>xsl:text</xmltag> because without it we might get some extra spaces or line returns. Extra
      whitespace probably wouldn't matter, but let's be precise and not introduce any trouble we don't want. </p>

    <p>Finally, part three happens in line <cref linkend="code.change-text-substring2"/>. The
      <ic>substring-after()</ic> function works just like the <ic>substring-before()</ic> function, except it
      takes everything in the string after the first occurrence of the second argument. </p>

    <p>And now the <xmltag>xsl:when</xmltag> instruction has done the substitution we wanted.</p>

    <p>If the string doesn't contain the forbidden "Vorblatz," we have our <xmltag>xsl:otherwise</xmltag>
      instruction to take care of it. Check out its contents starting at <cref linkend="code.change-text-otherwise"/> in the <ref linkend="code.change-text1"/>. Look familiar? Yep.
      All we're doing is copying the string as is, because it doesn't need any further manipulation. Our work
      here is done.</p>

    <p>Run that puppy!</p>
  </sect1>

  <sect1>
    <title>What We Did</title>
    <p>We could play with variations on the identity transform for a long time and not exhaust the possibilities.
       In fact, we'll see
      it again when we start doing recursive templates. For now, though, we've covered a lot of ground, so
      let's do a recap to see what we've learned. </p>

    <ul>
      <li>
        <p>We learned the basic pattern of the identity transform. </p>
      </li>
      <li>
        <p>We learned new elements:</p>
        <ul>
          <li>
            <p><xmltag>xsl:copy</xmltag>, to output a copy of the current context</p>
          </li>
          <li><p><xmltag>xsl:text</xmltag>, to output text with control over the whitespace</p></li>
          <li>
            <p><xmltag>xsl:choose</xmltag>, a structure for making conditional branches to the execution of a
              template</p>
          </li>
          <li>
            <p><xmltag>xsl:when</xmltag>, whose <xmlattr>test</xmlattr> attribute specifies a condition for
              execution of the contents of the <xmltag>xsl:when</xmltag> tag</p>
          </li>
          <li>
            <p><xmltag>xsl:otherwise</xmltag>, which acts as an optional catch-all for the
              <xmltag>xsl:choose</xmltag> if none of <xmltag>xsl:when</xmltag> conditions are true</p>
          </li>
        </ul>
      </li>
      <li>
        <p>We learned new tokens we can use in the match attribute, including wildcards for referencing the
          root (<ic>/</ic>), elements (<ic>*</ic>), and attributes (<ic>@*</ic>). We also learned about using
          the pipe (|) for a logical OR in match statements.</p>
      </li>
      <li>
        <p>We learned what functions are, and we learned about a few of them: <ic>translate()</ic>,
          <ic>contains()</ic>, <ic>not()</ic>, <ic>substring-before()</ic>, and
          <ic>substring-after()</ic>.</p>
      </li>
      <li>
        <p>We learned about matching on the most specific match when the same node type is matched in
          different templates.</p>
      </li>
      <li>
        <p>We learned how to extend the identity transform pattern to do special processing on specific nodes
          or node types when the rest of the XML can be copied verbatim.</p>
      </li>
    </ul>

    <p>One thing we didn't do was to set up special processing for two or three different elements or node
      types at the same time. I'm sure you can imagine how it would be done, though, right? Extra templates,
      new match statements for the nodes we're interested in, and off it goes.</p>

    <p>In fact, why don't you give it a try? For instance, if I told you that the space in "Sir Prize" was a
      mistake and needed to be removed at the same time you were uppercasing the admonitions, what would you
      do? Sounds like a substring function or two might be in order, what do you think? Go for it! </p>

    <p>Good deal. Sound's like we're ready to take on another big chunk of useful patterns.</p>

    <p>Next up: the wonderful world of reorganizing XML. Because you didn't think the output order was always
      going to follow the order of the source XML document, did you? No, and reorganizing those things can
      become amazingly complicated at times. But we've done well up to this point, so let's keep going.</p>

  </sect1>

</chapter>
<?location orderorder.pml@3 ?>

<chapter id="chap.orderorder">
  <title>Changing the Structure and <if-inline target="pdf"><newline/></if-inline>Order of Content</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p>I was not yet familiar with all the weapons, but my great familiarity with similar earthly weapons
        made me an apt pupil, and I progressed in a very satisfactory manner.</p>
    </epitext>
  </epigraph>
 <!-- 
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>XSLT provides the means to transform input into practically any order you can imagine. This ability
          gives it a tremendous advantage over a simple fall-through mechanism like CSS. Seeing some basic
          strategies for handling output structure will start giving you ideas...</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>You'll see some standard types of order manipulation you're likely to need when handling XML, and
          you'll see a couple of general strategies for re-ordering elements that will help you find your own
          solutions when needed. </p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>You'll be able to flatten hierarchical tags, wrap tags in other tags, add structure to flat lists,
          and change the order of tags from the source document. </p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>Changing the order of tags sometimes requires complex manipulations that are possible only if we
          can keep track of certain kinds of values. In the next chapter, we'll see things like variables,
          parameters, and counters that will help us with managing the structure of our output, along with a
          variety of other operations.</p>
      </dd>
    </dl>
  </storymap>
 --> 
  <p>One of the trickier parts of using XSLT is creating an output document in which the order of the content
    is significantly different than the order of the source document. The more difference in order between
    input and output, the more complex the stylesheet. Yep, that means we're about to hit one of the hard
    parts.</p>

  <p>Some kinds of things we might want to do with the order of our content are:</p>

  <ul style="compact">
    <li>
      <p>Flattening the structure</p>
    </li>
    <li>
      <p>Deepening the structure</p>
    </li>
    <li>
      <p>Adding structure to flat lists</p>
    </li>
    <li>
      <p>Moving child elements to be siblings</p>
    </li>
    <li>
      <p>Changing the order of tags</p>
    </li>
  </ul>

  <p>Methods that we will use in reordering content will include:</p>

  <ul>
    <li>
      <p>The careful matching and selection of elements in the <ic>xsl:template</ic>'s
        <xmlattr>match</xmlattr> attribute and the <ic>xsl:apply-templates</ic>'s <xmlattr>select</xmlattr>
        attribute.</p>
    </li>
    <li>
      <p>The use of the xsl:element tag to create new elements where we need them.</p>
    </li>

    <li>
      <p>The use of a syntax called XPath, which will allow us to address any part of an XML document from any
        other part of the document.</p>
    </li>
  </ul>

  <p>As I mentioned, we're about to get to some difficult parts,and the examples will take a little more room
    to demonstrate and explain. So we're going to divide this subject into two chapters: one without XPath,
    and one with XPath. We'll start out a little easy in this chapter by doing some re-structuring without
    XPath. Next chapter, we'll take on the subject of XPath by itself, developing an appreciation for its
    incredible power in the XSLT world. Then finally we'll come back around to the subject of re-ordering
    content, this time with our shiny new XPath tools. </p>

  <p>But first, let's see what it takes to flatten out some excessively structured XML.</p>

  <sect1>
    <title>Tidying Up Verbose XML</title>

    <p>It's a common problem: the data coming at you is a wonderful, complete resource chock full of
      informational goodness, but it's so overloaded with structure and data, it's completely inaccessible to
      the average reader. Maybe it's something like this:</p>

<processedcode language="xml" showname="no" size="small" style="normal">
<codeline><cokw>&lt;accounts&gt;</cokw></codeline>
<codeline>  <cokw>&lt;account</cokw> id=<costring>"123457"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;first&gt;</cokw>Jorge<cokw>&lt;/first&gt;</cokw></codeline>
<codeline>      <cokw>&lt;middle&gt;</cokw>Luis<cokw>&lt;/middle&gt;</cokw></codeline>
<codeline>      <cokw>&lt;last&gt;</cokw>Borges<cokw>&lt;/last&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/name&gt;</cokw></codeline>
<codeline>    <cokw>&lt;transactions&gt;</cokw></codeline>
<codeline>      <cokw>&lt;transaction</cokw> id=<costring>"TR-765432198"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;date&gt;</cokw></codeline>
<codeline>          <cokw>&lt;year&gt;</cokw>1984<cokw>&lt;/year&gt;</cokw></codeline>
<codeline>          <cokw>&lt;month&gt;</cokw>June<cokw>&lt;/month&gt;</cokw></codeline>
<codeline>          <cokw>&lt;day&gt;</cokw>6<cokw>&lt;/day&gt;</cokw></codeline>
<codeline>          <cokw>&lt;time&gt;</cokw>12:00:00<cokw>&lt;/time&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/date&gt;</cokw></codeline>
<codeline>        <cokw>&lt;amount&gt;</cokw>$14.99<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>        <cokw>&lt;product&gt;</cokw>B-5643A<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>      <cokw>&lt;transaction</cokw> id=<costring>"TR-654321987"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;date&gt;</cokw></codeline>
<codeline>          <cokw>&lt;year&gt;</cokw>1966<cokw>&lt;/year&gt;</cokw></codeline>
<codeline>          <cokw>&lt;month&gt;</cokw>July<cokw>&lt;/month&gt;</cokw></codeline>
<codeline>          <cokw>&lt;day&gt;</cokw>23<cokw>&lt;/day&gt;</cokw></codeline>
<codeline>          <cokw>&lt;time&gt;</cokw>23:47:12<cokw>&lt;/time&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/date&gt;</cokw></codeline>
<codeline>        <cokw>&lt;amount&gt;</cokw>$12.95<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>        <cokw>&lt;product&gt;</cokw>A-2345B<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/transactions&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/account&gt;</cokw></codeline>
<codeline><cokw>&lt;/accounts&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@134 ?>


    <p>You can find a longer version of this code with multiple <xmltag>account</xmltag> tags in
      <url>http://media.pragprog.com/titles/djkxsl/code/multiple_accounts.xml</url> if you want to try it
      yourself. Download the file, put it in a directory, then in the same directory create an XSLT file
      called </p>

    <p>Take a look at the XML file: that's a lot of tags for a little information. It's great to have that
      level of granularity in some cases, but in others we probably don't need separate entries for month,
      day, year, and time of day. If our main interest is in listing transactions for an account, we might be
      able to simplify the structure to make sorting and data identification a lot easier. Let's see how we
      might map this data to a simpler form of XML: </p>

<processedcode language="xml" showname="no" size="small" style="normal">
<codeline> <cokw>&lt;accounts&gt;</cokw></codeline>
<codeline>  <cokw>&lt;account</cokw> id=<costring>"123457"</costring> name=<costring>"Jorge Luis Borges"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;transaction</cokw> id=<costring>"TR-765432198"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;date&gt;</cokw>June 6, 1984, 12:00:00<cokw>&lt;/date&gt;</cokw></codeline>
<codeline>      <cokw>&lt;amount&gt;</cokw>$14.99<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>      <cokw>&lt;product&gt;</cokw>B-5643A<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>    <cokw>&lt;transaction</cokw> id=<costring>"TR-654321987"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;date&gt;</cokw>July 23, 1966, 23:47:12<cokw>&lt;/date&gt;</cokw></codeline>
<codeline>      <cokw>&lt;amount&gt;</cokw>$12.95<cokw>&lt;/amount&gt;</cokw></codeline>
<codeline>      <cokw>&lt;product&gt;</cokw>A-2345B<cokw>&lt;/product&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/transaction&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/account&gt;</cokw></codeline>
<codeline><cokw>&lt;/accounts&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@162 ?>


    <p>Ahh, much better. This is easier to read, and the data more to the point of what we're interested
      in.</p>

    <p>So what did we need to do to get the simpler form? Once thing we need to do is move the name elements
      into a single attribute for the <xmltag>account</xmltag> tag. Another is to remove the
      <xmltag>transactions</xmltag> tag entirely. And the third thing is to concatenate all those date
      elements into a single value for the <xmltag>date</xmltag> tag. These actions all represent typical
      methods of simplifying XML data structures.</p>

    <p>Let's tackle this one template at a time.</p>
    <sect2>
      <title>Moving Element Values into Attributes</title>

      <p>First, of course, we need an entry point into the file, so we'll set up a template to match on
        <xmltag>accounts</xmltag>. Inside that template, we'll just output the <xmltag>accounts</xmltag> tag
        the same as it was in the source, then we'll instruct the processor to apply templates, like so:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/accounts"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;accounts&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/accounts&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@187 ?>


      <p>We're processing the next set of tags inside the <xmltag>accounts</xmltag> tag, so what's the next
        template we need to build? See if you can get ahead of me on this one.</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"account"</costring><cokw>&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@196 ?>


      <p>Right. But we need some contents in this one. Taking a look at the output we wanted, we know that the
        <xmltag>account</xmltag> tag we output is going to look a little different than the tag we started
        with. In particular, that <xmlattr>name</xmlattr> attribute needs to be constructed from the contents
        of the <xmltag>name</xmltag> tag. To do this, we're going to need to use the
        <xmltag>xsl:element</xmltag> tag along with the <xmltag>xsl:attribute</xmltag> tag to create the new
        <xmlattr>name</xmlattr> attribute. Then, to fill in the value of the attribute, we'll need to get the
        parts of the name from the <xmltag>name</xmltag>. The construction of this attribute would look like
        so:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:attribute</cokw> name=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/first"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>   <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/middle"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>   <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/last"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@215 ?>


      <p>Since our current context is <xmltag>account</xmltag>, we can refer to the descendants of that tag
        with the paths we mentioned in <ref linkend="chap.howitlooks"/>. That's how we can get the values of
        the first, middle, and last names. Notice, too, that we have to add the spaces between the parts of
        the name ourselves, using the <xmltag>xsl:text</xmltag> tag. And all of it gets wrapped up nicely into
        the <xmlattr>name</xmlattr> attribute in our output.</p>

      <p>Did you also remember to put the <xmlattr>id</xmlattr> attribute from the original back into the
        <xmltag>account</xmltag> tag in the output? How about adding the <xmltag>xsl:apply-templates</xmltag>
        tag to keep the process flowing? If you remembered all that, your template is probably looking a good
        bit like this one: </p>
      <!-- Have we gone over how to select the value of an attribute yet? -->
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"account"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:element</cokw> name=<costring>"account"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:attribute</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"@id"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:attribute</cokw> name=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/first"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/middle"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/last"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"transactions"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@244 ?>


      <p>We added the <xmlattr value="transactions">select</xmlattr> to the
        <xmltag>xsl:apply-templates</xmltag> tag because we had already processed what we wanted out of the
        <xmltag>name</xmltag> tag and we didn't want to process it again.</p>

      <p>Sure, we've got that. What's next? Oh, right, we need to remove that useless
        <xmltag>transactions</xmltag> tag. Onward to the next section.</p>
    </sect2>
    <sect2>
      <title>Flattening the Structure of the Source</title>
      <p>This one is relatively easy---we saw clues toward how to do this in <ref linkend="chap.creatingoutput"/>.</p>

      <p>We're going to discard the <xmltag>transactions</xmltag> tag. So, just like we did with the
        <xmltag>name</xmltag> tag earlier, we can just not make a template to match on
        <xmltag>transactions</xmltag>, right? We're only interested in the <xmltag>transaction</xmltag> tags,
        after all...</p>

      <p>Okay, I thought I'd try to sneak a zinger past you. Yes, we actually do need a template to match on
        <xmltag>transactions</xmltag>, even if we're not keeping it, because we need to process its
        descendants. The template is dead simple, though, because we're not going to create any output for the
        <xmltag>transactions</xmltag> tag itself:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"transactions"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@272 ?>


      <p>And, <emph>voilà</emph>, we have taken a whole layer out of our XML hierarchy. Now we will process
        the individual <xmltag>transaction</xmltag> tags, and the new ones we create will be the immediate
        children of <xmltag>account</xmltag>. Nothing to it. That's the whole secret of taking a layer out of
        the structure...just process the tag, but don't create anything for it. </p>

      <p>Next? Ah, we need to tighten up that <xmltag>date</xmltag> tag. We'll need to rearrange the contents
        a bit, but that shouldn't be a problem. Let's have a look.</p>

    </sect2>
    <sect2>
      <title>Merging Elements Up into Higher Elements</title>
      <p>Another method of streamline XML is to merge a group of lower-level elements into a higher-level
        element, like we did with the <xmlattr>name</xmlattr> attribute. This type of merging is not
        necessarily great for storing data, but it's often used for presenting strings of related text in HTML
        and other output.</p>

      <p>There's nothing fancy about creating the new version of the <xmltag>transaction</xmltag> tags. The
        template for this tag will look a fair bit like our template for <xmltag>account</xmltag>, except the
        parts of the date will need to be rearranged a bit, and they will go into the <xmltag>date</xmltag>
        element rather than an attribute. We'll also need to preserve the <xmltag>amount</xmltag> and
        <xmltag>product</xmltag> tags in the <xmltag>transaction</xmltag> tag.</p>

      <p>One thing you might notice is that this part of the example does not really introduce any concepts
        you haven't already seen. So before I present the final solution, why not try your hand at it and see
        what you come up with.</p>

      <p>Here's what I've got:</p>

<processedcode language="xml" showname="orderorder/streamline.xsl" size="small" style="normal" url="orderorder/streamline.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"/accounts"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;accounts&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/accounts&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"account"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:element</cokw> name=<costring>"account"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:attribute</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"@id"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:attribute</cokw> name=<costring>"name"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/first"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/middle"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"name/last"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"transactions"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"transactions"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"transaction"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:element</cokw> name=<costring>"transaction"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"date"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:element</cokw> name=<costring>"date"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"month"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"day"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:text&gt;</cokw>, <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"year"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:text&gt;</cokw> <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"time"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"amount"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:element</cokw> name=<costring>"amount"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:element</cokw> name=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@302 ?>


      <p>I did the <xmltag>date</xmltag> tag a little differently than I did the <xmltag>name</xmltag> tag,
        with an extra template for <xmltag>date</xmltag>, but you could have done it the same way we did with
        the <xmltag>name</xmltag> tag. Just remember that if you create an
        <xmltag>xsl:apply-templates</xmltag> inside the template for <xmltag>transaction</xmltag>, you're
        going to need an empty template for <xmltag>date</xmltag> anyway, or you'll accidentally invoke those
        pesky built-in template rules, and you'll get the text of the sub-tags in <xmltag>date</xmltag> some
        place you don't want them.</p>
    </sect2>


  </sect1>

  <sect1>
    <title>Changing Elements from Children to Siblings</title>

    <p>Sometimes we'll need to move content out of its parent tag so it either follows or precedes the parent.
      Let's take a case where we have a list of configuration values in pairs, with one value as an attribute
      of a parent element, and one value as the text of a child element, like so: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;productlist&gt;</cokw></codeline>
<codeline>  <cokw>&lt;product</cokw> code=<costring>"AZ123"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>Wayback Machine<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/product&gt;</cokw></codeline>
<codeline>  <cokw>&lt;product</cokw> code=<costring>"BY234"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>Sonic Screwdriver<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/product&gt;</cokw></codeline>
<codeline>  <cokw>&lt;product</cokw> code=<costring>"CX345"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>Light Saber<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/product&gt;</cokw></codeline>
<codeline>  <cokw>&lt;product</cokw> code=<costring>"DW456"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;name&gt;</cokw>Tricorder<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/product&gt;</cokw></codeline>
<codeline><cokw>&lt;/productlist&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@338 ?>


    <p>What we'd like to do is get this into a simple HTML definition list, like this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;dl&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw>AZ123<cokw>&lt;/dt&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dd&gt;</cokw>Wayback Machine<cokw>&lt;/dd&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw>BY234<cokw>&lt;/dt&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dd&gt;</cokw>Sonic Screwdriver<cokw>&lt;/dd&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw>CX345<cokw>&lt;/dt&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dd&gt;</cokw>Light Saber<cokw>&lt;/dd&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw>DW456<cokw>&lt;/dt&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dd&gt;</cokw>Tricorder<cokw>&lt;/dd&gt;</cokw></codeline>
<codeline><cokw>&lt;/dl&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@353 ?>


    <p>The two lists are structure differently: in the first list, the product name is a child tag, in the
      second, the product name follows the product code as a sibling. In our typical template arrangement, we
      would be tempted to do this for processing the <xmltag>product</xmltag> tag:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"@code"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/dt&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@366 ?>


    <p>The processing for the child element (<xmltag>name</xmltag>) would be a child of <xmltag>dt</xmltag>,
      which maintains the relationship of the original. And that, of course, would be an unfortunate mistake.
      What we want is something more like:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"product"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;dt&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"@code"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/dt&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@379 ?>


    <p>The <xmltag>xsl:apply-templates</xmltag> tag is still operating within the context of the
      <xmltag>product</xmltag> tag, so it will still apply templates that match the children of
      <xmltag>product</xmltag>. But the structure of the output will be different, because now we've moved the
      <xmltag>xsl:apply-templates</xmltag> tag outside the <xmltag>dt</xmltag> tag. </p>

    <p>It's a subtle move, but it's another fine arrow in the quiver of methods for how we manipulate
      structure. And in complex templates, you may find it helpful to spend a little time analyzing the
      structue of your output versus the structure of your input to ensure that the child elements are indeed
      creating output in the right place in your output structure. </p>
    <p>For myself, I can say that this particular arrow once helped me solve a long, difficult puzzle in
      reconfiguring a lengthy set of stylesheets in the DITA Open Toolkit.<footnote>
      <p><url>http://ditaopentoolkit.org/</url></p>
      </footnote> As a result, I was able to allow customers to create landscape-oriented pages at any point
      in their PDF documents---something that apparently had never been done before. All from such a simple
      move! </p>
  </sect1>

  <sect1>
    <title>Wrapping Tags in Other Tags</title>
    <p>We actually did this one in the sections <ref linkend="sect1.addingtags"/> and <ref linkend="sect1.addingelements"/>. To summarize what we did there: you can add elements as text or add
      them dynamically using the <xmltag>xsl:element</xmltag> tag.</p>
    <p>In some cases we want to add a known element, in which case it's fine to use a text-based element. In
      other cases, we might not know the name of the element beforehand, in which case we'll need to use the
      <xmltag>xsl:element</xmltag> tag to generate the element with a name we somehow derive from the
      situation. We'll see an example of that in a minute.</p>

    <p>In some cases, the new element might be wrapped around one or more elements we're inheriting from the
      source document. In a case like this, we'll want the new element to be wrapped around the scripting that
      generates the existing element(s). For example, suppose we have this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;customer</cokw> name=<costring>"Edgar Allen Poe"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;street&gt;</cokw>203 Amity Street<cokw>&lt;/street&gt;</cokw></codeline>
<codeline>  <cokw>&lt;city&gt;</cokw>Baltimore<cokw>&lt;/city&gt;</cokw></codeline>
<codeline>  <cokw>&lt;state&gt;</cokw>Maryland<cokw>&lt;/state&gt;</cokw></codeline>
<codeline>  <cokw>&lt;zip&gt;</cokw>21233<cokw>&lt;/zip&gt;</cokw></codeline>
<codeline><cokw>&lt;/customer&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@419 ?>


    <p>Let's create a <xmltag>name</xmltag> tag, then wrap all those loose address elements in an
      <xmltag>address</xmltag> tag at the same level as <xmltag>name</xmltag>. All of it should still be
      contained in the <xmltag>customer</xmltag> tag. Give it a try---I suspect you've got this one already.
      Create an XML file with the contents shown above, then create an XSLT file with a stylesheet. Using our
      command-line approach (<ref linkend="chap.orderorder"/>), run the XSLT file against the XML file and see
      if you can get the following: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline> <cokw>&lt;customer&gt;</cokw></codeline>
<codeline>   <cokw>&lt;name&gt;</cokw>Edgar Allan Poe<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>   <cokw>&lt;address&gt;</cokw></codeline>
<codeline>     <cokw>&lt;street&gt;</cokw>203 Amity Street<cokw>&lt;/street&gt;</cokw></codeline>
<codeline>     <cokw>&lt;city&gt;</cokw>Baltimore<cokw>&lt;/city&gt;</cokw></codeline>
<codeline>     <cokw>&lt;state&gt;</cokw>Maryland<cokw>&lt;/state&gt;</cokw></codeline>
<codeline>     <cokw>&lt;zip&gt;</cokw>21233<cokw>&lt;/zip&gt;</cokw></codeline>
<codeline>   <cokw>&lt;/address&gt;</cokw></codeline>
<codeline><cokw>&lt;/customer&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@438 ?>


    <p>One way to do it is like this:</p>

<processedcode language="xml" showname="orderorder/customer.xsl" style="normal" url="orderorder/customer.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"/customer"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;customer&gt;</cokw></codeline>
<codeline>      <cokw>&lt;name&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"@name"</costring><cokw>/&gt;</cokw><cokw>&lt;/name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;address&gt;</cokw><cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw><cokw>&lt;/address&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/customer&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"street"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;street&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw><cokw>&lt;/street&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"city"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;city&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw><cokw>&lt;/city&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"state"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;state&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw><cokw>&lt;/state&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"zip"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;zip&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"."</costring><cokw>/&gt;</cokw><cokw>&lt;/zip&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@442 ?>


    <p>Did you try it? The output won't look exactly like what we are after, but that's just a matter of line
      indents and line returns. The structure of the XML is what we're after, and that looks right on
      target.</p>

    <p>Later we'll learn a shortcut so all those templates for the different address elements can be rolled
      into one, but this will work for now.</p>

    <p>As you can see in this example, the beginning and end tags surround the <xmltag close="yes">xsl:apply-templates</xmltag> tag, enclosing the various existing tags as we had hoped. </p>

    <p>What if we wanted to add a new tag between two tags instead of enclosing tags? Suppose we took our
      result XML and wanted to add <xmltag>occupation</xmltag> between <xmltag>name</xmltag> and
      <xmltag>address</xmltag>? Basically, we'd just put the additional tag between the elements that process
      the other tags, making sure NOT to wrap the new element around anything else. In this instance, we know
      the customer's occupation (“mad poet”), so we do it the easy way. The template that matches
      on <xmltag>customer</xmltag> would now look like this: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/customer"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;customer&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"name"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;occupation&gt;</cokw>mad poet<cokw>&lt;/occupation&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"address"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/customer&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@469 ?>


    <p>Then we would have templates matching <xmltag>name</xmltag> and <xmltag>address</xmltag> to fill in the
      rest of the tags. Go ahead and try this: whatever name you gave to your output file in the exercise
      above, use it as the input file for another XSLT transform you write. (You can do this kind of chaining
      of output files to input files all day---and sometimes there are good reasons for doing so, as we'll see
      in a later chapter.) Add the <xmltag>occupation</xmltag> tag, keeping all the other tags. Bonus points
      if you invert the order of the address elements!</p>

    <p>There's no big deal to adding tags to the output. Think about where you want the new tag and what it
      wraps around (or doesn't), then create related tags around, inside, above, or below the new tag so it
      appears where you want. Sounds easy, right? </p>
    <p>Good---because now we're going to move on to something a little trickier. Adding structure to a flat
      list of elements.</p>

  </sect1>

  <sect1 id="sect1.structuring-flat-lists">
    <title>Adding structure to flat lists</title>

    <p>I see it all the time: someone uses Microsoft Word without applying styles to anything. Section titles,
      figure titles, even the chapter headings are default paragraphs formatted to look like headings. Then
      the culprit, er, poor soul comes to me asking to convert it to an ebook. Sure, I can save
      the Word file as XML, but then I just get a long string of <xmltag>p</xmltag> tags. In the resulting ebook,
      all their lovingly hand-crafted headings look just like standard paragraphs.</p>

    <p>Good thing I've got XSLT to whip it into shape.</p>

    <p>Looking beyond my little problems, you're undoubtedly going to encounter data that needs additional
      structure imposed on it. A legacy file of undifferentiated tags is a common problem. They might be
      things you want to keep in the same order, but with different tags wrapped around sets of tags that have
      an affinity for each other, or you might want to untangle a bunch of tags, for instance, taking a bunch
      of <xmltag>customer</xmltag> tags and grouping them appropriately into
      <xmltag>corporate-customer</xmltag>, <xmltag>nonprofit-customer</xmltag>, and
      <xmltag>regular-customer</xmltag>. Or we might just need to swap content around so it's better organized for a particular audience.</p>

    <p>In the following sections, and in <ref linkend="chap.order-order-2"/>, we'll see how to deal with all these types of problems.</p>
  </sect1>

  <sect1>
    <title>Play It as It Lays</title>
    <p>In this approach, we're going to address that problem I mentioned earlier, the undifferentiated
      <xmltag>p</xmltag> tags. This example addresses a more general situation: the order of the tags is okay,
      but we'd like to get them into a more appropriate structure.</p>

    <sect2>
      <title>Examples, Bad and Good</title>

      <p>First, let's have a look at the drek...um...source file our associate has gifted us with:</p>

<processedcode language="xml" showname="orderorder/badlist.xml" size="small" style="normal" url="orderorder/badlist.xml">
<codeline><cokw>&lt;document&gt;</cokw></codeline>
<codeline> <cokw>&lt;p</cokw> font-size=<costring>"14pt"</costring> font-weight=<costring>"bold"</costring><cokw>&gt;</cokw>Grizzlies and People<cokw>&lt;/p&gt;</cokw></codeline>
<codeline> <cokw>&lt;p</cokw> font-size=<costring>"10pt"</costring> font-weight=<costring>"regular"</costring><cokw>&gt;</cokw>Since the Ice Age,</codeline>
<codeline>    man has feared the great denizens of the north. But why is that?<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"12pt"</costring> font-weight=<costring>"bold"</costring><cokw>&gt;</cokw>Horribleness<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"10pt"</costring> font-weight=<costring>"regular"</costring><cokw>&gt;</cokw>Grizzlies are so horrible,</codeline>
<codeline>    they are named <cokw>&lt;emph&gt;</cokw>Ursus horribilis<cokw>&lt;/emph&gt;</cokw>. 'Nuff said?<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"12pt"</costring> font-weight=<costring>"bold"</costring><cokw>&gt;</cokw>Largeness<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"10pt"</costring> font-weight=<costring>"regular"</costring><cokw>&gt;</cokw>Male grizzlies can average</codeline>
<codeline>    900 pounds and 9 feet tall. That's a lot of bear to feed, and they</codeline>
<codeline>    don't mind a little human in the diet!<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"12pt"</costring> font-weight=<costring>"bold"</costring><cokw>&gt;</cokw>Aggressiveness<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"10pt"</costring> font-weight=<costring>"regular"</costring><cokw>&gt;</cokw>Grizzlies are too large to</codeline>
<codeline>    escape danger by climbing trees; instead, they stand their ground.<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p</cokw> font-size=<costring>"10pt"</costring> font-weight=<costring>"regular"</costring><cokw>&gt;</cokw>All that being said,</codeline>
<codeline>    humans are still more dangerous than grizzly bears!<cokw>&lt;/p&gt;</cokw></codeline>
<codeline><cokw>&lt;/document&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@519 ?>


      <p>That's pretty gnarly. In a well-structured XML file, we would like to see something more like
        this:</p>

      <figure id="code.grizzlies">
        <title>The Output We Want for the Grizzly Essay</title>
<processedcode language="xml" showname="no" size="small" style="normal">
<codeline><cokw>&lt;chapter&gt;</cokw></codeline>
<codeline>  <cokw>&lt;title&gt;</cokw>Grizzlies and People<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p&gt;</cokw>Since the Ice Age, man has feared the great denizens of the north.</codeline>
<codeline>  But why is that?<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;section1&gt;</cokw></codeline>
<codeline>    <cokw>&lt;title&gt;</cokw>Horribleness<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p&gt;</cokw>Grizzlies are so horrible, they are named <cokw>&lt;emph&gt;</cokw>Ursus horribilis<cokw>&lt;/emph&gt;</cokw>.</codeline>
<codeline>      'Nuff said?<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/section1&gt;</cokw></codeline>
<codeline>  <cokw>&lt;section1&gt;</cokw></codeline>
<codeline>    <cokw>&lt;title&gt;</cokw>Largeness<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p&gt;</cokw>Male grizzlies can average 900 pounds and 9 feet tall. That's a lot of bear</codeline>
<codeline>      to feed, and they don't mind a little human in the diet!<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/section1&gt;</cokw></codeline>
<codeline>  <cokw>&lt;section1&gt;</cokw></codeline>
<codeline>    <cokw>&lt;title&gt;</cokw>Aggressiveness<cokw>&lt;/title&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p&gt;</cokw>Grizzlies are too large to escape danger by climbing trees; instead, they</codeline>
<codeline>    stand their ground.<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/section1&gt;</cokw></codeline>
<codeline>  <cokw>&lt;p&gt;</cokw>All that being said, humans are still more dangerous than grizzly bears!<cokw>&lt;/p&gt;</cokw></codeline>
<codeline><cokw>&lt;/chapter&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@548 ?>

      </figure>

      <p>One advantage of XML like this is that it's much easier to maintain. Imagine someone confronted with
        the XML file in the first example, trying to put in all the font styles, sizes, and weights for each
        paragraph. Crazy talk!</p>

      <p>Another advantage is that the structure is more explicit. Look at that last <xmltag>p</xmltag> tag in
        the first example. Does it belong to the secondary heading or the top heading? Who knows? In fact,
        when we restructure the XML, we're going to have some difficulties sorting it out ourselves.</p>

      <p>But that's the hand we've been dealt, so let's get to work.</p>
    </sect2>
    <sect2>
      <title>Starting with a Conceptual Approach</title>
      <p>Before we leap into writing the stylesheet, let's take a little time to think through how we're going
        to approach this one. In general, a little advanced planning can go a long way toward resolving the
        problems.</p>

      <p>What we need is a way to focus on the <xmltag>p</xmltag> tags that are headings, wrap
        some heading tags around those, and then within the heading tags, process only the following
        <xmltag>p</xmltag> tags that are actual text tags belonging within that section. That means we also
        have to keep track of what "this section" means. </p>
      <p>We can select the <xmltag>p</xmltag> tags that follow a <xmltag>p</xmltag> tag with the font size of
        12pt, for instance, but how do we know when to stop? To do that, we will want to check whether the
        text <xmltag>p</xmltag> tag in question comes after the <xmltag>p</xmltag> tag for our heading, but
        not after the <xmltag>p</xmltag> tag for the next heading. That means we'll somehow need a way of
        keeping track of which <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr> is
        which.</p>

      <p>To do all this, we're going to introduce several new XSLT mechanisms and make use of them. Here's a
        quick rundown of the tools we'll need:</p>

      <dl>
        <dt bold="yes" newline="yes">[ ]</dt>
        <dd>
          <p>The square brackets [ ] create what is called a <firstuse>predicate</firstuse>. Predicates are
            added to node names to refine the description of the nodes being referred to. For example, if we
            want to select a <xmltag>p</xmltag> tag, but we only want the <xmltag>p</xmltag> tags where
            <xmlattr value="12pt">font-size</xmlattr>, we can refine our selection like this: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@fontsize='12pt']"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@591 ?>


          <p>We can enter a variety of expressions inside the predicate. For instance, you could just put the
            name of a node (say, @font-size for the <xmlattr>font-size</xmlattr> attribute) to test for its
            existence. If the XSLT processor finds a node where the expression evaluates to <emph>true</emph>,
            then the node is selected. You'll find predicates to be extremely useful, especially in a problem
            like our list of identical elements with small differences in attributes or contents. </p>
        </dd>

        <dt newline="yes">not()</dt>
        <dd>
          <p>not() is a an XSLT function. We first ran into functions in the section <ref linkend="sect1.uppercasing"/> earlier in this book.</p>

          <p>The not() function requires an expression within the parentheses. The expression can be something
            as simple as a character or a node, or something with much more complex logic operators. The not()
            function works by first evaluating whether the expression in parentheses is true, then negates the
            logical value of the expression.</p>
          <p>For example, if the function is <ic>not(p)</ic>, and the node being examined by the XSLT
            processor is a <xmltag>p</xmltag>, tag, then the not() function returns a <emph>false</emph>
            value. If the function is <ic>not(document)</ic>, and the node being examined by the XSLT
            processor is a <xmltag>p</xmltag>, it returns a <emph>true</emph> value. </p>
        </dd>
        <dt newline="yes">generate-id()</dt>
        <dd>
          <p>The generate-id() function has a single purpose: it generates a unique value for an XML node when
            the document is processed. The node is defined by an expression inside the parentheses. Using
            generate-id() gives us a way to identify any given XML node in the document with a unique value.
            We'll learn more about functions and values in <ref linkend="chap.values"/>. </p>
        </dd>

        <dt newline="yes"><xmltag>xsl:variable</xmltag></dt>
        <dd>
          <p>Speaking of values, <xmltag>xsl:variable</xmltag> provides a means to name and define or derive a
            value. That's the easy definition, and the only thing we'll need to know for our current exercise.
            Again, we'll learn more about it in <ref linkend="chap.values"/>.</p>
        </dd>

        <dt newline="yes">following-sibling</dt>
        <dd>
          <p>following-sibling is an <firstuse>axis</firstuse>, a directional pointer used in XPath
            expressions. Let's not worry too much about what axes and XPath mean at the moment. Basically,
            following-sibling just tells the XLST processor to look for XML nodes that follow the current
            node, at the same level in the XML hierarchy, and only within the same parent tag as the current
            node. We'll see an example of this in action in the example solution that follows.</p>
          <p>following-sibling and other axes are used in much the same places as functions, except that they
            return XML nodes or node-sets rather than values. For our example, think of it selecting a
            specific set of <xmltag>p</xmltag> tags following a given <xmltag>p</xmltag> tag. We can also
            modify following-sibling to be more specific about what it selects. Yeah, we can use that.</p>
        </dd>

        <dt newline="yes">preceding-sibling</dt>
        <dd>
          <p>Yep, similar to following-sibling, except that it selects nodes that precede the current node
            within the same parent.</p>
        </dd>
      </dl>


      <p>Breaking up a list like this is a bit of a thorny problem, but we've got the tools---and by the end
        of this example, we should know how to use them.</p>

    </sect2>
    <sect2>
      <title>Writing the List-Buster: Part 1</title>

      <p>We're going to transform the bad example into the good example. Let's take the problem one template
        at a time. This is going to be a bit of a long session, so hang with me.</p>

      <p>First, let's do the obvious part: we'll convert that <xmltag>document</xmltag> tag to a
        <xmltag>chapter</xmltag> tag:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/document"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;chapter&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@668 ?>


      <p>We want everything else to go between the <xmltag>chapter</xmltag> tags. Let's ask: what else do we
        need at the top level? Well, the chapter title, right. So we add an
        <xmltag>xsl:apply-templates</xmltag> that selects specifically for that <xmltag>p</xmltag> tag with
        the font-size of 14pt. Remember how to select for an attribute and its value? Give it a try and see if
        you can get only the title. Remember, you'll need a template to partner with the
        <xmltag>xsl:apply-templates</xmltag> tag.</p>

      <p>After the title, we need something that will pick up that one text paragraph that occurs before the
        <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr>. This one's a bit tricky. Take a
        look at those extra tools I gave you earlier and see what you can come up with.</p>

      <p>Here's what I've got so far: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline prefix="Line 1"><cokw>&lt;xsl:template</cokw> match=<costring>"/document"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;chapter&gt;</cokw></codeline>
<codeline id="code.chapter-title" lineno="3" prefix="-">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='14pt']"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline id="code.chapter-text" lineno="5" prefix="5">      <costring>and not(preceding-sibling::p[@font-size='12pt'])]"</costring><cokw>/&gt;</cokw>  </codeline>
<codeline prefix="-">  <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.chapter-title-template" lineno="9" prefix="-"><cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='14pt']"</costring><cokw>&gt;</cokw> </codeline>
<codeline prefix="10">  <cokw>&lt;title&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/title&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="15"><cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline prefix="-">  <costring>and not(preceding-sibling::p[@font-size='12pt'])]"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;p&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/p&gt;</cokw></codeline>
<codeline prefix="20"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder.pml@704 ?>

      
      <p>Let's go through this in a bit more detail to see how it works. We're seeing a couple of new tricks
        here that we need to understand. </p>

      <p>First, in line <cref linkend="code.chapter-title"/>, we see that we've applied templates to select
        <xmltag>p</xmltag> tags, but we've also added a predicate. The predicate ensures that we select only
        <xmltag>p</xmltag> tags where the font size is 14pt. In line <cref linkend="code.chapter-title-template"/> we've created the corresponding template, which wraps the
        <xmltag>title</xmltag> tag around the text of the selected paragraph. Cool, there's our chapter title. </p>

      <p>Next, in line <cref linkend="code.chapter-text"/> and the preceding line, we've got a more
        complicated predicate. Here we're trying to select that <xmltag>p</xmltag> tag that comes immediately
        after the one with <xmlattr value="14pt">font-size</xmlattr>, but before the one with <xmlattr value="12pt">font-size</xmlattr>. We want this paragraph to be at the chapter level and not within any
        of the <xmltag>h1</xmltag> tags we're going to create. Two things we know about it is that it has a
        font-size of 10pt and it comes before any <xmltag>p</xmltag> tag with a font size of 12pt. We convert
        that knowledge into a logical expression in the predicate: </p>

<processedcode showname="no" style="normal">
<codeline>select="p[@font-size='10pt' and not(preceding-sibling::p[@font-size='12pt'])]</codeline>
</processedcode>
<?location orderorder.pml@725 ?>


      <p>Here we are adding a couple of logical constructs to our list of tools. First: the expression within
        the predicate contains an <firstuse>and</firstuse> operator, which works like a normal logical AND
        operator in any language. Both sides of the <emph>and</emph> have to be true for the expression to be
        true. </p>

      <p>Second, we have the not() function. The contents of this function test whether the <xmltag>p</xmltag>
        tag currently selected has a preceding sibling <xmltag attrs="font-size=“12pt”">p</xmltag>. If it <emph>doesn't</emph> have such a sibling, then the not() function evaluates as
        true, and bingo!, we have the paragraph that comes before the other headings. That's what we were
        after.</p>

      <p>Take a look back at <ref linkend="code.grizzlies"/>. Give the XSL stylesheet a try, and play around
        with some of the <xmlattr>select</xmlattr> statements to see the effect, comparing it to the original
        output. It's fine if you break it...it's just like taking apart a watch, right? Everything just goes
        back the opposite way it came apart. No problem, right?</p>

      <p>As you check out the new functions, also think about how we have used them to make a more complex
        re-ordering of our original document. Through the rest of this book, we'll see that the new functions
        we have used will be an ongoing and vital part of our growing toolset.</p>

      <p>The more we learn about XSL, the more you should be seeing the kinds of possibilities there are for
        making the XML sing, dance, and do the sorts of circus tricks that you may be asked to do. We're
        beginning to see that the XML is not just dead code in a file any more. We're learning to make it come
        alive! </p>
    </sect2>
  </sect1>

  <sect1>
    <title>What We Did</title>

    <p>Don't get too excited, though---we still have a lot ahead of us. So far we've only changed the
      structure and order of the content while keeping the output content fairly close to its original order
      in the source document.</p>

    <p>But we still did a lot of work:</p>
    
    <ul style="compact">
      <li>
        <p>moving an element into a parent's attribute</p>
      </li>
      <li>
        <p>removing a level from the source</p>
      </li>
      <li>
        <p>merging several elements into a higher-level element</p>
      </li>
      <li>
        <p>changing elements from children to siblings</p>
      </li>
      <li>
        <p>wrapping tags in other tags</p>
      </li>
      <li>
        <p>adding structure to a flat list without rearranging the elements</p>
      </li>
    </ul>

    <p>In the last section we added a lot of new XSLT functionality to our knowledge base. We'll spend a
      little more time with some of these in subsequent chapters, so don't get too concerned that we're
      brushing through them. The XPath axes in particular will be part of the next chapter, when we take our
      restructuring efforts to greater heights. </p>

    <p>So let's bring it on.</p>
  </sect1>

</chapter>
<?location xpath-order.pml@3 ?>

<chapter id="chap.xpath-order">
  <title>XPath: The Sibling Language Unveiled</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p/>
    </epitext>
  </epigraph>
  <!--  
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>XSLT provides the means to transform input into practically any order you can imagine. This ability
          gives it a tremendous advantage over a simple fall-through mechanism like CSS. Seeing some basic
          strategies for handling output structure will start giving you ideas...</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>You'll see some standard types of order manipulation you're likely to need when handling XML, and
          you'll see a couple of general strategies for re-ordering elements that will help you find your own
          solutions when needed. </p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>You'll be able to flatten hierarchical tags, wrap tags in other tags, add structure to flat lists,
          and change the order of tags from the source document. </p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>Changing the order of tags sometimes requires complex manipulations that are possible only if we
          can keep track of certain kinds of values. In the next chapter, we'll see things like variables,
          parameters, and counters that will help us with managing the structure of our output, along with a
          variety of other operations.</p>
      </dd>
    </dl>
  </storymap>
-->
  <sect1>
    <title>XPath: Mapping XML All Over the Place</title>

    <p>So what the heck is XPath? We've heard a lot about it, and we know it's supposed to help us with
      rearranging our document, among other things. So let's have a look at this beast by the full light of
      day.</p>

    <p>XPath is a language, mostly a syntax, used to reference parts of an XML document. We will use it in the
      attributes of XSLT instructions to return an XML node or set of nodes (called a
      <firstuse>node-set</firstuse>) for a variety of uses. For instance, we can use it in the
      <xmlattr>select</xmlattr> attribute of the <xmltag>xsl:value-of</xmltag> and
      <xmltag>xsl:apply-templates</xmltag> tag, or we can use it with a function in an expression to count
      nodes we might be interested in and compare that count to another value. </p>

    <p>The handy thing about XPath is that you can use it to refer to just about any node or node-set you can
      imagine from within the context of any other node in the document. Or to put it more bluntly: XPath
      gives you access to <emph>everything</emph> from <emph>anywhere</emph>.</p>

    <p>Now, that's power!</p>

    <joeasks>
      <title>But What Is XPath, Officially?</title>
      <p>XPath is short for XML Path Language: it's a language designed for addressing nodes in an XML
        document. It isn't really used by itself, but it's used in the context of other languages. Currently
        it exists as a recommendation of the World Wide Web Consortium (W3C).<footnote>
        <p><url>http://www.w3.org/TR/xpath/</url></p>
        </footnote> Version 1.0 of the recommendation was published in 1999 and has not been modified since.
        (There is also an XPath 2.0, as of 2010, but we won't be using that in this book.) The good news is
        that it's a language with a very stable syntax.</p>
      <p>Another piece of good news is that XPath is also used in XQuery, XPointer, and XLink, which are
        systems or languages that process XML in different ways. It can also be used in the Domain Object
        Model (DOM) of XML-based languages like XHTML, and it can be used in JavaScript<footnote>
        <p><url>https://developer.mozilla.org/en-US/docs/Introduction_to_using_XPath_in_JavaScript</url></p>
        </footnote> So once you learn a little XPath, you'll be dangerous on a lot of fronts.</p>
    </joeasks>

    <p>Since this is not a book about XPath, we'll just get a brief introduction to it in this chapter. The
      introduction should be enough to give you the flavor of it, and hopefully spur you on to explore it
      further. XPath adds a power to XSLT that helps to round out XSLT's full potential.</p>

    <p>To learn more about XPath (after reading the admirable introduction that follows, of course!), check
      out the online information for it at <url>http://www.w3schools.com/xpath/default.asp</url> or
      <url>http://www.w3.org/TR/xpath/</url>. </p>
    <p>In this chapter, we'll get a whirlwind tour of these parts of XPath, then we'll continue our
      exploration of how to restructure an XML document by using some serious XPath statements.</p>

    <p>Whirlwinds? Put on the goggles and let's dive in!</p>

  </sect1>

  <sect1>
    <title>XPath in a Thimble</title>
    <p>Before we lose track of the forest for the trees, let's take a high-level look at the major functional
      areas of XPath.</p>

    <ul style="compact">
      <li>
        <p>The Data Model</p>
      </li>
      <li>
        <p>Location Paths</p>
      </li>
      <li>
        <p>Expressions</p>
      </li>
      <li>
        <p>Functions</p>
      </li>
    </ul>
    <p>After the high-level look, we'll dive a good bit deeper into each area, particularly location
      paths.</p>

    <dl style="bold">
      <dt newline="yes">The Data Model</dt>
      <dd>
        <p>The data model describes the parts of the XML that we want to address, XML nodes like elements,
          attributes, text, comments, and so forth. XPath offers a vocabulary for describing these parts,
          including some wild-card naming conventions. We'll use the data model as a way to describe the parts
          of the XML we want to address or retrieve.</p>
      </dd>

      <dt newline="yes">Location Paths</dt>
      <dd>
        <p>Location paths are the directions for getting from the current context node to one or more nodes.
          Location paths can include the following parts:</p>
        <ul>
          <li>
            <p><firstuse>Axes</firstuse> represent different directions, but instead of north, south, etc., we
              can point to a child, parent, ancestor, descendant---we can even point to "here." XPath includes
              13 axes.</p>
          </li>
          <li>
            <p><firstuse>Node tests</firstuse> represent the type or name of the destination:
              <emph>school</emph>, <emph>church</emph>, <emph>gas_station</emph>, <emph>home</emph>. These
              example destinations could be the names of element nodes in our XML. We'll use the vocabulary of
              the data model in this part of location paths.</p>
          </li>
          <li>
            <p><firstuse>Predicates</firstuse> appear at the end of a location path and are contained in
              square brackets ([]). Predicates act as filters that describe important distinctions about the
              destinations we are interested in. </p>
          </li>
        </ul>
      </dd>

      <dt newline="yes">Functions</dt>
      <dd>
        <p>We've discussed functions before (<ref linkend="sect1.uppercasing"/>): functions are instructions
          that return values. For quick reference, the XSLT 1.0 functions are listed in <ref linkend="app.functions"/>. </p>
        <p>If we were using a mobile device, functions might perform like some of the extra tools in an online
          map application. For instance, if you want to know where is the closest restaurant with a five-star
          rated bathroom, the application would need a function that returned the distance to each restaurant
          and compared them, and another function to determine how many stars each bathroom is rated. In XSLT,
          we'll use functions in a lot of places, even outside of XPath.</p>

      </dd>

      <dt newline="yes">Expressions</dt>
      <dd>
        <p>Expressions are logical combinations of language elements that are interpreted and evaluated by the
          XSLT processor to return a value.</p>

        <p>In a <xmlattr>match</xmlattr> attribute, you might use an expression inside a predicate on the
          <xmltag>note</xmltag> element, like this: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:apply-templates</cokw> match=<costring>"note[@type='caution'</costring></codeline>
<codeline>   <costring>or contains(text(),'caution')]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@173 ?>


        <p>The equals sign (=) and the word <emph>or</emph> are <firstuse>tokens</firstuse> or parts of the
          XPath expression syntax. For a list of tokens used in XPath expressions, see <ref linkend="sect1.expressions"/>.</p>

        <p>In XSLT, we use expressions for selecting nodes and for specifying tests for conditional
          processing, and for creating text, among other things. </p>

      </dd>
    </dl>

    <p>We're about to embark on a lengthy tour of these four XPath components to give you the working
      vocabulary you need to start putting together more complex XSLT stylesheets. It's a big chunk, but we're
      going to need it. Right about now I'd grab a caffeinated beverage, shut the door, and hide the clock.
      This won't hurt a bit. Trust me! ;-)</p>

  </sect1>


  <sect1 id="sect1.data.model">
    <title>The Data Model</title>

    <p>The data model is the XPath a way of describing and naming certain parts of an XML document. You'll
      need this for just about everything you do in XSLT.</p>

    <p>The following table showing the kinds of nodes in the XPath data model. The table also shows how these
      node types are referenced in the <xmlattr>match</xmlattr> attribute in XSLT. (Although I'm showing them
      in <xmlattr>match</xmlattr> attributes for convenience, you can use these representations in other parts
      of an XSLT document.)</p>

    <table style="hlines">
      <title>Node Types in the XPath Data Model</title>
      <colspec col="1" width="18%"/>
      <colspec col="2" width="22%"/>
      <row>
        <col><p>Root node</p></col>
        <col><p><xmlattr value="/">match</xmlattr></p></col>
        <col><p>The root node is the top-level position in the XML tree, even above the root element.
          Everything else in the document is a child of the root node.</p></col>
      </row>
      <row>
        <col><p>Element nodes</p></col>
        <col><p><ic>match=</ic><newline/><ic>"</ic><emph>element_name</emph><ic>"</ic></p></col>
        <col><p>Elements are what we have been calling tags. In some conditions you may also have to include
          the element's namespace to fully represent the element.</p></col>
      </row>
      <row>
        <col><p>Attribute nodes</p></col>
        <col><p><ic>match=</ic><newline/><ic>"@</ic><emph>attribute_name</emph><ic>"</ic></p></col>
        <col><p>Attributes belong to elements, but they are not children of elements. Attributes provide
          additional information that is relevant to the context of its element.</p></col>
      </row>
      <row>
        <col><p>Text nodes</p></col>
        <col><p><ic>match="text()"</ic></p></col>
        <col><p>Any group of continuous text (including whitespace) in an XML document is considered to be a
          text node. Two pieces of text separated by an element, empty or otherwise, are considered to be two
          text nodes. A text node is always a child of the element that contains it.</p></col>
      </row>
      <row>
        <col><p>Processing instruction nodes</p></col>
        <col><p><ic>match=</ic><newline/><ic>"processing-instruction()"</ic></p></col>
        <col><p>Processing instructions provide special instructions directly to the XSLT processor;
          otherwise, they are ignored by the XSLT. </p></col>
      </row>
      <row>
        <col><p>Comment nodes</p></col>
        <col><p><ic>match=</ic><newline/><ic>"comment()"</ic></p></col>
        <col><p>XML comments (represented as &lt;- - (some content) - -&gt;) are nodes that may or may not be
          recognized by specific XML parsers. The XSLT processor will not be able to retrieve the text of the
          comment node if it is not passed along by the XML parser being used.</p></col>
      </row>
      <row>
        <col><p>Namespace nodes</p></col>
        <col><p><ic>match=</ic><newline/><ic>"@xmlns:</ic><newline/><emph>namespace_prefix</emph><ic>"</ic></p></col>
        <col><p>Namespace nodes define the XML namespaces for an element. Namespace nodes occur in document
          order before attributes nodes. For more curious information about namespace nodes, refer to
          <url>http://www.w3.org/TR/xpath/#namespace-nodes</url>. All that being said, namespace nodes are
          seldom referenced in XSLT.</p></col>
      </row>
    </table>

    <sect2>
      <title>Wildcards and General Representations for Nodes</title>

      <p>We've learned there are general expressions for node types <emph>text()</emph>,
        <emph>comment()</emph> and <emph>programming-instruction()</emph>. Are there equivalent ways to name
        element and attribute nodes?</p>

      <p>Indeed there are, and as in other languages we call them <emph>wildcards</emph>. For our purposes, we
        will consider wildcards as part of the data model.</p>

      <p> Just to keep things interesting, wildcards don't all take the form of <emph>node-type()</emph>. The
        following table shows all the XPath wildcards. For completeness, this table includes some wildcards
        we've already covered, because they tend to get used in similar ways. </p>

      <table style="hlines">
        <title>Wildcards for Nodes</title>
        <colspec col="1" width="18%"/>
        <colspec col="2" width="20%"/>
        <thead>
          <col align="left">Wildcard</col>
          <col align="left">Represents...</col>
          <col align="left">Selects...</col>
        </thead>
        <row>
          <col>*</col>
          <col>Elements</col>
          <col><p>All elements within scope of the specified axis. For example, <emph>*</emph> selects all the
            child elements in the current context. Note that it does not select the attributes of those
            elements, and it does not select the text of those elements. (But watch out for the built-in
            template rule for text!) </p></col>
        </row>
        <row>
          <col>@*</col>
          <col>Attributes</col>
          <col><p>All the attributes of the current context. The context has to be an element for this to
            select anything, since only elements have attributes.</p>
            <!-- save for later  <p>This
            could be combined with the wildcard for elements to select all of the attributes in a document.
            Remembering the shortcut for all the descendants of the document root (//), you would just do
            this: <emph>//*/@*</emph>. Likewise, for to get all the attributes for all of a single element
            type in a document, you would do: <emph>//element-name/@*</emph>. </p> -->
          </col>
        </row>
        <row>
          <col>node()</col>
          <col>Nodes</col>
          <col><p>All the nodes in the current context. This includes elements, attributes, text, and the
            others. This wildcard gets used a lot when you want everything in all or part of the source
            document.</p></col>
        </row>
        <row>
          <col>text()</col>
          <col>Text</col>
          <col> <p>Text nodes in the current context. Note that attributes, comments, and processing
            instructions do not contain text nodes, they only contain string values. Elements are the only
            nodes that contain text nodes.</p> </col>
        </row>
        <row>
          <col>comment()</col>
          <col>Comments</col>
          <col><p>All comments in the current context.</p></col>
        </row>
        <row>
          <col>processing-instruction()</col>
          <col>Processing Instructions</col>
          <col><p>All processing instructions in the current context.</p></col>
        </row>
      </table>

      <p>With the use of wildcards and general expressions, we now have another tool to be more expressive
        about describing which parts of the XML document we want to select. Of course, with great power comes
        great...complexity, right? Stick around, it's only going to get more interesting when we add location
        paths!</p>
    </sect2>
  </sect1>

  <sect1 id="sect1.location-paths">
    <title>Location Paths</title>
    <p><emph>Location Paths</emph> tell the XSLT processor where to look in the data nodel and what kinds of
      nodes to look for in that location. Location paths can be defined by three subcomponents,
      <emph>axes</emph>, <emph>node tests</emph>, and <emph>predicates</emph> which we briefly introduced
      earlier. </p>

    <p>Before we jump in, though, let's first look at a full-blown location path so we have a clue what we're
      talking about when we discuss the parts. Here, for instance, is a location path that tells the XSLT
      processor to look for <xmltag>p</xmltag> tags at any level below the current context, and with <xmlattr value="10pt">font-size</xmlattr>: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline>descendant::p[@font-size = '10pt']</codeline>
</processedcode>
<?location xpath-order.pml@346 ?>


    <p>The <emph>descendant::</emph> part is the axis, which in this case says to look at any level inside the
      current context. The <emph>p</emph> part is the node test---it just says to look for a
      <xmltag>p</xmltag>. And the part in square brackets is the predicate. In this case the predicate
      contains an expression that narrows down what sort of <xmltag>p</xmltag> tag we're looking for. You
      could imagine using this XPath statement in a <xmlattr>select</xmlattr> attribute for
      <xmltag>xsl:apply-templates</xmltag>.</p>

    <p>Now that we've got something concrete to go on, let's see what sorts of choices we have for each part
      of the location path.</p>


    <sect2 id="sect2.axes">
      <title>The Thirteen Axes</title>
      <p>An axis specifies a direction in the XML tree and the scope of that direction.</p>

      <p>In XPath, there are really only two directions: before the current context and after the current
        context. There are thirteen variations on those two directions because we also want to define the
        scope of what we're interested in in either direction.</p>


      <p> In the following sections we're going to describe each axis and which nodes it selects in an XML
        tree, starting from a given current context. <ref linkend="fig.xml-tree-with-axes" thispage="yes"/>
        presents the XML tree as an arrangement of nodes, numbered in document order.
        <!--  For the examples, the current context
        node will be shown in black, and the nodes that are in the scope of the axis will be shown in gray.  --></p>
      <figure id="fig.xml-tree-with-axes" place="top">
        <title>An XML Tree</title>
        <imagedata fileref="images/xpath-order/axis-tree-current-context.pdf" width="35%"/>
      </figure>

      <p>Here, then, are the thirteen axes of XPath, with examples of their scope:</p>

      <dl style="bold">
        <dt newline="yes">ancestor</dt>
        <dd>
          <p>The direction of <string>ancestor</string> is before the current node, and the scope is all of
            the ancestors of the current node.</p>
          <p>In the example figure, if node 13 is the current node, <string>ancestor</string> selects nodes
            12, 10, and the root element (1). If the root element is the current node, nothing is
            selected.</p>
        </dd>

        <dt newline="yes">ancestor-or-self</dt>
        <dd>
          <p>The direction of <string>ancestor-or-self</string> is before the current node, and the scope is
            all of the ancestors of the current node <emph>plus</emph> the current node.</p>
          <p>In the example figure, if node 13 is the current node, <string>ancestor-or-self</string> selects
            nodes 13, 12, 10, and 1. If the root element is the current node, the root element is
            selected.</p>
        </dd>

        <dt newline="yes">attibute</dt>
        <dd>
          <p>The direction of <string>attribute</string> is after the current node, and the scope is all of
            the attributes that belong to the current node.</p>
          <p>In the example figure, if node 2 is the current node, <string>attribute</string> selects all the
            attributes of node 2. If the element has no attributes, nothing is selected.</p>
        </dd>

        <dt newline="yes">child</dt>
        <dd>
          <p>The direction of <string>child</string> is after the current node, and the scope is only the
            immediate children of the current node. In the example figure:</p>
          <ul style="compact">
            <li>
              <p>If node 2 is the current node, nodes 3, 4, and 5 are selected.</p>
            </li>
            <li>
              <p>If node 8 is the current node, nothing is selected.</p>
            </li>
          </ul>
        </dd>

        <dt newline="yes">descendant</dt>
        <dd>
          <p>The direction of <string>descendant</string> is after the current node, and the scope is all of
            the descendants of the current node. In the example figure:</p>

          <ul style="compact">
            <li>
              <p>If the root element is the current node, nodes 2 through 21 are selected.</p>
            </li>
            <li>
              <p>If node 10 is the current node, nodes 11 through 15 are selected.</p>
            </li>
            <li>
              <p>If node 14 is the current node, nothing is selected.</p>
            </li>
          </ul>
        </dd>

        <dt newline="yes">descendant-or-self</dt>
        <dd>
          <p>The direction of <string>descendant-or-self</string> is after the current node, and the scope is
            all of the descendants of the current node <emph>plus</emph> the current node.</p>
          <p>In the example figure, if node 10 is the current node, nodes 10, 11, 12, 13, 14, and 15 are
            selected. If node 5 is the current node, nodes 5, 6, 7, 8, and 9 are selected.</p>
        </dd>

        <dt newline="yes">following</dt>
        <dd>
          <p>The direction of <string>following</string> is after the complete context of the current node
            (that is, after the closing tag of the current node), and the scope is all of the nodes with a
            higher number in the document order.</p>
          <p>In the example figure:</p>
          <ul style="compact">
            <li>
              <p>If node 12 is selected, nodes 15 through 21 are selected. </p>
            </li>
            <li>
              <p>If node 16 is selected, nodes 19 through 21 are selected. </p>
            </li>
            <li>
              <p>If node 17 is the current node, nodes 18 through 21 are selected.</p>
            </li>
            <li>
              <p>If node 19 is the current node, nothing is selected.</p>
            </li>
            <li>
              <p>If node 20 is the current node, node 21 is selected.</p>
            </li>
          </ul>
        </dd>

        <dt newline="yes">following-sibling</dt>
        <dd>
          <p>The direction of <string>following-sibling</string> is after the current node, and the scope is
            all of the nodes that have the same parent as the current node. In the example figure, if node 3
            is the current node, nodes 4 and 5 are selected.</p>
        </dd>

        <dt newline="yes">namespace</dt>
        <dd>
          <p>The direction of <string>namespace</string> is after the current node, and the scope is the
            current node. In the example, if the current node is 10, the selected node is the namespace (or
            namespaces) of 10.</p>
        </dd>

        <dt newline="yes">parent</dt>
        <dd>
          <p>The direction of <string>parent</string> is before the current node, and the scope is the only
            the element containing the current node. Only elements can be parents. In the example, if the
            current node is 16, the selected node is 1.</p>
        </dd>

        <dt newline="yes">preceding</dt>
        <dd>
          <p>The direction of <string>preceding</string> is before the current node, and the scope is all
            nodes with a smaller number in the document order except for ancestors of the current node,
            attibute nodes, and namespace nodes. </p>
        </dd>

        <dt newline="yes">preceding-sibling</dt>
        <dd>
          <p>The direction of <string>preceding-sibling</string> is before the current node, and the scope is
            all nodes that have the same parent as the current node.</p>
        </dd>

        <dt newline="yes">self</dt>
        <dd>
          <p>The direction of <string>self</string> is after the current node, and the scope is only the
            current node.</p>
        </dd>
      </dl>
      <sect3>
        <title>Axis Shortcuts</title>
        <p>Some of the axes have shortcuts, which you will find convenient as long as you remember what they
          are shortcuts for! These shortcuts can be used in most of the places where the full axis name can be
          used. Following is a list of axis shortcuts:</p>

        <table style="hlines">
          <colspec col="1" width="20%"/>
          <colspec col="2" width="15%"/>
          <thead>
            <col align="left">Axis</col>
            <col align="left">Shortcut</col>
            <col align="left">Description</col>
          </thead>
          <row>
            <col>self</col>
            <col>.</col>
            <col><p>represents the <string>self</string> axis; it select the current node</p> </col>
          </row>

          <row>
            <col>parent</col>
            <col>..</col>
            <col> <p>represents the parent of the current node</p> </col>
          </row>
          <row>
            <col>child</col>
            <col><p>​</p></col>
            <col> <p>child:: can be omitted from a location path. The XSLT processor assumes that the given
              node test represents a child (or attribute or namespace) of the current node.</p> <p>For
              example, when we use <xmltag attrs="select=&quot;p&quot;">xsl:apply-templates</xmltag>, the
              contents of the <xmlattr>select</xmlattr> attribute are equivalent to <string>child::p</string>.
              So we've already been using this shortcut quite a bit. </p> </col>
          </row>


          <row>
            <col><p>root/<if-inline target="pdf">​</if-inline>descendant</p></col>
            <col>//</col>
            <col><p>represents everything within the document root. When a node test follows this (for
              example, //author), it selects all the nodes in the current document that match the node
              test.</p> <p>If a node precedes it (for example, chapter//, it selects everything beneath the
              given node, assuming that the given node is in the context of the current node. In this example,
              if the current node is a <xmltag>part</xmltag> tag, where <xmltag>chapter</xmltag> is an
              immediate child element, we could use chapter//note to select all the <xmltag>note</xmltag>
              elements inside all the child chapters. </p> </col>
          </row>
        </table>

        <p>Later we'll also see abbreviations (or <emph>wildcards</emph>) for nodes and attributes.</p>

      </sect3>

    </sect2>

    <sect2 id="sect2.nodetests">
      <title>Node Tests</title>
      <p>Now that we have the left side of our path set up, we can pay attention to <emph>node tests</emph>.
        By a node test, we mean that we describe a node or set of nodes; any node that matches our node test
        from the current context evaluates to true and therefore gets selected.</p>


      <p> We talked about how nodes were named in the section on the data model (<ref linkend="sect1.data.model"/>). Those names or naming conventions are used as node tests, along slashes
        to extend the paths, and wild cards. That's it---no big deal about it. Let's look at a few examples of
        node tests combined with the axes to see how they work.</p>

      <p>First, let's have a look at the XML we want to run tests on. This is a variation of the example with
        node numbers that we used before, but this time we're including attributes, processing instructions,
        and comments as well as elements and text:</p>

      <figure id="code.xml.node.tests">
        <title>Example XML for demonstrating node tests</title>
<processedcode id="code.node.tests" language="xml" showname="xpath-order/nodetests-1.xml" style="normal" url="xpath-order/nodetests-1.xml">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="nodetests-1.xsl"?&gt;</codeline>
<codeline><cokw>&lt;doc</cokw> id=<costring>"doc-1"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;chapter</cokw> id=<costring>"chapter-1"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-1"</costring><cokw>&gt;</cokw>one<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-2"</costring><cokw>&gt;</cokw>two<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-3"</costring><cokw>&gt;</cokw>three</codeline>
<codeline>      <cocomment>&lt;!-- This is an extraordinary comment! --&gt;</cocomment></codeline>
<codeline>      <cokw>&lt;footnote</cokw> id=<costring>"fn-1"</costring><cokw>&gt;</cokw>four<cokw>&lt;/footnote&gt;</cokw></codeline>
<codeline>      <cokw>&lt;footnote</cokw> id=<costring>"fn-2"</costring><cokw>&gt;</cokw>five</codeline>
<codeline>        <cokw>&lt;xref</cokw> id=<costring>"xref-1"</costring><cokw>&gt;</cokw>six<cokw>&lt;/xref&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xref</cokw> id=<costring>"xref-2"</costring><cokw>&gt;</cokw>seven<cokw>&lt;/xref&gt;</cokw></codeline>
<codeline>        <cokw>&lt;bold</cokw> id=<costring>"bold-1"</costring><cokw>&gt;</cokw>WOWSERS!<cokw>&lt;/bold&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/footnote&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline>  <cokw>&lt;chapter</cokw> id=<costring>"chapter-2"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cocomment>&lt;?php echo $fox; ?&gt;</cocomment></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-4"</costring><cokw>&gt;</cokw>eight<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-5"</costring><cokw>&gt;</cokw>nine</codeline>
<codeline>      <cokw>&lt;footnote</cokw> id=<costring>"fn-3"</costring><cokw>&gt;</cokw>ten<cokw>&lt;/footnote&gt;</cokw></codeline>
<codeline>      <cokw>&lt;bold</cokw> id=<costring>"bold-2"</costring><cokw>&gt;</cokw>OH, GOOD GRIEF!<cokw>&lt;/bold&gt;</cokw></codeline>
<codeline>     <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;note</cokw> id=<costring>"note-1"</costring><cokw>&gt;</cokw>eleven</codeline>
<codeline>      <cokw>&lt;p</cokw> id=<costring>"para-6"</costring><cokw>&gt;</cokw>twelve</codeline>
<codeline>         <cokw>&lt;footnote</cokw> id=<costring>"fn-4"</costring><cokw>&gt;</cokw>thirteen<cokw>&lt;/footnote&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/note&gt;</cokw></codeline>
<codeline>    <cokw>&lt;p</cokw> id=<costring>"para-7"</costring><cokw>&gt;</cokw>fourteen<cokw>&lt;/p&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline><cokw>&lt;/doc&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@585 ?>

      </figure>

      <p><ref linkend="table.node-tests"/> shows some of the kinds of things we can select with node
        tests:</p>

      <missing>The examples in this table need work.</missing>
      <table id="table.node-tests" style="hlines">
        <title>Selection with Axes and Node Tests</title>
        <colspec col="1" width="25%"/>
        <colspec col="2" width="25%"/>
        <thead>
          <col align="left">Current Context</col>
          <col align="left">Location Path</col>
          <col align="left">...Selects...</col>
        </thead>
        <row>
          <col><p><xmltag>footnote</xmltag></p></col>
          <col><p>ancestor::chapter</p></col>
          <col><p>Only the chapter element in which the footnote appears.</p></col>
        </row>
        <row>
          <col><p><xmltag attrs="id=&quot;chap-1&quot;">chapter</xmltag></p></col>
          <col><p>descendant::footnote</p></col>
          <col><p><xmltag>footnote</xmltag> elements where <xmlattr value="fn-1">id</xmlattr> and <xmlattr value="fn-2">id</xmlattr></p></col>
        </row>
        <row>
          <col><p>doc</p></col>
          <col><p>descendant::@id</p></col>
          <col><p>chap-1para-1para-2para-3fn-1fn-2xref-1xref-2chap-2para-4para-5fn-3fn-4para-6</p> <p>Note
            that without any way to restrict which <xmlattr>id</xmlattr> we're after, we get all
            <xmlattr>id</xmlattr> attributes that are descendants of <xmltag>doc</xmltag>.</p> </col>
        </row>
        <row>
          <col><p><xmltag attrs="id=&quot;chap-1&quot;">chap</xmltag></p></col>
          <col><p>descendant::comment()</p></col>
          <col><p>This is an extraordinary comment!</p></col>
        </row>
        <row>
          <col><p><xmltag attrs="id=&quot;fn-3&quot;">footnote</xmltag></p></col>
          <col><p>ancestor::chapter/@id</p></col>
          <col><p><xmltag>chapter</xmltag> where <xmlattr value="chap-2">id</xmlattr></p></col>
        </row>
        <row>
          <col><p><xmltag attrs="id=&quot;fn-1&quot;">footnote</xmltag></p></col>
          <col><p>following-sibling::bold</p></col>
          <col><p><xmltag>bold</xmltag> where <xmlattr value="bold-1">id</xmlattr></p></col>
        </row>
      </table>



      <sect3>
        <title>Extended Node Paths</title>
        <p>In some cases, a single node name is not enough. Let's say we're in a chapter and we want to select
          the footnotes that are inside <xmltag>note</xmltag> elements. One way to do that would be: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline>descendant::note/p/footnote</codeline>
</processedcode>
<?location xpath-order.pml@645 ?>


        <p>Slashes are separators that work just like they do in a file path, leading us from one element to
          its next relative. Remember, if you just give an element name, the assumption is that the element is
          a child of the current context. So the expanded version of the node path given above would be:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline>descendant::note/child::p/child::footnote</codeline>
</processedcode>
<?location xpath-order.pml@653 ?>


        <p>What this suggests is that you could put some different axis in front of each node in the path,
          providing it made sense in the context of the previous node in the path. With that idea, we're now
          really getting somewhere. The idea that we can specify a new axis <emph>at any point in the
          path</emph> gives us the possibility of navigating from one node in the XML to any other node,
          anywhere. This is where the real power of XPath begins to show itself.</p>

        <p>Suppose the current context is <xmltag>bold</xmltag> where <xmlattr value="bold-2">id</xmlattr> and
          we want to know what the <xmlattr>id</xmlattr> attribute is for the <xmltag>bold</xmltag> in the
          previous chapter. We're going to have to do something fancy to get there:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline>ancestor::chapter/preceding-sibling::chapter/descendant::bold/@id</codeline>
</processedcode>
<?location xpath-order.pml@667 ?>


        <p>Take a look back at <ref linkend="code.node.tests"/> and follow the thread of what is happening in
          this statement. From <xmltag attrs="id=&quot;bold-2&quot;">bold</xmltag>, the
          <ic>ancestor::chapter</ic> takes us up to <xmltag attrs="&quot;chap-2&quot;">chapter</xmltag>. Then
          <ic>preceding-sibling::chapter</ic> moves the context to <xmltag attrs="&quot;chap-1&quot;">chapter</xmltag>, and from there, the <ic>descendant::bold</ic> takes us to the only
          <xmltag>bold</xmltag> element in the first chapter. Then we get that last <ic>@id</ic>, which
          finally selects the <xmlattr>id</xmlattr> attribute of the <xmltag>bold</xmltag> tag. </p>

        <p>Essentially, the use of the location path in an extended fashion means we can navigate to any node
          or set of nodes in the document, then take a step in any of the thirteen axis directions to select
          any other set of nodes. That's pretty powerful stuff!</p>
      </sect3>

      <sect3>
        <title>Selecting Multiple Node Paths</title>
        <p>Sometimes you'll need to select more than one set of nodes, and it would make life a lot easier if
          you could do it in a single selection statement. That's easy enough---you just use a <emph>logical
          OR</emph> or a <emph>logical AND</emph> between the path statements. For example, let's say that the
          chapter element has three possible child types (<emph>p</emph>, <emph>note</emph>, and
          <emph>figure</emph>), and you only want to select the text of two of them (<emph>note</emph> and
          <emph>figure</emph>). You would place both paths in the select statement, separated by a pipe (|)
          character. The match or select statement would look like this:</p>

        <p><xmltag attrs="select=&quot;note/text() | figure/text()&quot;">xsl:apply-templates</xmltag></p>

        <p>As we'll learn in the section on expressions (<ref linkend="sect1.functions"/>), the pipe character
          represents a logical OR. You can put location paths together in other sorts of logical relationships
          using XPath expressions as well, and sometimes these can become quite long and complex. For
          readability, it's useful to break the expression just before each pipe, as shown in the following
          example that matches all three of the elements in <xmltag>chapter</xmltag>: </p>

<processedcode showname="no" style="normal">
<codeline>&lt;xsl:template match="p/text()</codeline>
<codeline>   | note/text()</codeline>
<codeline>   | figure/text()"</codeline>
</processedcode>
<?location xpath-order.pml@706 ?>


        <p>The spaces on either side of the pipe character aren't required, but they make for more readable
          code.</p>
      </sect3>
    </sect2>

    <sect2 id="sect2.predicates">
      <title>Predicates</title>
      <p>We defined predicates earlier, but let's get a little more formal: </p>

      <ul>
        <li>
          <p>Predicates appear in square brackets ([]) after the axis and node test.</p>
        </li>
        <li>
          <p>The brackets contain expressions that resolve to a boolean (true or false); or, if the predicate
            contains only a number, the number represents a position.</p>
        </li>
        <li>
          <p>The XSLT processor finds nodes that are in the scope of the axis and node test and evaluates them
            against the expression in the predicate. If a node evaluates to true, or it matches the position
            given by a number, the node is returned in the resulting node set.</p>
        </li>
      </ul>

      <p>Again referring to our bibliography XML example, suppose we wanted to show only the first author
        listed for a book. If our current context is <xmltag>book</xmltag>, we can say we want
        <string>child::author[1]</string>. Here, the predicate [1] contains the expression <emph>1</emph>,
        which in this case means "the first instance of the node of which I am a predicate." The
        <emph>child::author</emph> part of the path brings all of the <xmltag>author</xmltag> tags into scope;
        the XSLT processor evaluates each child <xmltag>author</xmltag> tag against the predicate expression
        and returns the one instance that evaluates to <emph>true</emph>: the first one. </p>

      <p>Predicates can contain much more complex expressions than just numbers. We haven't covered
        expressions yet, but it wouldn't hurt to get a taste for what predicates can do. Following is a table
        that shows some of the types of expressions you'll find in a predicate.</p>

      <dl style="bold">
        <dt newline="yes"><ic>ancestor::ul[1]</ic></dt>
        <dd>
          <p>A number in a predicate specifies an ordinal value; that is, it specifies which instance to
            return from an ordered set of nodes, where the node set is defined by the location path that
            precedes it. In this case, the node set is all <xmltag>ul</xmltag> elements, and the instance to
            return is the first.</p>
          <p>Higher numbers select nodes that are further from the current context. We talked about which
            direction in the tree each axis selects in <ref linkend="sect2.axes"/>. If the axis selects before
            the node, the predicate is evaluated from the current context backward in the document order, and
            if the axis selects after the node, the predicate is evaluated from the current context forward.
            So in this example, since ancestor:: selects backward, if we were at the bottom of a nested set of
            <xmltag>ul</xmltag> lists, the predicate would select the ancestor <xmltag>ul</xmltag> closest to
            the current context.</p>
        </dd>

        <dt newline="yes"><ic>descendant::*[footnote]</ic></dt>
        <dd>
          <p>This selects any element that is a descendant of the current context and the contains a child
            <xmltag>footnote</xmltag>.</p>

          <p>Do you see why this is this different from saying <ic>descendant::footnote</ic>? The * wildcard
            is the node test---it selects any element. The predicate says <ic>[footnote]</ic>, but remember:
            if there is no preceding axis for an element, the default axis is <ic>child::</ic>. So what the
            above XPath statement says is really: </p>
<processedcode language="text" showname="no" style="normal">
<codeline>descendant::*[child::footnote]</codeline>
</processedcode>
<?location xpath-order.pml@771 ?>

        </dd>

        <dt newline="yes"><ic>//xref/text()[contains(.,'figure')]</ic></dt>
        <dd>
          <p>The expression in the predicate means "the context contains the text "figure". In this case, the
            context is represented by the . ("self"), which is the node defined by the location path. So this
            predicate returns all the <xmltag>xref</xmltag> tags in the whole document whose text contains the
            string "figure".</p>
        </dd>

        <dt newline="yes"><ic>following-sibling::*[self::p | self::note]</ic> </dt>
        <dd>
          <p>This selects any following sibling that is either a <xmltag>p</xmltag> or a
            <xmltag>note</xmltag>.<author>need to test this one</author></p>
        </dd>

        <dt newline="yes"><ic>following::*[@*]</ic></dt>
        <dd>
          <p>This selects any following element that contains any attribute. Note that it doesn't select the
            attribute itself, only the element.</p>
        </dd>

        <dt newline="yes"><ic>ancestor::*[ancestor::*]</ic></dt>
        <dd>
          <p>This selects any ancestor that has an ancestor. In other words, it selects all ancestor elements
            fromn the current context except the root element.</p>
        </dd>

        <dt newline="yes"><ic>descendant::*[@id = 'ab1429z07']</ic></dt>
        <dd>
          <p>This selects a descendant with <xmlattr value="ab1429z07">id</xmlattr>.</p>
        </dd>
      </dl>

      <p>A great way to get comfortable with the combination of axes, node tests, and predicates is to play
        with them. Try it yourself: use a stylesheet that consists of an identity transform plus one other
        template. (You remember <ref linkend="chap.identity"/>, right?) In the second template, match on an
        element of interest, then use an <xmltag>xsl:value-of</xmltag> with an XPath statement to retrieve
        values from elsewhere in the XML document. You might even add some text around the
        <xmltag>xsl:value-of</xmltag> tag to set off the results from the rest of the document. At this point
        I don't think we even need an example---I'm going to trust you on this one.</p>

      <sect3>
        <title>Multiple Predicates</title>

        <p>A location path can have more than one predicate. You might need to combine several criteria for
          selecting nodes out of the scope of the node-set. We used the example earlier of wanting a Thai
          restaurant with highly rated bathrooms---but preferably the closest one! If our XPath statement
          selects all restaurants, and restaurants have attributes like cuisine and number of stars for
          restrooms, the location path might look like: <ic>restaurant[@cuisine='Thai' and @restroomstars &gt;
          4][1]</ic>.</p>

        <p>The trick here is that the first predicate filters the node set, then the second predicate is
          applied to the filtered node set. In this example, the set of restaurants is restricted to Thai
          restaurants with highly rated restrooms, then the second predicate picks the first one of those. </p>

        <p>If we did it the other way around, it might not work out so well. Check it out:
          <emph>restaurant[1][@cuisine='Thai' and @restroomstars &gt; 4]</emph>. Here we're saying, give us the
          first restaurant we find, then select it if it's a Thai restaurant with a great restroom. Chances
          are, if we're on a highway, the first restaurant will be a McDonald's or a Waffle House, and we
          won't return anything from the second predicate. Keep driving, and good luck!</p>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="chap.xpath.sect1.functions">
    <title>Functions</title>
    <p>We've talked around functions a little in earlier chapters, but now it's time to pin them down.</p>

    <p>So far, we know that they are language tokens that return values, and we know that they take the form
      <ic>function-name()</ic>, where the parentheses may or may not contain arguments. Functions are
      frequently used in XPath statements, but they can also be used in other parts of XSLT. (We'll see more
      of this when we get to <ref linkend="chap.values"/>.) Functions are often used in expressions to give
      values for comparison and testing, as well as in variables for calculation, decision-making, and output. </p>
    <p> What sort of values can we get out of functions? Here's the list: </p>
    <ul style="compact">
      <li>
        <p>Boolean values (true or false)</p>
      </li>
      <li>
        <p>Numbers</p>
      </li>
      <li>
        <p>Strings</p>
      </li>
      <li>
        <p>Node sets</p>
      </li>
    </ul>
    <p>In the following sections, we'll have a look at a couple of functions to get a feel for how they work,
      then spend some time on how to deal with the parameters. The last section will be a quick list of the
      functions organized by the kinds of values they return. Then I'm going to do a total cop-out and refer
      you to <ref linkend="app.functions"/> and some other resources online for more information about using
      functions. Sorry about that---space in this book is a little limited, and I'm sure your patience is as
      well! </p>

    <sect2>
      <title>Functions at Work</title>

      <p>Let's have a look at a function that takes three parameters and returns a string value:
        <ic>substring()</ic>. This is one of the most flexible of the string functions, so it gets a lot of
        exercise. Basically, you specify a string to work with and give the positions of the first and last
        letter of the part of the substring you want to return from the string. </p>

      <p>In the example below, we're going to take the first 45 characters of a string to use as the teaser
        for a news article. Hopefully the writer knows how to make a punchy lead-in sentence! This sort of
        string would typically be linked to the full article elsewhere. We won't create the link in this
        example, but we will see how to create the teaser string.</p>

      <p>Here's the first paragraph of the content for the article itself:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;p&gt;</cokw>NASA revealed that aliens invaded Anchorage, Alaska</codeline>
<codeline>  during the last major snowstorm. Apparently no one noticed</codeline>
<codeline>  because their spacesuits looked like snow gear. <cokw>&lt;/p&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@888 ?>


      <p>Let's take a look at the template we would use for showing only the first 45 characters:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline prefix="Line 1"><cokw>&lt;xsl:template</cokw> match=<costring>"p"</costring><cokw>&gt;</cokw></codeline>
<codeline id="code.substring.function" lineno="2" prefix="2">  <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring(.,1,45)"</costring><cokw>/&gt;</cokw><cokw>&lt;xsl:text&gt;</cokw>...<cokw>&lt;/xsl:text&gt;</cokw>  </codeline>
<codeline prefix="3"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@896 ?>


      <p>Looking more closely at line <cref linkend="code.substring.function"/>, check out how we specified
        the first parameter: it's just the period (.). As we learned earlier, the period is XPath shorthand
        for the current context. In this case, the period returns the text of the current context, which is
        the whole paragraph string that we want to operate on.</p>
      <p>Following the . is a comma to separate the parameters, then a 1 for the second parameter, which tells
        the function where to start the substring. The convention for string positions in XPath is that the
        first character position is numbered 1, the second 2, and so forth. So we're telling the function to
        start the substring with the first character. </p>
      <p>The second comma sets off the third parameter, which tells the function which character position will
        be the last in the substring. We want 45 characters, so we specify 45 for this parameter. The result
        is a tittilating lead-in for our article:</p>

<processedcode language="text" showname="no" style="normal">
<codeline>NASA revealed that aliens invaded Anchorage...</codeline>
</processedcode>
<?location xpath-order.pml@912 ?>


      <p>As a general pattern for the use of functions, this example demonstrates several things. First, the
        function is used in the context of an attribute of an XSLT instruction. Functions always do their work
        within the attributes of XSLT instructions.</p>

      <p>Second, a function can be used to send its value to the output. This isn't always true, though---you
        can also used functions as parts of expressions to evaluate conditions and make decisions about
        processing. That is to say, the values can be used for internal processing purposes within the XSLT as
        well as for creating output. </p>

      <p>Third, parameters are always separated by commas. If you need to use a comma in a parameter, the
        parameter needs to be enclosed in single quotes (''). In our example, for instance, we could have just
        put a literal string (including a comma) in the function, with the string inside single quotes like
        so:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"p"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring('NASA revealed that aliens</costring></codeline>
<codeline>    <costring>invaded Anchorage, Alaska',1,45)"</costring><cokw>/&gt;</cokw><cokw>&lt;xsl:text&gt;</cokw>...<cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@933 ?>


      <p>Of course, using the . for the first parameter rather than all of that text would make this template
        more useful for situations other than when aliens invade Anchorage...</p>

      <p>One important point to note: parameters for <ic>substring()</ic> can be static values or can be
        variable values that are defined elsewhere. In this example we used static values for the second and
        third parameters because we haven't gotten to variables yet. But even that period in the first
        parameter represents a dynamic value: we have no idea what the actual string will be until runtime.
        And we can easily imagine wanting to change the size of the teaser based on the type of device the
        news is being delivered to. To do that, we would need to use a variable for the third parameter. We'll
        get a good look at creating that kind of control when we get to <ref linkend="chap.values"/>. </p>

      <p>While this section presents a general guideline to functions and their usage, it doesn't begin to
        touch all the functions and how they can be employed in XSLT. <ref linkend="app.functions"/> lists the
        functions available for XPath 1.0, and those will handle a lot of situations in XSLT. We'll see more
        uses for functions when we get into <ref linkend="sect1.xpath-expressions"/> and other parts of this
        book. We'll even see situations where we use functions within the parameters of other functions.</p>
      <p> As your use of XSLT matures, you will want to check out the functions available in later versions of XPath,<footnote>
        <p><url>http://www.w3.org/TR/xpath-functions/</url> and
          <url>http://www.w3.org/TR/xpath-functions-30/</url></p>
        </footnote> as well as in various XSLT extensions, such as EXSLT<footnote>
        <p><url>http://www.exslt.org/func/index.html</url></p>
        </footnote> and FunctX.<footnote>
        <p><url>http://www.xsltfunctions.com/</url></p>
        </footnote> For a list of the extended functions available in the Saxon XSLT processor, refer to
        Saxon's documentation.<footnote>
        <p><url>http://saxonica.com/documentation9.4-demo/html/extensions/</url></p>
        </footnote> If you are adept at other programming languages, you can even create your own extended functions!<footnote>
        <p><url>http://msdn.microsoft.com/en-us/magazine/cc302079.aspx</url></p>
        </footnote><footnote>
        <p><url>http://ode.apache.org/custom-xpath-functions.html</url></p>
        </footnote> Custom extended functions are well beyond the scope of this book, but keep in mind that
        this is one of those useful areas where the “X” (eXtensible) part of XSLT comes into play. </p>
      <sidebar>
        <title>XPath 1.0 functions are a meager offering...</title>
        <p>Let's face it: XSLT 1.0 and XPath 1.0 can seem like a starter set of building blocks when you're
          faced with creating industrial-strength output of any meaningful complexity. In those cases, it's
          best to stay away from the XSLT processors built into web browsers if you possibly can. Then you can
          take advantage of the legions of neat functions offered in XPath 2.0 and in various XSLT
          extensions.</p>

        <p>One of the more popular extension projects is EXSLT,<footnote>
          <p><url>http://exslt.org/</url></p>
          </footnote> a nonprofit community that provides a ton of useful functions for things like date and
          time handling, math functions, regular expressions, and extended string handling. But you'll find
          that there are numerous function libraries out there for a variety of programming languages and XSLT
          processors.</p>

        <p>As in everything else, though, these additional functions come with a caveat. Most XSLT processors
          don't support all of the EXSLT functions, although many processors support a good subset of them.
          You'll have to check the specifications for the XSLT processor you use, or you'll have to point the
          processor to other processing tools that can handle the extended functions.</p>

        <p>You can learn more about XSLT extensions in <ref linkend="app.extensions"/>, but I wanted to let
          you know up front that you aren't necessarily stuck with just the XPath 1.0 functions. I find that I
          can get by with XPath 1.0 functions for a very large percentage of the problems I've encountered.
          But there is no question that functions from XPath 2.0 or EXSLT extensions will bring a little
          sunshine into your XSLT programming life. </p>
      </sidebar>
    </sect2>
  </sect1>

  <sect1 id="sect1.xpath-expressions">
    <title>Expressions</title>

    <p>We've seen three aspects of XPath: the data model, location paths, and functions. In our fourth and
      final act, we'll look at expressions, which round out XPath into a fairly robust tool for handling XML. </p>

    <p>Plain and simple, the function of XPath expressions is to derive values that can be used for
      controlling our XSLT processor. The form of an expression can be something as simple as a single static
      value or as complex as a mathematical formula. Within XPath constructions, expressions frequently take
      the form of relationships that are evaluated as true or false. For example, you might see an expression
      in the predicate of a <xmlattr>select</xmlattr> attribute, like this: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:apply-templates</cokw> select=<costring>"following-sibling::phone-number[@type = 'home']"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@1010 ?>


    <p>Here we can imagine that our current context is an <xmltag>address</xmltag> tag that includes a lot of
      other tags like <xmltag>address-line-1</xmltag>, <xmltag>city</xmltag>, and several
      <xmltag>phone-number</xmltag> tags. If all we want is the home phone number, we set up the expression in
      the predicate (<ic>[@type = 'home']</ic>) to be true when the processor gets to the tag that looks
      something like <xmltag attrs="type=“home”">phone-number</xmltag>. When that expression is
      true, the <xmltag>xsl:apply-templates</xmltag> goes to work. For <xmltag>phone-number</xmltag> tags with
      other values for <xmlattr>type</xmlattr>, the processor just says “meh” and keeps working. </p>

    <p> In the following sections we'll take a look at some fundamental characteristics of expressions: how
      they are constructed, what language elements can be used in them, how they are evaluated, and some
      typical use cases. By the end of this chapter you should understand the basic structure and use of XPath
      expressions. And in subsequent chapters we'll see expressions put through their paces to solve a variety
      of problems. </p>

    <sect2>
      <title>The Structure of Expressions</title>

      <p>As mentioned earlier, expressions can be very simple, or they can be fairly complicated. Here's a
        <xmlattr>select</xmlattr> attribute with a one-character expression, the 1 inside the square brackets
        ([]):</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:apply-templates</cokw> select=<costring>"following-sibling::phone-number[1]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@1035 ?>


      <p>The expression evaluates to true when the processor reaches the first instance of the
        <xmltag>phone-number</xmltag> tag in the current context. In this case, the 1 is really a short-hand
        form for an expression that goes more like <ic>position() = 1</ic>, but it still qualifies as an
        expression. </p>

      <p>An expression can consist of one on more parts. An expression does not necessarily consist of a
        relationship; it can be a simple static value, a variable, a function, or a combination of tokens, and
        it may include <firstuse>operators</firstuse>. Operators are special characters that modify or create
        relationships between things in an expression. </p>

      <p> The expression <ic>position() = 1</ic> is a relationship. It consists of the <ic>position()</ic>
        function, which produces different values based on the position of the specified element within its
        current context, and a static value, 1. The = sign is an instance of operator. There are a bunch of
        operators that can be used in expression. We'll be get to those shortly.</p>

      <p>Using operators, you can construct fairly sophisticated expressions to evaluate for an endless
        variety of conditions. For example:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[count(preceding-sibling::p) </costring>&amp;gt;<costring>= 1]</costring></codeline>
<codeline>  <costring>[not(preceding-sibling::*[not(self::p or self::title or self::i)])]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location xpath-order.pml@1058 ?>


      <p> This little snarl of logical obscurity is intended to select for <xmltag>p</xmltag> tags that have
        the following characteristics: </p>

      <ul>
        <li>
          <p>The number of preceding <xmltag>p</xmltag> tags in the current context is greater than or equal
            to one. (That &amp;gt;= is a relationship operator meaning <emph>greater than or equal
            to</emph>.)</p>
        </li>
        <li>
          <p><emph>and</emph> it is not the case that any of those preceding sibling tags are anything other
            than <xmltag>p</xmltag> OR <xmltag>title</xmltag> OR <xmltag>i</xmltag>. In this part of the
            expression, the <emph>or</emph> tokens are logical operators that work just like they did in your
            old algebra courses. You remember those, don't you? </p>
        </li>
      </ul>

      <p>In general, expressions are formed by the arrangement of one or more things that represent values,
        possibly separated by different kinds of operators that establish relationships between the values.
        Structurally, it sounds fairly simple. In practice, though, we'll see that there are a number of
        things that represent values and a number of things that act as operators; between the values and the
        operators, expressions can be quite adaptable to almost any situation.</p>

      <p>So let's have a look at the sorts of things we can fit into the structure of an expression.</p>

    </sect2>

    <sect2 id="sect2.content.expressions">
      <title>The Contents of Expressions</title>

      <p>What sorts of things can expressions contain? We've seen static values, functions, and relational
        operators so far. Expressions turn out to be pretty flexible---all sorts of thing can go into them.
        The trick for contructing a useful expression is finding the appropriate kinds of things to put in it
        to get the value we need. We can't really go through all the possibilities in this short section, but
        we can at least take a look at what kinds of options are available for constructing expressions.</p>
      <p>Here's a list of XSLT constructions we might find in an expression: </p>

      <ul style="compact">
        <li>
          <p>Strings</p>
        </li>
        <li>
          <p>Numbers</p>
        </li>
        <li>
          <p>Nodes or node-sets</p>
        </li>
        <li>
          <p>XPath statements (location paths) that select nodes or node-sets</p>
        </li>
        <li>
          <p>Functions</p>
        </li>
        <li>
          <p>Variables and parameters</p>
        </li>
        <li>
          <p>Operators</p>
        </li>
      </ul>

      <p> We're familiar with most of these, although haven't looked at variables and parameters yet, but
        we'll get to them in <ref linkend="chap.values"/>. You can think of them as placeholders whose values
        are determined at runtime. </p>

      <p>In general, other than operators, all these items evaluate to the four basic value types in XSLT:
        numbers, strings, Boolean values, and nodes. </p>

      <p>Operators are another thing entirely. XPath operators consist of the following:</p>

      <table>
        <row>
          <col>or</col>
          <col><p>The Boolean <emph>or</emph> operator is used between tokens or expressions that evaluate to
            true or false. The expression is true if either side of the <emph>or</emph> is true.</p></col>
        </row>

        <row>
          <col>and</col>
          <col><p>The Boolean <emph>and</emph> operator is also used between tokens or expressions that
            evaluate to true or fales. The expression is true only if both sides of the <emph>and</emph> are
            true.</p></col>
        </row>
        <row>
          <col>=</col>
          <col><p>The equals sign is true only if both sides of the expression are equal. The values on either
            side can be numbers, strings, Boolean values, or node-sets. If you're comparing node-sets, just be
            aware that the evaluation is made based on the string values of the two node-sets. The way string
            values of node-sets are determined is a bit too complex for this book---you might (or might not!)
            want to have a look at the XPath specification<footnote>
            <p><url>http://www.w3.org/TR/xpath/#dt-string-value</url></p>
            </footnote> for the gory details.</p></col>
        </row>
        <row>
          <col>!=</col>
          <col><p>!= means “not equals”, and the expression evaluates to true only if one side is
            not equal to the other.</p></col>
        </row>
        <row>
          <col>&lt;=</col>
          <col><p>The less-than-or-equal operator yields true if the left side of the relationship is less
            than or equal to the right side. Remember to use &amp;lt; as the symbol for &lt; when you are
            inside an attribute, or Bad Things Will Happen.</p></col>
        </row>
        <row>
          <col>&lt;</col>
          <col><p>The less-than operator yields true only if the left side is smaller than the right side.
            Yes, you can compare strings and node-sets with this and the other equals, greater- and less-than
            operators, but again, check the rules for how strings and node-sets are evaluated. Thankfully,
            numbers, are what you'd expect. </p></col>
        </row>
        <row>
          <col>&gt;=</col>
          <col><p>The expression is true if the right side is larger than or equal to the left side. You don't
            need to make the &gt; symbol as &amp;gt;, but you can if you'd like.</p></col>
        </row>
        <row>
          <col>&gt;</col>
          <col><p>The expression is true only if the right side is larger than the left.</p></col>
        </row>
        <row>
          <col>+</col>
          <col><p>The plus sign performs arithmetic addition. Objects on either side of the expression are
            treated as numbers. If they don't start as numbers, they are converted to numbers. You can check
            the definition of the number() function (<ref linkend="app.functions"/>) to see how strings,
            node-sets, and Booleans are converted to numbers.</p></col>
        </row>
        <row>
          <col>-</col>
          <col><p>The minus sign performs arithmetic subtraction, and converts non-numeric objects to numbers
            the way the + sign does. Unless the values on either side are actually numbers, it's best to put a
            space on either side of the - sign, or it might wind up being mistaken for part of a
            string.</p></col>
        </row>

        <row>
          <col>div</col>
          <col><p>The <emph>div</emph> operator performs arithmetic division. The number on the left is
            divided by the number on the right.</p></col>
        </row>
        <row>
          <col>mod</col>
          <col><p>The <emph>mod</emph> (modulo) operator returns the remainder of the whole-number division of
            the left side by the right side. For example, <ic>5 mod 2</ic> divides 5 by 2 and returns a value
            of 1.</p></col>
        </row>
        <row>
          <col>*</col>
          <col><p>The asterisk performs multiplication between the two sides of an expression. Again,
            non-numeric values are converted to numbers. Be careful with the asterisk, though---when it comes
            without spaces immediately before or after a slash, after an @ sign, or by itself, it becomes a
            wildcard for representing node-sets. And it's always good to leave spaces between the values and
            the * to make it easier to read! </p></col>
        </row>
        <row>
          <col>/</col>
          <col><p>As we've seen, the slash (/) is used in XPath expressions to separate between XPath node
            levels. When used at as the first character in a node path, it means to begin at the root
            node.</p></col>
        </row>
        <row>
          <col>//</col>
          <col><p>The // essentially means the same thing as descendant-or-self. When used as the first
            character in a node path, it means to begin at the root node and find the descendant-or-self of
            whatever node path follows it. This is a good way to find all of a particular type of node or
            node-set in the whole document. As you might expect, it can also be expensive on processing
            time.</p></col>
        </row>
        <row>
          <col>.</col>
          <col><p>The . means the same as self:: in an XPath expression. </p></col>
        </row>
        <row>
          <col>..</col>
          <col><p>The double dot means the same as parent:: in an XPath expression.</p></col>
        </row>
        <row>
          <col>@</col>
          <col><p>The at symbol means the same thing as attribute:: in an XPath expression.</p></col>
        </row>
        <row>
          <col>[]</col>
          <col><p>The square brackets enclose the content of an XPath predicate.</p></col>
        </row>
        <row>
          <col>*</col>
          <col><p>The asterisk, when used in an XPath path, is a wildcard that represents element nodes. When
            used after the at symbol (@*), it's a wildcard for attribute nodes.</p></col>
        </row>
        <row>
          <col>$</col>
          <col><p>The dollar symbol is used to start the name of a variable or parameter that has been defined
            elsewhere.</p></col>
        </row>
      </table>
    </sect2>

    <sect2>
      <title>The Values of Expressions</title>
      <p> What kind of value will you get out of an expression? We've seen that expressions are used in the
        context of attributes, and different attributes require different types of values. In some cases you
        may need a simple Boolean value; in other cases, a variable that returns a complex string. Depending
        on how the expression is set up, you can derive these types of values: </p>

      <ul>
        <li>
          <p>Numbers</p>
        </li>
        <li>
          <p>Strings</p>
        </li>
        <li>
          <p>Booleans</p>
        </li>
        <li>
          <p>Nodes or node-sets</p>
        </li>
      </ul>
      
      <p>How do you know you're going to get the right sort of value out of an expression?  Look at the largest containing structure in
      the expression and determine what sort of value it returns.  For example, an expression with an = in the middle will return a Boolean value,
      regardless of what's on either side.  An expression that is couched in the parentheses of a function will return whatever type of value
      that function normally returns.  And an expression that starts with an XPath address will likely return a node or node-set.</p>
      
      <p>And if nothing else, you can always experiment!</p>
    </sect2>
    <!--  <p>Note that in we have to use the XML character entity for the left angle bracket (&amp;lt;) in the
      expression because the expression is in an attribute. Using the raw left angle bracket character (&lt;)
      by itself would break the code- - -it would appear that we are opening a new element within an attribute,
      which, of course, is bad manners in XML.</p> -->
  </sect1>
  <sect1>
    <title>What We Did</title>
    <p>Well, that was pretty much a whirlwind tour of XPath.  If you're feeling dizzy, exhausted, nervous, restless, 
    and not the least bit sleepy---it's probably all the caffeine it took to get through this chapter.</p>
    
    <p>In this chapter we covered all the elements and principles of XPath 1.0 -- no mean feat for twenty-some-odd pages.
    We saw that XPath is composed of four major functional areas: the data model, location paths, functions, and expressions.
    Location paths in turn are divided into three parts: axes, node tests, and predicates.  Node tests can contain wildcards,
    and predicates can contain functions, expressions, and more XPath statements.
    </p>
    <p>And then, of course, each of of those functional areas has its own list of things that can go into them. Yes, it makes for a long
    chapter.  And even more regrettably, we didn't get to see a lot of examples in the process.</p>
    <p>
       But not to worry. In the next chapter, and the rest of the book, we'll find that we will not stray far from the use of XPath statements.
       We'll see a lot of examples while we are demonstrating other aspects of XSLT. In fact, as you recall, we were in the middle of
    the problem of re-ordering XML elements when we suddenly went off on this extravagant diversion.  It's time to get back to the original
    problem now that we've taken XPath into our growing toolset.
    </p>
    
    <sidebar>
      <title>Is XPath Really Separate from XSLT?</title>
      <p>The relationship between XSLT and XPath is so tight,
       it makes you wonder why they are considered separate languages. The answer is that XPath can be used in other processing languages, so it
       was specified separately from XSLT.  However, it's extremely difficult if not impossible to use XSLT without using XPath---and 
       thus this overly long chapter.</p>
    </sidebar>

  </sect1>
  



</chapter>
<?location orderorder-2.pml@3 ?>

<chapter id="chap.order-order-2">
  <title>Using XPath to Change the Order of Documents</title>
  <epigraph>
    <name>Edgar Rice Burroughs, <bookname>A Princess of Mars</bookname></name>
    <epitext>
      <p/>
    </epitext>
  </epigraph>
 
  <sect1>
    <title>Putting XPath to Work</title>
    <p>Now we're going to apply XPath to solve the remainder of our problem with the Grizzly essay. And we'll
      do more than that in this chapter: we'll put XPath to work solving a variety of problems that require us
      to access content all over the place. We'll see a method call <firstuse>pull processing</firstuse>,
      which will run contrary to the normal functional model of XSLT, but which can prove useful on occasion;
      we'll see grouping and sorting; and we'll talk about other reasons to retrieve content or test the
      structure of nodes elsewhere in the document.</p>
  </sect1>
  <sect1>
    <title>Writing the List-Buster: Part 2</title>
    <p>At the end of <ref linkend="chap.orderorder"/> we wrote XSLT to handle the chapter heading and the
      chapter-level paragraph, but what about the next-level headings and their content?</p>

    <p>The next-level headings should all come after the chapter-level paragraph, so we can add an
      <xmltag>xsl:apply-templates</xmltag> statement in the chapter-level template to process those: </p>

<processedcode language="xml" showname="orderorder2/listfix.xsl" style="normal" url="orderorder2/listfix.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:template</cokw> match=<costring>"/document"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="2">  <cokw>&lt;chapter&gt;</cokw></codeline>
<codeline prefix="3">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='14pt']"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="4">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline prefix="5">      <costring>and not(preceding-sibling::p[@font-size='12pt'])]"</costring><cokw>/&gt;</cokw></codeline>
<codeline id="code.h1-selection" lineno="6" prefix="6">    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='12pt']"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="7">  <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline prefix="8"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@30 ?>


    <p> Line <cref linkend="code.h1-selection"/> selects the heading-level paragraphs. So, as we did with the
      chapter title, we need to create a template that processes the text of those paragraphs and puts them
      into the title tag. And we may as well wrap them in the <xmltag>h1</xmltag> tags while we're at it,
      because the <xmltag>title</xmltag> tags have to go inside the <xmltag>h1</xmltag> tags. (See <ref linkend="sidebar.well-formed"/> for why the beginning and end tags should both go inside the same
      template.) </p>

    <sidebar id="sidebar.well-formed">
      <title>Templates should emit well-formed output</title>

      <p>Isn't it possible to create an open <xmltag>h1</xmltag> in the template for the heading-level
        paragraphs, then the closing &lt;/h1&gt; in the template for the last paragraph in the section? </p>

      <p>Quick answer: no. XSLT is designed to emit well-formed XML.</p>

      <p>Slow answer: not really. You could probably bluff your way into it by using something like
        <ic>&amp;lt;h1&amp;gt;</ic> in the one template and <ic>&amp;lt;/h1&amp;gt;</ic> in the other
        template, and the character entities would get converted into angle brackets, creating tags in the
        output. But don't do it. The XSLT processor parses the XML output to make sure it is well-formed. To
        fool the processor, you would have to emit some output that looks like text (as I've shown here).
        There would be no way to guarantee that you're creating good XML. </p>

      <p> Because XSLT is designed to create well-formed output, it helps to think about structuring your
        templates so they create chunks of XML with beginning and end tags. Doing so leads to good stylesheet
        design and self-contained templates that can be easily reused. </p>

      <p>If you find that you're struggling to get the open and close tags in one template, you might need to
        reconsider your stylesheet design. </p>

      <p>Save yourself a lot of trouble and stick to the normal processing model. Create well-formed output in
        each template! </p>
    </sidebar>

    <p>Now we get to the tricky part. We need to insert the remaining text paragraphs within the <xmltag>h1
      tags</xmltag> we just created. To do this, we need the select the <xmltag>p</xmltag> tags that meet
      these conditions:</p>

    <ul>
      <li>
        <p>They follow the currently selected <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr>.</p>
      </li>
      <li>
        <p>They precede the next <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr>.</p>
      </li>
    </ul>

    <p>One way to express these conditions logically is that we want:</p>

    <ul>
      <li>
        <p><xmltag>p</xmltag> tags that follow the current <xmltag>p</xmltag> tag and that have <xmlattr value="10pt">font-size</xmlattr></p>
      </li>
      <li>
        <p>AND that don't follow any <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr>
          that follows the current <xmltag>p</xmltag> tag</p>
      </li>
    </ul>

    <p>How do we convert that logic into XSLT syntax? You can probably do the first logical part yourself at
      this point. What about the second part? We know we need a way to keep track of what the current
      <xmltag>p</xmltag> tag is. As the XSLT processor looks at each <xmltag>p</xmltag> tag for inclusion, we
      need a way to find out whether a preceding <xmltag>p</xmltag> tag with <xmlattr value="12pt">font-size</xmlattr> is the one we started with or one of the ones that follow what we started with. To
      do this, let's create a variable with the ID value of our initial <xmltag>p</xmltag> tag:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:variable</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"generate-id(.)"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:variable&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@105 ?>


    <p>Now we can create the XSLT that looks for the conditions we've described:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:variable</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;xsl:apply-templates</cokw> select=<costring>"following-sibling::p[@font-size = '10pt' and</costring></codeline>
<codeline>     <costring>preceding-sibling::p[@font-size = '12pt'][1][generate-id() = $id]]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@115 ?>


    <!-- Yeah, that's a little better - just need to test it! -->

    <p>Ouch! That's pretty hairy---take a minute to look through those lines. We've got some XPath in our back
      pocket now, so we should be able to figure it out. </p>

    <p>First, look at the big picture. We're selecting all the following-sibling <xmltag>p</xmltag> tags, but
      we've added a predicate to select only the tags we want. The predicate starts out like predicates we've
      seen before, just selecting for a font size equal to 10 points. But to that requirement we add another:
      the selected tag must also have a preceding sibling that is a <xmltag attrs="font-size=“12pt”">p</xmltag>. The <ic>[1]</ic> says that this has to be the first
      preceding sibling that meets the font size condition, and the <ic>[@id = $id]</ic> condition says that
      it must also have the same generated ID value as the one we generated for the <xmltag attrs="font-size=“12pt”">p</xmltag> that we matched on to begin with. If the processor gets
      to a <xmltag>p</xmltag> that follows the next <xmltag attrs="font-size=“12pt”">p</xmltag>,
      then <ic>preceding-sibling::p[@font-size = '12pt'][1]</ic> won't have the same ID value, and nothing
      will be returned. Sweet. </p>

    <p>Okay---with this great huge clunker of a select statement, we're almost home free. We just need to take
      the next step and add a template that matches the <xmltag attrs="font-size=“10pt”">p</xmltag> tags. Remember that the paragraph tag immediately after the chapter title also matches this
      description, so we'll have to add a little something in our select statement to make sure we omit that
      one. Can you figure it out?</p>

    <p>And then---success. We get a nicely restructured piece of XML. Sure, that was a lot of work for a
      little piece of XML, but what would you say to several hundred pages of XML in the same format?
      Personally, I'd be ecstatic to spend the time on this stylesheet. Beats restructuring it by hand (or
      with regular expressions or HTML filters) in a heartbeat!</p>

    <p>And here it is, the reward for all our hard work (and huge, hairy predicates!): the complete
      stylesheet:</p>

    <figure id="fig.listfix" place="top">
      <title>The Complete Listbuster Stylesheet</title>
<processedcode language="xml" showname="orderorder2/listfix2.xsl" style="normal" url="orderorder2/listfix2.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/document"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;chapter&gt;</cokw></codeline>
<codeline prefix="5">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='14pt']"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline prefix="-">        <costring>and not(preceding-sibling::p[@font-size='12pt'])]"</costring><cokw>/&gt;</cokw></codeline>
<codeline id="code.h1-selection2" lineno="8" prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"p[@font-size='12pt']"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;/chapter&gt;</cokw></codeline>
<codeline prefix="10">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='14pt']"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;title&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="15">      <cokw>&lt;/title&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline prefix="-">    <costring>and not(preceding-sibling::p[@font-size='12pt'])]"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="20">    <cokw>&lt;p&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/p&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="25">  <cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='12pt']"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:variable</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:value-of</cokw> select=<costring>"generate-id(.)"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;h1&gt;</cokw></codeline>
<codeline prefix="30">      <cokw>&lt;title&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/title&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"following-sibling::p[@font-size='10pt' and</costring></codeline>
<codeline prefix="-">        <costring>not(preceding-sibling::p[@font-size='12pt'</costring></codeline>
<codeline id="code.idEquals" lineno="35" prefix="35">        <costring>and preceding-sibling::p[generate-id() = $id]])]"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;/h1&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="-"> <cokw>&lt;xsl:template</cokw> match=<costring>"p[@font-size='10pt'</costring></codeline>
<codeline id="code.p10afterp12" lineno="40" prefix="40">   <costring>and preceding-sibling::p[@font-size='12pt']]"</costring><cokw>&gt;</cokw> </codeline>
<codeline prefix="-">   <cokw>&lt;p&gt;</cokw></codeline>
<codeline prefix="-">     <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">   <cokw>&lt;/p&gt;</cokw></codeline>
<codeline prefix="-"> <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="45"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@150 ?>

    </figure>

    <p>You can see in line <cref linkend="code.p10afterp12"/> how we crafted the match statement to avoid
      picking up that one paragraph immediately after the chapter title. The part of the expression after the
      <ic>and</ic> tells the processor that the seleced <xmltag>p</xmltag> tag must follow a <xmltag attrs="font-size=“12pt”">p</xmltag> tag. That condition eliminates the paragraph after the
      <xmltag attrs="font-size=“14pt”">p</xmltag> tag.</p>

    <p>Job well done! It was a long journey that started way back in <ref linkend="sect1.structuring-flat-lists"/> and took us through an entire chapter about XPath. We have used
      the attributes of a flat list of <xmltag>p</xmltag> tags to create an XML document with hierarchical
      structure that better represents the underlying structure of the content, which is just what we
      wanted.</p>

    <p>Now that we have XPath in our tool chest, though, we can begin to address problems that are
      considerably more complicated than anything we have seen yet. And, you know what? Given the XML that
      we'll find out there in the wild, we're going to need all the tricks we can find.</p>
  </sect1>

  <sect1>
    <title>What Else We'll Do in This Chapter</title>
    <p>Now that we've finished our complex restructuring job, let's take a look at some other ways we can use
      XSLT with XPath to restructure and re-order our content. We'll be using XPath in most of these
      approaches, but XPath won't be all. We're also going to have a look at some methods for grouping and
      sorting content---restructuring with a vengeance! </p>
    <p>Here's what we've got ahead in this chapter:</p>

    <ul>
      <li>
        <p>“Pull processing,” which involves cheating a little bit on XSLT's functional
          programming model</p>
      </li>
      <li>
        <p>Using XPath from any location to retrieve any other content in the document</p>
      </li>
      <li>
        <p>Grouping (by a couple of different methods)</p>
      </li>
      <li>
        <p>Sorting, which requires learning some new XSLT instructions</p>
      </li>
    </ul>

    <p>These techniques will give you enough power to address a large number of the XML restructuring problems
      we're likely to encounter. Of course, we haven't gotten to the use of conditional processing, which will
      help even further---but we'll first need to learn about variables and parameters (<ref linkend="chap.values"/>) before we can start working with conditional structures. In the meantime, we
      still have some excellent restructuring strategies to cover in this chapter. </p>
  </sect1>

  <sect1>
    <title>“Pull” Processing: Empirical Processing with XSLT</title>

    <p> We're going to see a method for specifying exactly what we want and where we want it using an approach
      that will look remarkably like a traditional empirical language. XSLT purists would probably call this
      section “Doing It Wrong.” But really, what's wrong with a little shortcut here and there?
      Maybe it's the right thing to do under certain circumstances. The great thing is that XSLT enables you
      to do it, and it won't leave snide little notes in your code reviews to tweak your conscience. </p>

    <p>“Pull” processing is simply a way to use XPath statements to retrieve content while not
      actually allowing the XSLT processor to walk through the XML document. You can start it at any level of
      the XSLT stylesheet, but for our purposes, let's imagine that we only want to write one template that
      matches on the root of the document. How would we get output if we had a complex XML source
      document?</p>

    <p>Well, yes, we could just write <xmltag close="yes">xsl:apply-templates</xmltag> and retrieve all the
      text in document order. You already knew that. But suppose we want to be a little more selective about
      our output, and maybe even put some tags around it somewhere. Let's try putting a bunch of <xmltag close="yes">xsl:apply-templates</xmltag> tags together with <xmlattr>select</xmlattr> statements that
      contain XPaths. First, here's the sample XML document we're going to work on:</p>

<processedcode language="xml" showname="orderorder2/grain1.xml" style="normal" url="orderorder2/grain1.xml">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="pullprocess.xsl"?&gt;</codeline>
<codeline><cokw>&lt;FERMENTABLES&gt;</cokw></codeline>
<codeline>  <cokw>&lt;FERMENTABLE&gt;</cokw></codeline>
<codeline>    <cokw>&lt;NAME&gt;</cokw>Acid Malt<cokw>&lt;/NAME&gt;</cokw></codeline>
<codeline>    <cokw>&lt;VERSION&gt;</cokw>1<cokw>&lt;/VERSION&gt;</cokw></codeline>
<codeline>    <cokw>&lt;TYPE&gt;</cokw>Grain<cokw>&lt;/TYPE&gt;</cokw></codeline>
<codeline>    <cokw>&lt;AMOUNT&gt;</cokw>0.000000<cokw>&lt;/AMOUNT&gt;</cokw></codeline>
<codeline>    <cokw>&lt;YIELD&gt;</cokw>58.7<cokw>&lt;/YIELD&gt;</cokw></codeline>
<codeline>    <cokw>&lt;COLOR&gt;</cokw>3.0<cokw>&lt;/COLOR&gt;</cokw></codeline>
<codeline>    <cokw>&lt;ADD_AFTER_BOIL&gt;</cokw>FALSE<cokw>&lt;/ADD_AFTER_BOIL&gt;</cokw></codeline>
<codeline>    <cokw>&lt;ORIGIN&gt;</cokw>Germany<cokw>&lt;/ORIGIN&gt;</cokw></codeline>
<codeline>    <cokw>&lt;SUPPLIER</cokw><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;NOTES&gt;</cokw>Acid malt contains acids from natural lactic acids.</codeline>
<codeline>      Used by German brewers to adjust malt PH</codeline>
<codeline>      without chemicals to adhere to German purity laws.</codeline>
<codeline>      Also enhances the head retention. <cokw>&lt;/NOTES&gt;</cokw></codeline>
<codeline>    <cokw>&lt;COARSE_FINE_DIFF&gt;</cokw>1.5<cokw>&lt;/COARSE_FINE_DIFF&gt;</cokw></codeline>
<codeline>    <cokw>&lt;MOISTURE&gt;</cokw>4.0<cokw>&lt;/MOISTURE&gt;</cokw></codeline>
<codeline>    <cokw>&lt;DIASTATIC_POWER&gt;</cokw>0.0<cokw>&lt;/DIASTATIC_POWER&gt;</cokw></codeline>
<codeline>    <cokw>&lt;PROTEIN&gt;</cokw>6.0<cokw>&lt;/PROTEIN&gt;</cokw></codeline>
<codeline>    <cokw>&lt;MAX_IN_BATCH&gt;</cokw>10.0<cokw>&lt;/MAX_IN_BATCH&gt;</cokw></codeline>
<codeline>    <cokw>&lt;RECOMMEND_MASH&gt;</cokw>TRUE<cokw>&lt;/RECOMMEND_MASH&gt;</cokw></codeline>
<codeline>    <cokw>&lt;IBU_GAL_PER_LB&gt;</cokw>0.000<cokw>&lt;/IBU_GAL_PER_LB&gt;</cokw></codeline>
<codeline>    <cokw>&lt;DISPLAY_AMOUNT&gt;</cokw>0.00 lb<cokw>&lt;/DISPLAY_AMOUNT&gt;</cokw></codeline>
<codeline>    <cokw>&lt;INVENTORY&gt;</cokw>0.00 lb<cokw>&lt;/INVENTORY&gt;</cokw></codeline>
<codeline>    <cokw>&lt;POTENTIAL&gt;</cokw>1.027<cokw>&lt;/POTENTIAL&gt;</cokw></codeline>
<codeline>    <cokw>&lt;DISPLAY_COLOR&gt;</cokw>3.0 SRM<cokw>&lt;/DISPLAY_COLOR&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/FERMENTABLE&gt;</cokw></codeline>
<codeline><cokw>&lt;/FERMENTABLES&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@222 ?>


    <p>This is an ingredient listed in BeerXML<footnote>
      <p><url>http://www.beerxml.com</url></p>
      </footnote> that obviously contains a lot of technical information. Good for beer brewers, not so good
      for lay readers like myself. So let's concoct a stylesheet that returns just a few items of general
      interest for a beer-taster's website. Matching only on the root, we'll create a simple web page that
      contains only the ingredient name, origin, and notes.</p>

<processedcode language="xml" showname="orderorder2/pullprocess.xsl" style="normal" url="orderorder2/pullprocess.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"/"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;html&gt;</cokw><cokw>&lt;head&gt;</cokw><cokw>&lt;/head&gt;</cokw></codeline>
<codeline>      <cokw>&lt;body&gt;</cokw></codeline>
<codeline>        <cokw>&lt;h1&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"FERMENTABLES/FERMENTABLE/NAME"</costring><cokw>/&gt;</cokw><cokw>&lt;/h1&gt;</cokw></codeline>
<codeline>         <cokw>&lt;p&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"FERMENTABLES/FERMENTABLE/NOTES"</costring><cokw>/&gt;</cokw><cokw>&lt;/p&gt;</cokw></codeline>
<codeline>        <cokw>&lt;p&gt;</cokw></codeline>
<codeline>          <cokw>&lt;xsl:text&gt;</cokw>Origin: <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>          <cokw>&lt;xsl:value-of</cokw> select=<costring>"FERMENTABLES/FERMENTABLE/ORIGIN"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/p&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/body&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/html&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@231 ?>


    <p>And, voila:</p>

    <imagedata border="yes" fileref="images/orderorder2/grain1.png" width="70%"/>

    <p>That, my friends, is pull processing. You just find a comfortable place in the XML and use XPath to
      bring the content to you.</p>

    <p>And please don't tell anyone who showed it to you!</p>

    <p>So why am I showing it to you if it's so naughty? Because in spite of what purists might think, it can
      actually be quite useful in the right situation. For instance, in the example above, using the
      traditional approach I would have had to write a template that matched the /FERMENTABLES/FERMENTABLE
      part of the path, then three other templates, one each for NAME, NOTES, and ORIGIN. In my
      pull-processing shortcut, I've only had to write one template. </p>

    <p>Another advantage is that this approach makes it easy to swap the order of the content. Check the order
      of the notes and the origin in the output.</p>

    <p>The great thing is that you don't need to be at the document root for this to work. You might have
      matched an element further down in the XML structure and realized that all you need at that point are
      two or three of its distant relatives (scattered somewhere across a labyrinthine, booby-trapped XML
      structure). Toss in some <xmltag>xsl:apply-templates</xmltag> or <xmltag>xsl:value-of</xmltag>
      instructions with appropriate XPath statements, and you're doing pull processing---properly, thank you
      very much.</p>

    <p>If pull processing is so useful, why is it frowned on? You can probably guess: XML is a flexible,
      tricksy sort of thing, and you may have no way to anticipate what the structure might actually be. For
      instance, I haven't actually seen a DTD or schema for BeerXML, so I don't know whether ORIGIN or NOTES
      are required fields, and I don't know whether there might be more than one origin. Think what would
      happen, for instance, if we ran into this: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:variable</cokw> name=<costring>"id"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;ORIGINS</cokw> status=<costring>"disputed"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;ORIGIN&gt;</cokw>Germany<cokw>&lt;/ORIGIN&gt;</cokw></codeline>
<codeline>      <cokw>&lt;ORIGIN&gt;</cokw>Netherlands<cokw>&lt;/ORIGIN&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/ORIGIN&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@272 ?>


    <p>Suddenly our pull processing doesn't work so well. In a case like this, we're better off sticking with
      the fall-through template approach that allows XSLT to keep up with the complexities of XML. </p>

    <p>Still, if we know the structure well enough, pull processing can be a useful shortcut for
      retrieving---and re-ordering---small amounts of data.</p>

  </sect1>

  <sect1 id="sect1.xpaths2anywhere">
    <title>XPaths to Anywhere</title>

    <p>So far we've re-ordered content from sort of a top-down approach, but on a regular basis, we're going
      to need to deal with content that's a lot more dispersed than what we've seen so far. Let's imagine a
      set of pharmaceutical data that has been sorted into various sections. (Real pharmaceutical XML is quite
      complex, more complex than we can deal with in our examples here.) In one section is a list of standard
      descriptions for standard types of side effects, and in another section is a list of medications offered
      by a company. It might look a bit like this:</p>

<processedcode language="xml" showname="orderorder2/pharmEffects.xml" style="normal" url="orderorder2/pharmEffects.xml">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="pharmEffects.xsl"?&gt;</codeline>
<codeline><cokw>&lt;substanceEffects&gt;</cokw></codeline>
<codeline>  <cokw>&lt;sideEffects&gt;</cokw></codeline>
<codeline>    <cokw>&lt;negative&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"A"</costring><cokw>&gt;</cokw>dizziness<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"B"</costring><cokw>&gt;</cokw>drowsiness<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"D"</costring><cokw>&gt;</cokw>dyspepsia<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/negative&gt;</cokw></codeline>
<codeline>    <cokw>&lt;positive&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"E"</costring><cokw>&gt;</cokw>awesome strength<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"H"</costring><cokw>&gt;</cokw>reduced risk of heart attack<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/positive&gt;</cokw></codeline>
<codeline>    <cokw>&lt;curious&gt;</cokw></codeline>
<codeline>      <cokw>&lt;effect</cokw> reference=<costring>"I"</costring><cokw>&gt;</cokw>desire to wear colorful spandex<cokw>&lt;/effect&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/curious&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/sideEffects&gt;</cokw></codeline>
<codeline>  <cokw>&lt;substances&gt;</cokw></codeline>
<codeline>    <cokw>&lt;substance</cokw> status=<costring>"experimental"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;invented_name&gt;</cokw>Spydybyty<cokw>&lt;/invented_name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;sideEffects&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"A"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"E"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"I"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/sideEffects&gt;</cokw></codeline>
<codeline>      <cokw>&lt;description&gt;</cokw>This refined, radioactive spider venom</codeline>
<codeline>      is similar to a form accidentally discovered in 1962.</codeline>
<codeline>      <cokw>&lt;/description&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/substance&gt;</cokw></codeline>
<codeline>     <cokw>&lt;substance</cokw> status=<costring>"common"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;invented_name&gt;</cokw>Acetylsalicylic acid<cokw>&lt;/invented_name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;sideEffects&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"B"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"D"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;effect</cokw> ref=<costring>"H"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/sideEffects&gt;</cokw></codeline>
<codeline>      <cokw>&lt;description&gt;</cokw>Acetylsalicylic acid, while used</codeline>
<codeline>      in natural forms since antiquity, was first</codeline>
<codeline>      manufactured in 1899. It is better known as</codeline>
<codeline>      aspirin.</codeline>
<codeline>      <cokw>&lt;/description&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/substance&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/substances&gt;</cokw></codeline>
<codeline><cokw>&lt;/substanceEffects&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@292 ?>


    <p> Our mission is to turn this gobblety-gook into something a bit more readable, like this: </p>

    <imagedata border="yes" fileref="images/orderorder2/spydybyty.png" width="90%"/>

    <p>I know you can do the first parts of this, so why not give it a try. When it's time to do the list of
      effects, we'll see a technique that we haven't explored yet.</p>

    <p>When we get to a tag like <xmltag attrs="ref=“A”">effect</xmltag> in the
      <xmltag>substances</xmltag> section, we need to find an <xmltag>effect</xmltag> in the
      <xmltag>sideEffects</xmltag> section with <xmlattr>references</xmlattr> equal to the
      <xmlattr>ref</xmlattr> attribute we started with. So one thing we need to learn is how to keep track of
      a value that we pick up in one place and compare it to a value in another place.</p>

    <p>Here's the template that performs this piece of the work:</p>

    <figure id="fig.pharmEffects">
      <title>Retrieving the Effects Text for Each Substance</title>
<processedcode language="xml" showname="orderorder2/pharmEffects.xsl" style="normal" url="orderorder2/pharmEffects.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:template</cokw> match=<costring>"effect"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="2">  <cokw>&lt;xsl:variable</cokw> name=<costring>"ref_code"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="3">    <cokw>&lt;xsl:value-of</cokw> select=<costring>"@ref"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="4">  <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline prefix="5">  <cokw>&lt;li&gt;</cokw></codeline>
<codeline prefix="6">  <cokw>&lt;xsl:value-of</cokw></codeline>
<codeline prefix="7">   select=<costring>"/substanceEffects/</costring></codeline>
<codeline id="code.reference.value" lineno="8" prefix="8">   <costring>sideEffects//effect[@reference = $ref_code]"</costring><cokw>/&gt;</cokw>  </codeline>
<codeline prefix="9">  <cokw>&lt;/li&gt;</cokw></codeline>
<codeline prefix="10"><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@311 ?>

    </figure>

    <p>In this example our XPath statement starts all the way back at the root with that introductory slash
      (/), then works its way back down the hierarchy. The double-slash (//) in the path is a neat piece of
      shorthand to ignore the fact that the <xmltag>effect</xmltag> tags are in three different container
      elements. We want to look in all of those containers, so we use // to say “any path from the
      <xmltag>sideEffects</xmltag> tag to any <xmltag>effects</xmltag> tag.” (Note that we had to
      include the <xmltag>sideEffects</xmltag> element in the path. If we had eliminated it, the statement
      would also have picked up those <xmltag>effect</xmltag> tags in the <xmltag>substances</xmltag>
      section.</p>

    <p>Although this approach works, backing all the way up to the root and then working back down can take a
      lot of processing overhead. Another way we could have done the same thing is by using a relative path.
      In this case, the path would have had to refer up to a common ancestor then work its way down, like
      this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:value-of</cokw></codeline>
<codeline> select=<costring>"ancestor::substanceEffects/sideEffects//effect[@reference = $ref_code]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@333 ?>


    <p>Between you and me, there's not much difference in this case, but in larger chunks of XML the
      difference may be considerable. Be kind to your processors!</p>

    <p>If you compare the predicate in line <cref linkend="code.reference.value"/> (<xref linkend="fig.pharmEffects"/>) with the predicate in line <cref linkend="code.idEquals"/> in <xref linkend="fig.listfix"/>, you'll detect a pattern. This is a strategy we'll often use in conjunction with
      XPath statements: we put the value of some attribute of an element into a variable where it will stay
      put, then we use XPath to find some other element with a similar or identical attribute value. In the
      first example we used an ID value that we generated with XSLT. In the second example we used a reference
      value that was intentionally set up for this purpose. </p>

    <p>I don't know whether this strategy has a name, but it should. “Snare and compare?” Corny, I
      know, but let's go with it. We will see this strategy again in our XSLT travels.</p>

    <p>Speaking of travels, our next stop on the subject of grouping will take us a good bit further down the
      road of reorganizing content.</p>

    <joeasks>
      <title>How Do I Handle Those Incredibly Long XSLT Expressions?</title>
      <p>XSLT expressions can be as complex as the patterns of XML you encounter, and they can become
        incredibly long at times. In those cases, you'll want to add line breaks to the expressions where
        possible to make them more readable. Some valid places to break XSLT expressions are:</p>

      <ul>
        <li>
          <p>Before or after the quote marks enclosing the expression</p>
        </li>
        <li>
          <p>Between expression operators. I like to put the expression operator at the beginning of the
            second line so I can see the type of relationship more easily, but a lot of people do it the other
            way around.</p>
        </li>
        <li>
          <p>Between predicate square brackets</p>
        </li>
        <li>
          <p>Within function parentheses</p>
        </li>
        <li>
          <p>Between attributes</p>
        </li>
        <li>
          <p>Before or after the slashes in an XPath path. I like to bring the slash down to the next line so
            I can see that it's part of a path.</p>
        </li>
      </ul>

      <p>For example, this expression...</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw></codeline>
<codeline>  match=<costring>"/docroot</costring></codeline>
<codeline>  <costring>/a</costring></codeline>
<codeline>  <costring>| docroot/b</costring></codeline>
<codeline>  <costring>[contains(.,</costring></codeline>
<codeline>  <costring>'yes'</costring></codeline>
<codeline>  <costring>)]</costring></codeline>
<codeline>  <costring>[@id</costring></codeline>
<codeline>  <costring>= 2]"</costring></codeline>
<codeline><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@397 ?>


      <p>...is valid and functionally the same as...</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"docroot/a | docroot/b[contains(.,'yes')][@id = 2]"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@405 ?>


      <p>For myself, I like to place the breaks so there are parallel groupings from line to line---large
        predicates, halves of relational statements, and so forth. It helps with scanning through the code to
        see what's what. XSLT is noteworthy for being verbose, and management of all that verbage can become a
        significant issue.</p>
    </joeasks>
  </sect1>

  <sect1>
    <title>Grouping</title>
    <p>Grouping and sorting are two fundamental activities in database handling, and likewise in the world of
      XML processing. In this section we'll see how to handle grouping with XSLT, then we'll follow up with
      sorting in the next section.</p>

    <p>By grouping, we mean that we are going to gather similar sorts of things together. As part of this
      gathering, we may find it helpful or convenient to place certain repeated parts of the data into an
      overall heading for the group, then list the group members without the repetitions.</p>

    <p>With the work that we've already done with XPath, we'll find that grouping is not really a big deal.
      Not unlike rearranging XML content piece by piece, as we saw it in <ref linkend="sect1.xpaths2anywhere"/>, the secret of grouping is to place the <xmltag>xsl:apply-templates</xmltag> tags judiciously, choose
      our XPaths carefully, and decide what and what not to process. </p>

    <p>OK, that's a little abstract, so let's dive into an example and see if we can figure out what I was
      just trying to say.</p>

    <p>In a basic form of grouping, let's say we have some XML about bicycles that looks like this, only with,
      say, several hundred models:</p>

<figure id="fig.code.bike.xml">
  <title>Example XML for Bike Models and Shops</title>
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;bikes&gt;</cokw></codeline>
<codeline>  <cokw>&lt;bike&gt;</cokw></codeline>
<codeline>    <cokw>&lt;brand&gt;</cokw>Raleigh<cokw>&lt;/brand&gt;</cokw></codeline>
<codeline>    <cokw>&lt;model&gt;</cokw>Revenio 3.0<cokw>&lt;/model&gt;</cokw></codeline>
<codeline>    <cokw>&lt;price&gt;</cokw>1199<cokw>&lt;/price&gt;</cokw></codeline>
<codeline>    <cokw>&lt;group&gt;</cokw>105<cokw>&lt;/group&gt;</cokw></codeline>
<codeline>    <cokw>&lt;shop&gt;</cokw>REI<cokw>&lt;/shop&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/bike&gt;</cokw></codeline>
<codeline>   ...</codeline>
<codeline>  <cokw>&lt;bike&gt;</cokw></codeline>
<codeline>    <cokw>&lt;brand&gt;</cokw>KHS<cokw>&lt;/brand&gt;</cokw></codeline>
<codeline>    <cokw>&lt;model&gt;</cokw>Flite 750<cokw>&lt;/model&gt;</cokw></codeline>
<codeline>    <cokw>&lt;price&gt;</cokw>1999<cokw>&lt;/price&gt;</cokw></codeline>
<codeline>    <cokw>&lt;group&gt;</cokw>sram rival<cokw>&lt;/group&gt;</cokw></codeline>
<codeline>    <cokw>&lt;shop&gt;</cokw>TLC Bikes<cokw>&lt;/shop&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/bike&gt;</cokw></codeline>
<codeline><cokw>&lt;/bikes&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@457 ?>

</figure>
    
    <p>We'd like to get all that data into a more manageable form---say, group the bikes by store, if we're
      serving up a friendly website that lists bike models by bike shop. There are at least two ways to do
      this: the sneaky way and the clasically correct (hard) way. We'll check out both methods.</p>

    <sect2>
      <title>Finding First Instances</title>

      <p>First, let's think about what we're trying to do. We want to construct a list of stores, and each
        store will have a secondary list of the bike models it has available. It's a long list, and we don't
        necessarily know the name of each store we're likely to encounter, so our stylesheet has to take into
        account that we need a list of models for any store we happen to encounter. We can't tell it exactly
        what to look for.</p>

      <p>In the sneaky solution, we use XPath to match on each store, but we add a predicate to make sure that
        there is no previous entry for the same store, so we get only the first entry for each store. Then we
        apply templates to all the following entries and take the ones that match the current store.</p>

      <p>We're going to have to add one more XSLT tool to the utility belt to make this one work. But first
        let's have a look at the stylesheet in <ref linkend="fig.bikelist"/>. </p>

      <figure id="fig.bikelist" place="top">
        <title>Listing bike models by bike shop</title>
<processedcode language="xml" showname="orderorder2/bike-grouping.xsl" style="normal" url="orderorder2/bike-grouping.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"/bikes"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;store-models&gt;</cokw></codeline>
<codeline prefix="5">      <cokw>&lt;xsl:apply-templates</cokw></codeline>
<codeline id="code.bikelist.select-first" lineno="6" prefix="-">        select=<costring>"bike[not(preceding-sibling::bike/shop = shop)]"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;/store-models&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="10">  <cokw>&lt;xsl:template</cokw> match=<costring>"bike"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;xsl:variable</cokw> name=<costring>"this-shop"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:value-of</cokw> select=<costring>"shop"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;shop&gt;</cokw></codeline>
<codeline prefix="15">      <cokw>&lt;shop-name&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"shop"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/shop-name&gt;</cokw></codeline>
<codeline id="code.bikelist.this-bike" lineno="18" prefix="-">      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"."</costring> mode=<costring>"bikelist"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:apply-templates</cokw></codeline>
<codeline id="code.bikelist.select-rest" lineno="20" prefix="20">        select=<costring>"following-sibling::bike[shop = $this-shop]"</costring> mode=<costring>"bikelist"</costring><cokw>/&gt;</cokw> </codeline>
<codeline prefix="-">    <cokw>&lt;/shop&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline id="code.bikelist.bikelist-content" lineno="24" prefix="-">  <cokw>&lt;xsl:template</cokw> match=<costring>"bike"</costring> mode=<costring>"bikelist"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="25">    <cokw>&lt;bike&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;brand&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/brand&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;model&gt;</cokw></codeline>
<codeline prefix="30">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/model&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;price&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;xsl:value-of</cokw> select=<costring>"price"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/price&gt;</cokw></codeline>
<codeline prefix="35">    <cokw>&lt;/bike&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@482 ?>

      </figure>

      <p>You no doubt noticed that <xmlattr>mode</xmlattr> thing we've thrown into the mix. A template
        <firstuse>mode</firstuse> is simply a way of adding a name to <xmltag>xsl:template</xmltag> and
        <xmltag>xsl:apply-templates</xmltag> as a way to allow a separate “branch” of processing.
        Sometimes we need to process one or more elements more than one time, in different ways. For instance,
        we might process all the tags in a book three times---once for the table of contents, once for the
        body, and once for the index. If we just used a <xmlattr>match</xmlattr> or <xmlattr>select</xmlattr>
        statement for the tags we needed to process a second time, those statements would probably look
        identical to the ones we used to process the tags the first time. As my some of my friends like to
        say, “that dog don't hunt.”  And besides, XSLT parsers get cranky about duplicate template matches.</p>

      <p>We solve the problem by using modes. Modes can be named anything you like (without spaces), the more
        descriptive of their purpose the better. Templates for processing the table of contents might have a
        <xmlattr value="toc">mode</xmlattr>, and so forth.</p>

      <p>In the XSLT script in <ref linkend="fig.bikelist"/>, we first match on the root element and set up
        the wrapper XML tag for our output, <xmltag>store-models</xmltag>. Then comes the first part of our
        strategy: in line <cref linkend="code.bikelist.select-first"/>, we select the first instance of
        <xmltag>bike</xmltag> by checking whether there is any preceding <xmltag>bike</xmltag> that has the
        same value in the <xmltag>shop</xmltag> element as the current instance. If no preceding occurence,
        this is the first for that bike shop. Selecting only the first instance for each shop, we go off to
        the template for <xmltag>bike</xmltag> and do more processing. </p>

      <p>In the template for <xmltag>bike</xmltag>, we make some tags for the shop and shop name. Since we
        have the information for one bike within the current <xmltag>bike</xmltag> tag, we use an
        <xmltag>xsl:apply-templates</xmltag>(line <cref linkend="code.bikelist.this-bike"/>)---with the
        <xmlattr value="bikelist">mode</xmlattr> that we talked about---to process the tags for this bike. </p>

      <p>Note that the value of the <xmlattr>select</xmlattr> statement is a period (.), which selects the
        current element, which is <xmltag>bike</xmltag>. To keep the templates compact, we want to select the
        <xmltag>bike</xmltag> tag here so we can use the same template we use when selecting the following
        <xmltag>bike</xmltag> tags. </p>

      <p>But now we need to process all the other <xmltag>bike</xmltag> tags for the same shop. Ah---here's
        where our XPath friend, following-sibling, comes in handy. In line <cref linkend="code.bikelist.select-rest"/> we use the old “snare and compare” method to process
        through the remaining bike tags with the name of our current bike shop in hand. (See, I told you we'd
        see it again!) Where the <xmltag>bike</xmltag> tag has a <xmltag>shop</xmltag> tag with the same
        value, we again apply the template for <xmltag>bike</xmltag> in the <xmlattr value="bikelist">mode</xmlattr> mode.</p>

      <p>Finally, the last template on line <cref linkend="code.bikelist.bikelist-content"/> fills in the gory
        details for each bike. And that's it! With three carefully arranged templates, we've sifted through
        the XML to give us bike grouping by shop, sort of like this:</p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;store-models&gt;</cokw></codeline>
<codeline>  <cokw>&lt;shop&gt;</cokw></codeline>
<codeline>    <cokw>&lt;shop-name&gt;</cokw>REI<cokw>&lt;/shop-name&gt;</cokw></codeline>
<codeline>    <cokw>&lt;bike&gt;</cokw></codeline>
<codeline>      <cokw>&lt;brand&gt;</cokw>Raleigh<cokw>&lt;/brand&gt;</cokw></codeline>
<codeline>      <cokw>&lt;model&gt;</cokw>Revenio 3.0<cokw>&lt;/model&gt;</cokw></codeline>
<codeline>      <cokw>&lt;price&gt;</cokw>1199<cokw>&lt;/price&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/bike&gt;</cokw></codeline>
<codeline>    <cokw>&lt;bike&gt;</cokw></codeline>
<codeline>      <cokw>&lt;brand&gt;</cokw>Diamondback<cokw>&lt;/brand&gt;</cokw></codeline>
<codeline>      <cokw>&lt;model&gt;</cokw>Podium 4<cokw>&lt;/model&gt;</cokw></codeline>
<codeline>      <cokw>&lt;price&gt;</cokw>1499<cokw>&lt;/price&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/bike&gt;</cokw></codeline>
<codeline>    ...</codeline>
<codeline>  <cokw>&lt;/shop&gt;</cokw></codeline>
<codeline>  ...</codeline>
<codeline><cokw>&lt;/store-models&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@549 ?>


      <p>This approach to grouping---finding the first item in a group then iterating over the remaining
        items---works okay, but it can lead to some lengthy XPath statements as the XML structure becomes more
        complex. For instance, what do we do if <xmltag>bike</xmltag> is not always at the same level in the
        structure? This iterative method is okay for simple hierarchies, but to deal with more complex XML,
        we're going to need a more industrial-strength method. </p>
    </sect2>

    <sect2>
      <title>Keys for Grouping: the Muenchian Method</title>
      
      <p>To manage the grouping in a more abstract and flexible fashion, we use a tool called a <firstuse>key</firstuse>. The use of keys involves 
        two parts: the <xmltag>xsl:key</xmltag> tag, which defines what we're looking for, and the <ic>key()</ic> function, 
        which we place where we need to use the key we've defined.
      </p>
      
      <sect3 id="sect3.intro.keys">
        <title>Introduction to Keys</title>
     
      
      <p>So, very quickly, here are the technical details on the <xmltag>xsl:key</xmltag> and the <ic>key()</ic> function. Don't get too bogged down
      in the details, though---it's best to see these guys in action to understand how they work.</p>
      
      <dl>
        <dt><xmltag>xsl:key</xmltag></dt>
        <dd>
          <p><xmltag>xsl:key</xmltag> tags appear at the same level as the <xmltag>xsl:template</xmltag> tag in the stylesheet.  By convention, they
          are usually placed before any templates at the top of the stylesheet so they are easy to keep track of. By being placed at the top level 
          in the stylesheet, they can be used in any template. (In other words, they have <emph>global scope</emph>---although we haven't
          gotten to the concept of scope quite yet. Patience, Grasshopper.)
          </p>
          <p>Following are the pertinent attributes for <xmltag>xsl:key</xmltag>:</p>
          
          <table style="hlines">
            <thead>
              <col>Attribute</col>
              <col>Required?</col>
              <col>Function</col>
            </thead>
            <row>
              <col>name</col>
              <col>Yes</col>
              <col><p>Gives the name of the key, which will be called by the <ic>key()</ic> function. The name must not contain spaces, but it may contain a namespace prefix.</p>
              </col>
            </row>
            <row>
              <col>match</col>
              <col>Yes</col>
              <col>Provides the XPath pattern that will be matched when the key is used.</col>
            </row>
            <row>
              <col>use</col>
              <col>Yes</col>
              <col><p>Gives an expression for the value to be matched in the nodes retrieved by the <xmlattr>match</xmlattr> attribute.  
                The expression can match values in the attributes, text, or children of the matched node. Note that the expression is evaluated in the context
                of the path given by the <xmlattr>match</xmlattr> attribute.  For example, using our bike shop example in <xref linkend="fig.code.bike.xml"/>,
                if we say <xmltag attrs="name=&quot;bike-brand&quot; match=&quot;bike&quot; use=&quot;brand&quot;" close="yes">xsl:key</xmltag>, it's valid
                because <xmltag>brand</xmltag> is a child of <xmltag>bike</xmltag>.  
              
              </p></col>
            </row>
          </table>
        </dd>
        <dt><ic>key({string},{object})</ic></dt>
        <dd><p>The <ic>key()</ic> function uses the definition of the key.</p> 
      
          <table style="hlines">
            <thead>
              <col>Parameter</col>
              <col>Required?</col>
              <col>Function</col>
            </thead>
            <row>
              <col>string</col>
              <col>Yes</col>
              <col><p>Gives the name of the <xmltag>xsl:key</xmltag> to be used.</p></col>
            </row>
            <row>
              <col>object</col>
              <col>Yes</col>
              <col><p>Specifies what value will be used for the <xmlattr>use</xmlattr> expression.</p></col>
            </row>
          </table>
        </dd>
      </dl>
      
      <p> For <ic>key()</ic> to work properly, it needs to be placed where the path of the <xmlattr>match</xmlattr> attribute is valid. 
        In our bike example, if we define the key  <xmltag attrs="name=&quot;bike-brand&quot; match=&quot;bike&quot; use=&quot;brand&quot;" close="yes">xsl:key</xmltag>, 
        we need to use <ic>key('bike-brand','Specialized')</ic> in a context where that <xmlattr value="bike">match</xmlattr> makes sense---in our case, when we have matched the <xmltag>bikes</xmltag>
        tag. We'll see that arrangement in action in our next example.
      </p>
      
      <p>In their simplest use, the <xmltag>xsl:key</xmltag> tag and <ic>key()</ic> function work to select specific 
        items from a list. For example, let's say that in our list of bicycles we want only the list of bikes 
        made by Specialized. Here's a stylesheet to do the trick:</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline><cokw>&lt;xsl:stylesheet</cokw> version=<costring>"1.0"</costring></codeline>
<codeline>  xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring><cokw>&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:key</cokw> name=<costring>"bike-brand"</costring> match=<costring>"bike"</costring> use=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"/bikes"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;html&gt;</cokw></codeline>
<codeline>    <cokw>&lt;body&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"key('bike-brand', 'Specialized')"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/body&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/html&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"bike"</costring><cokw>&gt;</cokw></codeline>
<codeline>  [Tags and values we want from the <cokw>&lt;bike&gt;</cokw> contents.]</codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@667 ?>

      
      <p>The result is a list that matches <xmltag>bike</xmltag> where <xmltag>brand</xmltag> has the value <emph>Specialized</emph>. As you can see, we've place the <ic>key()</ic>
      function in the template that matches <xmltag>bikes</xmltag> so the <xmlattr value="bike">match</xmlattr> attribute makes sense.  And since we've specified <xmlattr value="brand">use</xmlattr>
        in the key itself, and the <ic>key()</ic> function specifies we want the value <ic>Specialized</ic>, the combination works to retrieve all instances of <xmltag>bike</xmltag> where <xmltag>brand</xmltag> is
        <ic>Specialized</ic>.
      </p>
        
      </sect3>
      <sect3 id="sect3.muenchian.method">
      <title>The Muenchian Method and <xmltag>xsl:for-each</xmltag></title>
      <p>Keys are helpful when we need to match the same element many times with one or more values, even if we aren't necessarily grouping things.  
        But it does suggest that keys could be used for grouping. The catch is that the simple usage shown in <ref linkend="sect3.intro.keys"/> doesn't create a heading 
        for the items to be listed under, and it doesn't select all the values that might appear for <xmltag>brand</xmltag>.  To go this extra step, we're going to need a little extra twist---and 
        interestingly enough, it also uses the “snare-and-compare” method.  This approach is commonly called the <firstuse>Muenchian method</firstuse>.</p>
      
      <joeasks>
        <title>Why is it called the Muenchian method?</title>
        <p>The Muenchian method is named after Steve Muench, an early XSLT programmer who developed it.</p>
        <p>The XSLT development community has been fairly tightly knit over the years...<author>more history here.</author></p>
      </joeasks>
        
        <p>To demonstrate the Muenchian method in its classical form, we're going to need to learn a new XSLT tools, the <xmltag>xsl:for-each</xmltag> instruction. 
          We've been using <xmltag>xsl:apply-templates</xmltag> to accomplish some of the work it does, but it will make the form of the solution much easier
        in the long run. And more tools are almost always better.
        </p>
        
        <dl>
          <dt><xmltag>xsl:for-each</xmltag></dt>
          <dd>
            <p>The <xmltag>xsl:for-each</xmltag> instruction is an <emph>iterator</emph>: it directs the XSLT processor to execute its contents as many times as necessary to satisfy its conditions.
              The conditions it specifies are defined by an XPath expression in the <xmlattr>select</xmlattr> attribute.  The condition is satisfied when the processor has found all of the instances
              of the XPath expression it can find, or when it determines that no nodes match the XPath expression. 
            </p>
            
            <p>In a way, <xmltag>xsl:for-each</xmltag> is a bit like the <xmltag>xsl:apply-templates</xmltag> in that it tells the processor to select some node and act on it, 
              and it's a bit like the <xmltag>xsl:template</xmltag> tag in that it contains additional instructions for the processor to execute within the context of the selected tag.
              Which brings up another interesting point: <xmltag>xsl:apply-templates</xmltag> and <xmltag>xsl:for-each</xmltag> are the only two tags that can be used to change the current context
              of the XSLT processor within the XML content.  The <xmlattr>select</xmlattr> attribute in both instructions is the ticket for the XSLT processor to move down the road.
            </p>
            
            <p>Although <xmltag>xsl:for-each</xmltag> temporarily changes the execution context of the processor, execution returns to the template in which it appears
              once all its conditions are satisfied. If the template contains other instructions after the <xmltag>xsl:for-each</xmltag>, those are executed next.
            </p>
            
            <p>Another point worth mentioning is that if you define a variable within the <xmltag>xsl:for-each</xmltag> instruction, that variable is defined the same way each time the contents 
              of the <xmltag>xsl:for-each</xmltag> instruction are executed. That means that the results of a previous execution of <xmltag>xsl:for-each</xmltag> can't be used to change the contents of the variable.
              If you run into that sort of issue, you probably want to use <firstuse>iteration</firstuse>, a technique we will see in <xref linkend="chap.stylesheets"/>
            </p>
            
            <p><xmlattr>select</xmlattr> is the only required attribute for <xmltag>xsl:for-each</xmltag>.</p>
            
            <p>We'll see <xmltag>xsl:for-each</xmltag> in a bit of sample code shortly.</p>
          </dd>
        </dl>
         
        <p>So, going back to our previous example, where we listed only the bikes of a single particular brand, we still have a problem: how would we group all of the bikes 
          by all of the brands in our XML example (<xref linkend="fig.code.bike.xml"/>)?  Let's take a look.
        </p>
        
        <figure id="code.grouping.muenchian">
          <title>The Muenchian Grouping Method</title>
<processedcode language="xml" showname="orderorder2/bike-grouping-muenchian.xsl" style="normal" url="orderorder2/bike-grouping-muenchian.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:key</cokw> name=<costring>"bike-brand"</costring> match=<costring>"bike"</costring> use=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="5">  <cokw>&lt;xsl:template</cokw> match=<costring>"/bikes"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;store-models&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:for-each</cokw></codeline>
<codeline id="code.muenchian.select-first" lineno="8" prefix="-">        select=<costring>"bike[generate-id() = generate-id(key('bike-brand', brand)[1])]"</costring><cokw>&gt;</cokw>   </codeline>
<codeline prefix="-">        <cokw>&lt;h1&gt;</cokw></codeline>
<codeline prefix="10">          <cokw>&lt;xsl:value-of</cokw> select=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/h1&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;ul&gt;</cokw></codeline>
<codeline id="code.muenchian.select-remainder" lineno="13" prefix="-">          <cokw>&lt;xsl:for-each</cokw> select=<costring>"key('bike-brand',brand)"</costring><cokw>&gt;</cokw> </codeline>
<codeline id="code.muenchian.output" lineno="14" prefix="-">            <cokw>&lt;li&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw>, <cokw>&lt;xsl:value-of</cokw> select=<costring>"shop"</costring><cokw>/&gt;</cokw><cokw>&lt;/li&gt;</cokw> </codeline>
<codeline prefix="15">          <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/ul&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/store-models&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="20"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@729 ?>

        </figure>
        
          <p>And that's it.  If nothing else, it's much more terse than what we did before.</p>
        
          <p>Let's have a look at what's going on here. First, you'll see that we've set up the key exactly as we did when we were just picking out a single entry. This time, however,
            we're going to generalize our use of the key to select multiple entries.  In line <cref linkend="code.muenchian.select-first"/>, we've placed a <xmltag>xsl:for-each</xmltag>
            that uses the key.  The <xmltag>xsl:for-each</xmltag> will iterate through the path specified by the <xmlattr>select</xmlattr> statement. </p>
        
        <p>In this case, though, we've limited the selection to one item.  The <xmlattr>select</xmlattr> statement says we're going to look through all the <xmltag>bike</xmltag> elements,
          then the predicate checks whether the ID generated for this instance is the same as the ID generated for the first instance in the key. If the two generated IDs are equal, this
          instance is the first in the list. (Jeni Tennison suggestions another method for handling the 
          predicate,<footnote><p><url>http://www.jenitennison.com/xslt/grouping/muenchian.html</url></p></footnote> but either should do the trick.)</p>
        
        <p>Having selected the first instance, we insert a few tags for the output to
          create our brand heading.  Now we need to list all the instances of bikes of that brand.  Here again we use
          <xmltag>xsl:for-each</xmltag> with the key to iterate through the node-set (in line <cref linkend="code.muenchian.select-remainder"/>). 
          Since we've already established the name of the brand when we went through the first <xmltag>xsl:for-each</xmltag>, the 
          second <xmltag>xsl:for-each</xmltag> iterates only through the set of <xmltag>bike</xmltag> nodes containing that brand. 
          The results will be a list of all the bikes of that brand, showing only the two values we're outputting in line <cref linkend="code.muenchian.output"/>. 
        </p>
        
        <p>Hey, that wasn't so bad! You probably recognize some of the similarities with the method we covered earlier. The difference is that with the key, 
          we can do it a lot more efficiently.</p>
        
        <p>As you play with keys, you'll see that you can adjust the <xmlattr>match</xmlattr> and <xmlattr>use</xmlattr> expressions to cover
        a wide range of relationships in the document. Remember, XPath is your friend. The key to remember(so to speak) is that the <xmlattr>use</xmlattr>
          expression has to be valid within the context of the node-set returned by the <xmlattr>match</xmlattr> statement, and the <ic>key()</ic> function has
          to be used where the <xmlattr>match</xmlattr> statement makes sense. Remember those two points, and you're well on your way to becoming a master of the keys.
        </p>
      </sect3>
      
      <p>Excellent! Grouping is one of the more complicated techniques we'll learn in this book, so we've done well. We can now select items and group them by various sorts of affinities
        within their content. But there's one more technique we need to add to our quiver to give us fundamental control over our lists. We now need to sort what we've retrieved
       so our audience isn't presented with a random batch of whatever happens to get stuffed into the source content.</p>
    </sect2>
  </sect1>

  <sect1> 
      <title>Sort of a Short Sortie on Sorting</title>
    
      <p>I have a confession: I enjoy baseball statistics.  I'm not nearly the statistics junky that some people are, 
        but I like to go to stats websites and browse through
      those monstrous wide tables of player statistics.  One of the things I like best about
      those sites is the little widget at the top of each column to sort the players by
      each satistical category.  Does a high number of triples correspond to a high number of stolen bases?
      Does a a high ratio of homers per at-bat correspond to a high number of plate appearances?
      A sad case, no doubt about it. 
      </p>
      
      <p>You'll inevitably need to supply someone with a sorted list at some point, and no wonder. 
      Try looking through an unsorted list of a few hundred items to find five or six specific entries. 
      Wouldn't it be nice if someone had just sorted the fershlugginer thing?</p>
      
      <p>We don't want to be responsible for creating fershlugginer sorts of things, so let's sort out this sorting business.</p>
      
      <p>The primary actor in most sorting methods is, as you might guess, the <xmltag>xsl:sort</xmltag> instruction. Let's get its vital statistics, then we'll put it through its paces
        in a continuation of our bike shop example.
      </p>
      
      <dl style="bold">
        <dt newline="yes"><xmltag>xsl:sort</xmltag></dt>
        <dd>
          <p><xmltag>xsl:sort</xmltag> specifies the order in which data will be output.  It must be used as the first element 
            within an <xmltag>xsl:apply-templates</xmltag> or <xmltag>xsl:for-each</xmltag> instruction. This instruction is always used as an empty tag. 
            The default order, if no attributes are given, is for data to be sorted in ascending order as text.
          </p>
          <table style="hlines">
        <thead>
          <col>Attribute</col>
          <col>Required?</col>
          <col>Function</col>
        </thead>
            <row>
              <col>select</col>
              <col>No</col>
              <col><p>Specifies the node that will be the basis for sorting the node-set selected by the <xmltag>xsl:apply-templates</xmltag> or <xmltag>xsl:for-each</xmltag> tag (“the selected node”).
              This implies that the node specified in this attribute must be a descendant of the selected node, or it must be the selected node itself.</p>
                <p>If this attribute isn't used, the data is sorted on the node selected by the <xmltag>xsl:apply-templates</xmltag> or <xmltag>xsl:for-each</xmltag> tag.</p></col>
            </row>
            <row>
              <col>order</col>
              <col>No</col>
              <col><p>The value <xmlattrval>ascending</xmlattrval> or <xmlattrval>descending</xmlattrval> specify whether the sort order will be ascending or descending. The default order is ascending.</p></col>
            </row>
            <row>
              <col>data-type</col>
              <col>No</col>
              <col><p>Specifies how the data will be treated for sorting purposes.
                Valid values are <xmlattrval>text</xmlattrval>, <xmlattrval>number</xmlattrval>, and <xmlattrval>qname</xmlattrval>. The default value is <xmlattrval>text</xmlattrval>.</p>
                <p>When <xmlattrval>number</xmlattrval> is specified, values are sorted by their numeric value rather than by their first characters.  For example, in the group 45, 90, 135, the alphabetical ordering
                arranges them as 135, 45, 90, while the numeric ordering herds them back into a sensible 45, 90, 135.</p>
              </col>
            </row>
            <row>
              <col>case-order</col>
              <col>No</col>
              <col><p>The value <ic>upper-first</ic> or <ic>lower-first</ic> specify whether uppercase or lowercase letters will be first. 
                This attribute only has an effect when <xmlattr value="text">data-type</xmlattr>
                The default value is language-dependent and also has a dependency on the XSLT processor.</p></col>
            </row>
             <row>
               <col>lang</col>
              <col>No</col>
               <col><p>Specifies the language to be used as the basis for sorting. Valid values are the language codes 
                 as defined by the IEFT Network Working Group.<footnote><p>Tags for Identifying Languages, <url>http://www.ietf.org/rfc/rfc4646.txt</url></p></footnote> 
                 If you're up on your XML or HTML, it's the same language codes you use in those.</p></col>
            </row>
          </table>
        </dd>
      </dl>
      
      <p>So there's the dull stuff out of the way---now let's watch it work.</p>
    
    <p>Looking back at our bike shop grouping exercise (<ref linkend="code.grouping.muenchian"/>),
      we can see there are a couple of opportunities for sorting. 
      Let's pop an <xmltag>xsl:sort</xmltag> under each <xmltag>xsl:for-each</xmltag> and see what
      we get.  Here's the code with our addition:</p>
   
   <figure id="code.muenchian.sorted">
     <title>Sorting the Bicycle Output</title>
<processedcode language="xml" showname="orderorder2/bike-grouping-muenchian-sorted.xsl" style="normal" url="orderorder2/bike-grouping-muenchian-sorted.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:key</cokw> name=<costring>"bike-brand"</costring> match=<costring>"bike"</costring> use=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="5">  <cokw>&lt;xsl:template</cokw> match=<costring>"/bikes"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;store-models&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:for-each</cokw></codeline>
<codeline id="code.muenchian2.select-first" lineno="8" prefix="-">        select=<costring>"bike[generate-id() = generate-id(key('bike-brand', brand)[1])]"</costring><cokw>&gt;</cokw>   </codeline>
<codeline prefix="-">        <cokw>&lt;xsl:sort</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="10">        <cokw>&lt;h1&gt;</cokw></codeline>
<codeline prefix="-">          <cokw>&lt;xsl:value-of</cokw> select=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/h1&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;ul&gt;</cokw></codeline>
<codeline id="code.muenchian2.select-remainder" lineno="14" prefix="-">          <cokw>&lt;xsl:for-each</cokw> select=<costring>"key('bike-brand',brand)"</costring><cokw>&gt;</cokw> </codeline>
<codeline prefix="15">            <cokw>&lt;xsl:sort</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw></codeline>
<codeline id="code.muenchian2.output" lineno="16" prefix="-">            <cokw>&lt;li&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw>, <cokw>&lt;xsl:value-of</cokw> select=<costring>"shop"</costring><cokw>/&gt;</cokw><cokw>&lt;/li&gt;</cokw> </codeline>
<codeline prefix="-">          <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/ul&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="20">    <cokw>&lt;/store-models&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@850 ?>

    </figure>
    <p>As you can see, we didn't bother with any of the attributes for the brand in the first 
      <xmltag>xsl:sort</xmltag>.  Good old alpha sorting, nothing fancy.  In the second sort, we
      said that we wanted to sort by brand. And here are the results, side-by-side with the unsorted version, for your inspection:</p>
    
    <figure id="fig.sorted">
      <title>Unsorted Bike List beside Sorted List</title>
      <imagedata border="yes" fileref="images/orderorder2/unsorted-vs-sorted.png"/>
    </figure>
    
    <p>Finally, let's put the icing on the cake for our grouping/sorting extravaganza. Can we sort on two 
      or more fields at the same time?  And how do those numbers sort out?  For this exercise to look good,
      we'll need a little more data, and we'll want to pull in the prices of our bikes.  We'll add another 
      <xmltag>xsl:sort</xmltag> under the second one
      in <xref linkend="code.muenchian.sorted"/>, this time with <xmlattr value="price">select</xmlattr> 
      and <xmlattr value="number">data-type</xmlattr>.
      Now our code looks like:
    </p>
    
<processedcode language="xml" showname="orderorder2/bike-grouping-muenchian-sorted2.xsl" style="normal" url="orderorder2/bike-grouping-muenchian-sorted2.xsl">
<codeline prefix="Line 1"><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:output</cokw> indent=<costring>"yes"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;xsl:key</cokw> name=<costring>"bike-brand"</costring> match=<costring>"bike"</costring> use=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-"/>
<codeline prefix="5">  <cokw>&lt;xsl:template</cokw> match=<costring>"/bikes"</costring><cokw>&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;store-models&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;xsl:for-each</cokw></codeline>
<codeline id="code.muenchian3.select-first" lineno="8" prefix="-">        select=<costring>"bike[generate-id() = generate-id(key('bike-brand', brand)[1])]"</costring><cokw>&gt;</cokw>   </codeline>
<codeline prefix="-">        <cokw>&lt;xsl:sort</cokw><cokw>/&gt;</cokw></codeline>
<codeline prefix="10">        <cokw>&lt;h1&gt;</cokw></codeline>
<codeline prefix="-">          <cokw>&lt;xsl:value-of</cokw> select=<costring>"brand"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;/h1&gt;</cokw></codeline>
<codeline prefix="-">        <cokw>&lt;ul&gt;</cokw></codeline>
<codeline id="code.muenchian3.select-remainder" lineno="14" prefix="-">          <cokw>&lt;xsl:for-each</cokw> select=<costring>"key('bike-brand',brand)"</costring><cokw>&gt;</cokw> </codeline>
<codeline prefix="15">            <cokw>&lt;xsl:sort</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">            <cokw>&lt;xsl:sort</cokw> select=<costring>"price"</costring> data-type=<costring>"number"</costring><cokw>/&gt;</cokw></codeline>
<codeline prefix="-">            <cokw>&lt;li&gt;</cokw><cokw>&lt;xsl:value-of</cokw> select=<costring>"model"</costring><cokw>/&gt;</cokw>, <cokw>&lt;xsl:value-of</cokw> select=<costring>"shop"</costring><cokw>/&gt;</cokw>,</codeline>
<codeline id="code.muenchian3.output" lineno="18" prefix="-">              <cokw>&lt;xsl:value-of</cokw> select=<costring>"price"</costring><cokw>/&gt;</cokw><cokw>&lt;/li&gt;</cokw> </codeline>
<codeline prefix="-">          <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="20">        <cokw>&lt;/ul&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;/xsl:for-each&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/store-models&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline prefix="-"><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location orderorder-2.pml@870 ?>

    
    <p>And the results are spiffin':</p>
    
    <figure id="fig.sort.twice">
      <title>Sorting on Two Fields</title>
      <imagedata border="yes" fileref="images/orderorder2/double-sort.png" width="65%"/>
    </figure>
    
    <p>As you can see in the beefed-up section on Specialized bikes, the models are sorted in alphabetical order, 
      but where the models have the same name, the results are further sorted by the numeric value of the prices.
      An excellent approach for comparison shopping to keep you away from those spreadsheet apps!
    </p>
    
     </sect1>
  <sect1>
    <title>What We've Done</title>
   <p>We've sliced and diced our content so many ways now, it's starting to look like last week's 
     leftover hash. We've rearranged flat lists, we've learned a couple of methods for grouping content,
   we've learned keys for selecting content, and we've learned how to sort our results into 
   satisfying patterns.
   </p>
    <p>We've spent three chapters learning how to manipulate the order of content, and it's time 
      to give ourselves a nice pat on the back.  This type of content manipulation is at the heart of what makes
    XSLT useful, and we've dealt with a big chunk of it.  Sure, there are a lot more complicated
    problems than what we've shown here, but the methods for handling most of those problems are
    variations on what we've learned here.
    </p>
    
    <p>So why not take a break and digest what you've learned.  Because when we get to the next 
      chapter on using and handling values, we're going to take XSLT to a whole different level.</p>
</sect1>
  

</chapter>
<?location values.pml@3 ?>

<chapter id="chap.values">
  <title>The Value of Values</title>
  <!-- <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>We need ways of handling values within the context of the transforms. Some values will be used
          internally to the stylesheet, while other values will be part of the output. Some values will be
          related to the structure of the source document, while other values will be more abstract, possibly
          passed into the stylesheet from other sources. The ability to manage these values will add power,
          subtlety, and new functions to our XSLT stylesheet arsenal. </p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <p>How to define and use variables, parameters, and value-related XSLT elements and functions. These
          will enable and enhance conditional controls like <xmltag>xsl:if</xmltag> and
          <xmltag>xsl:choose</xmltag>, as well as enabling controls based on position, size, content, and
          other value-based characteristics. </p>
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>You will be able to count things in the source document, create code that makes decisions based on
          conditions represented by values, and create multiple types of output from a single input file. You
          will also be able to create complex variables that take input from a variety of sources to create an
          output value.</p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>Now that we have some ways of handling values, we'll apply those and some other new mechanisms to
          the problems involved in manipulating textual content.</p>
      </dd>
    </dl>
  </storymap> -->

  <p>We've been dancing around a certain subject in these early chapters, and now it's time to get face to
    face with it: <emph>values</emph>, how they are handled in XSLT, and the kinds of things we can do with
    them. </p>

  <p>Every programming language worth its salt deals with values. We have to be able to count things,
    manipulate text, deal with dates, identify things---and values are how we do that. We've already seen
    values at work in a number of ways---we've seen variables being used in the <xmltag>xsl:variable</xmltag>
    instruction, we've seen numbers being used in XPath expressions, and we've used the text() function to get
    the text value of elements. We've dealt with these methods of handling values as part of other methods and
    solutions, but if we're going to have a thoroughgoing understanding of the XSLT toolset, we need to cover
    all the bases. </p>

  <p>That being said, this wouldn't be the solution-oriented guide of choice if we just listed the
    value-handling mechanisms and let it go at that. So we're going to take it a little further. We're going
    to look at a couple of other XSLT mechanisms that make use of values, and we're going to learn about a
    technique called <firstuse>recursion</firstuse>. The techniques we'll learn will be two forms of
    conditional control (<xmltag>xsl:if</xmltag> and <xmltag>xsl:choose</xmltag>), a re-usable, named template
    using the <xmltag>xsl:call-template</xmltag> instruction. We'll use conditional control and named
    templates as part of the technique of recursion, or recursive processing.</p>

  <p>And we'll see that the grease that keeps the gears going around will be values and the XSLT mechanisms
    that manage them. So let's dig in.</p>

  <sect1 id="sect1.value.value-types">
    <title>Value Types</title>

    <p>In <xref linkend="sect2.content.expressions"/>, we mentioned that there were four basic types of values
      in XSLT: numbers, strings, Boolean values, and nodes. Let's get a little more specific than that,
      because there are nuances hidden in these categories. Here's a breakdown on each of these value types. </p>

    <sect2>
      <title>Numbers</title>

      <p>Numbers are what you think they are---good old base 10 values represented by the Arabic numeric
        characters 0 through 9. In XSLT 1.0, numbers are usually recognized as numbers rather than as strings.
        (This isn't always the case in XSLT 2.0.)</p>
      <p>Still, in some cases where there may be issues with the data typing of a result, you can be sure that
        the result is treated as a number by using the <ic>number()</ic> function. Even if the argument of
        <ic>number()</ic> isn't really a number, it can usually convert it to something recognizable in the
        world of numbers.</p>
    </sect2>
    <sect2>
      <title>Strings</title>

      <p>We've seen strings aplenty in our earlier examples, so there's not much to talk about here.</p>

      <p>One thing we haven't talked about, though, is how to treat numbers like strings. That's because you
        don't really have to. If you apply a string-related function (like <ic>substring-before()</ic>) with a
        number as one or more of the arguments, XSLT gets it. The number gets treated like a common string.
        For example, if I have an XML tag <xmltag>bignum</xmltag>1234567890<xmltag close="yes">bignum</xmltag>
        and want to get artsy and replace the 3 with an E, I would match on <xmltag>bignum</xmltag> and use
        something like: </p>

<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before(.,3)"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;xsl:text&gt;</cokw>E<cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline><cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-after(.,3)"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location values.pml@97 ?>


      <p>Out pops the highly useful string 12E4567890, and we're in some kind of business.</p>
    </sect2>

    <sect2>
      <title>Boolean Values</title>

      <p>If you've studied logic or computer programming, you know that Boolean values means
        “true” and “false.” But what does that mean in XSLT terms?</p>
      <p>As we'll learn in the sections on <xmltag>xsl:if</xmltag> and <xmltag>xsl:choose</xmltag>, we
        sometimes need to check conditions with a <xmlattr>test</xmlattr> attribute. Or we may need to check a
        condition within an XPath expression. We may need to know, simply, whether a condition is logically
        true or false. But how do we check for trueness or falseness? What kind of value is
        “true,” and what kind is “false?”</p>
      <p>The funny thing about Boolean values is that the value is assigned to an object, but you don't see
        the value of the Boolean explicitly. The value of a Boolean object can be “true” or
        “false” (but never both at the same time, as far as anyone knows!), but you don't see that
        value explicitly. Instead, you have to test the object to know what Boolean value it has.</p>
      <p>In <xref linkend="sect2.content.expressions"/> we talked about relational operators that are used to
        create expressions that yield Boolean values. You can also test whether an object is true or false by
        using the <ic>boolean()</ic> function. For example, if we said <xmltag attrs="select=&quot;boolean(4 = 5)&quot;">xsl:value-of</xmltag>, we would get the string
        “false”. But “false” is just a string representing the Boolean value, it's not
        the value itself.</p>
      <p>To make the example a little muddier, what would happen if we said <xmltag attrs="select=&quot;boolean('false')&quot;">xsl:value-of</xmltag>. We would get the result
        “true”! That's because the string “false,” taken by itself, is not a
        zero-length string. So 'false' is true. (And people wonder why XSLT gets such a bad rap.)</p>
      <p>Besides using the <ic>boolean()</ic> function to test the truth-value of an object, we can also use
        the <ic>true()</ic> and <ic>false()</ic> functions to explicitly specify a Boolean value. Basically,
        the value of <ic>true()</ic> is a Boolean true value, and the value of <ic>false()</ic> is a Boolean
        false value. Maybe these two functions are so easy to make up for “false” being true. </p>
      <p>Here's a short guideline to how different types of XML objects are evaluated as true or false.</p>

      <ul>
        <li>
          <p>A positive zero, negative zero, or NaN is false; any other number is true.</p>
        </li>
        <li>
          <p>Any string longer than zero characters is true.</p>
        </li>
        <li>
          <p>Any node-set that is not empty is true.</p>
        </li>
        <li>
          <p>A Boolean true value is true, and a Boolean false value is false. (Goes without saying, I know,
            but there it is.)</p>
        </li>
      </ul>

    </sect2>

    <sect2>
      <title>Nodes</title>

      <p>Nodes are the usual suspects---you know, elements, attributes, text nodes, the root, comments,
        programming instructions, and namespaces. Nodes can be considered individually or as a group. Thinking
        about nodes as values, we usually think of a node-set, that is, a group of nodes.</p>

      <p>A node-set is usually created by the use of an XPath expression. We've seen XPath expressions in
        action before, and we've made use of the node-sets that get returned, so we don't need to explore that
        relationship much more. But what if we need to refer to the node-set many times? Do we need to write
        the XPath expression every time?</p>

      <p>It turns out that we can store a node-set in a variable and use the contents of 
        that variable wherever we need it. We'll see more about this usage of node-sets 
        when we get to <xref linkend="sect1.values.variables"/>. We'll see that we can use 
        variables for testing for the presence of nodes as well as for retrieving nodes on 
        a repeated basis.
      </p>
      
    </sect2>
  </sect1>

  <sect1 id="sect1.values.variables">
    <title>Variables</title>
    <author>More formal definition of variable, scope, uses of variables.</author>
    
    <p>We've used variables in previous examples, but we skirted over the definition of them while we concentrated on other things. 
      It turns out that we use variables all over the place in our stylesheets, so we should give them a little more attention.  
      And where we're going by the end of this chapter, we're going to need them.</p>
    
    <sect2>
      <title>The Dossier on Variables</title>
      <p>Let's begin with a quick run-down on the formalities, then talk a bit about what variables are used for. 
      Then we'll put them to work in a couple of interesting ways. (Like???)</p>
      
      <dl>
        <dt newline="yes"><xmltag>xsl:variable</xmltag></dt>
        <dd><p>The <xmltag>xsl:variable</xmltag> instruction defines a named symbol for holding and using values. 
         Once a value is defined for a variable within its given scope, that value is static until the variable's scope is released.</p>
          <p>Within the scope of the variable, the value can be retrieved by using a dollar sign ($) immediately followed by the variable name.
          The variable is usually retrieved in the context of an attribute of some kind.
          </p>
          <p>Here are the attributes that can be used with <xmltag>xsl:variable</xmltag>:</p>
          <table style="hlines">
            <thead>
              <col>Attribute</col>
              <col>Required?</col>
              <col>Function</col>
            </thead>
            <row>
              <col><p><xmlattr>name</xmlattr></p></col>
              <col><p>Yes</p></col>
              <col><p>Assigns a name to the variable.  This name will be used, preceded by a dollar sign ($), to retrieve the value stored in the variable.</p></col>
            </row>
            <row>
              <col><p><xmlattr>select</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This attribute takes an expression that specifies the value to be assigned to the variable.  
                If this attribute is not used to assign a value, the <xmltag>xsl:variable</xmltag>
              tag must enclose additional content to specify the value of the variable.
              If this attribute is used, the <xmltag>xsl:variable</xmltag> tag must be empty.</p></col>
            </row>
          </table>
        </dd>
      </dl>
      
      <p>But that's only a part of the story. The use of variables entails a few other interesting tidbits:</p>
      
      <ul>
        <li><p>Variables can contain any of the data types defined in <xref linkend="sect1.value.value-types"/>. 
          The data type of the value will condition how you retrieve and use the value. For example, if the variable
          contains a string and you try to use it as you would use a node-set, you will probably get an error message.</p></li>
        
        <li><p>If you define a variable but don't have anything after it in the template, 
        you may get a warning from the XSLT processor to the effect that the variable isn't actually doing anything.
        It won't stop anything, but you might want to check whether you meant to do something with it.
        </p></li>
        
        <li><p>You can define variables within variables to any level, but I'm not sure there's a point. 
        Anything defined inside a variable can also be defined outside the variable.</p></li>
        
        <li><p>A variable can only be used within its scope.  The scope is global if it is defined as a top-level element 
        in a stylesheet, and the scope is local if it is defined within a template.
        A global variable can be used anywhere in the stylesheet, while a local variable can only be used in the template where it is defined.  
        (We'll cover a way to get around some of that limitation with <xmltag>xsl:param</xmltag> later in this chapter.)</p></li>
        
        <li><p>If the variable is globally defined, its placement in the stylesheet does not matter.  
          If it is defined in a template, the variable can only be used following its definition.</p></li>

        <li><p>In addition to scoping within templates, the <xmltag>xsl:for-each</xmltag> tag imposes its own scope.  You cannot pass the value of a variable defined inside <xmltag>xsl:for-each</xmltag>
          to anything outside the <xmltag>xsl:for-each</xmltag>. </p>
          <p>If you think you need to capture values from a repetitive process, a variable inside <xmltag>xsl:for-each</xmltag> may not be the answer to your problem.  Maybe you could put the
          <xmltag>xsl:for-each</xmltag> inside the variable, in which case the variable would contain all of the data output by the entire <xmltag>xsl:for-each</xmltag> operation. You might consider
            using <xmltag>xsl:apply-templates</xmltag> with the same <xmlattr>select</xmlattr> statement as the <xmltag>xsl:for-each</xmltag> (remembering to create the appropriate template to go with it).
            Or you might need a recursive process, which we will describe in <xref linkend="sect1.values.recursion"/> later in this chapter.
        </p></li>
        </ul>
      
      <p>And that's the book on variables---a shifty sort of character with questionable values. In fact, we'll question those values a lot once we get to the <xmlattr>test</xmlattr> attribute
      in <xmltag>xsl:when</xmltag> and <xmltag>xsl:if</xmltag>. But let's take a look at examples of <xmltag>xsl:variable</xmltag> in its various guises before we take on conditional processing.</p>
    </sect2>

    <sect2>
      <title>Variables in Action</title>
      <p>One use for a variable is to give it the value of something that we can't know until we are processing the XML source, then to take some action based on the variable.
        For example, suppose our XML consists of a mixture of elements that need to be number, and both the numbering and the indent level will reflect the depth of the 
        element within a hierarchy of these mixed elements. Every level needs to be indented another half an inch, and every level gets a period and its own number added to the number of its parent.
        That may sound a little abstract, so here's an example:     
      </p>
      
      <figure id="fig.task-steps">
        <title>A Mixture of Task and Steps</title>
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;task</cokw> id=<costring>"1"</costring><cokw>&gt;</cokw>Build a robot.</codeline>
<codeline>  <cokw>&lt;step&gt;</cokw>Draw a plan.<cokw>&lt;/step&gt;</cokw></codeline>
<codeline>  <cokw>&lt;task&gt;</cokw>Implement the plan.</codeline>
<codeline>    <cokw>&lt;steps&gt;</cokw></codeline>
<codeline>      <cokw>&lt;step&gt;</cokw>Build the hardware.<cokw>&lt;/step&gt;</cokw></codeline>
<codeline>      <cokw>&lt;step&gt;</cokw>Write the software.<cokw>&lt;/step&gt;</cokw></codeline>
<codeline>      <cokw>&lt;step&gt;</cokw>Test the robot.</codeline>
<codeline>          <cokw>&lt;steps&gt;</cokw></codeline>
<codeline>            <cokw>&lt;step&gt;</cokw>Tell it to go.<cokw>&lt;/step&gt;</cokw></codeline>
<codeline>            <cokw>&lt;step&gt;</cokw>Tell it to stop.<cokw>&lt;/step&gt;</cokw></codeline>
<codeline>          <cokw>&lt;/steps&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/step&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/steps&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/task&gt;</cokw></codeline>
<codeline>  <cokw>&lt;task&gt;</cokw>Take over the world</codeline>
<codeline>    <cokw>&lt;task&gt;</cokw>Repeat task <cokw>&lt;xref</cokw> href=<costring>"1"</costring><cokw>/&gt;</cokw> 6 billion times.<cokw>&lt;/task&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/task&gt;</cokw></codeline>
<codeline><cokw>&lt;/task&gt;</cokw></codeline>
</processedcode>
<?location values.pml@283 ?>

      </figure>
      <p>
        As you can see, this XML is a little gnarly. For us to get the level of the element (either <xmltag>task</xmltag> or <xmltag>step</xmltag>), we're going to have to count ancestors.  Our variable to hold the
        value of the level is going to look like this:
      </p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:variable</cokw> name=<costring>"tag-level"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw></codeline>
<codeline>  select=<costring>"count(ancestor-or-self::*[name() = 'task' or name() = 'step']"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:variable&gt;</cokw></codeline>
</processedcode>
<?location values.pml@297 ?>

      
      <p>Could we have put that <ic>count()</ic> function into the <xmlattr>select</xmlattr> statement of the <xmltag>xsl:variable</xmltag>?  Yes, and it would have made no difference, it would work either way. 
        Sometimes you will need to put the expression for the value into the contents of the <xmltag>xsl:variable</xmltag> tag, because it can become very complicated, and I generally like doing things only one way as much as possible. 
        But let's not rule out the possibility of the other mechanism.  And remember, when creating node-sets, the <xmlattr>select</xmlattr> attribute is the way to go.
      </p>
      
  
      <p>Now when we want to use the level number we just ask nicely by placing the <ic>$tag-level</ic> in the appropriate place.  For example, to get the half-inch spacing we're looking for, we might create the following
      attribute:</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:attribute</cokw> name=<costring>"margin-left"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"concat( ($tag-level * 0.5) ,'in' "</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:attribute&gt;</cokw></codeline>
</processedcode>
<?location values.pml@314 ?>

      
      <p>Here we multiply the tag level times 0.5 to get the amount of indentation, then we concatenate the string with the unit of measurement <ic>in</ic> (inches) 
        to create the value for the <xmlattr>margin-left</xmlattr> attribute.</p>
      
       <p>What about the numbering we talked about for the elements?  We want the first-level elements to be numbered 1, 2, 3, the second-level elements 
        to be numbered 1.1, 1.2, 1.3 and 2.1, 2.2, 2.3, and so forth, as many levels down as we need.  We could probably work that all out with our <ic>tag-level</ic>
       variable and the <ic>count()</ic> function, but that approach would quickly bog down in repetition and long XPath expressions.  We would have to count elements at our current level,
         then count the number of elements preceding and including the parent
       element, taking into account that we don't want to count the <xmltag>steps</xmltag> tag at all---very messy.</p>
      
      <p>I'm going to whet your appetite by telling you we can avoid that mess very easily with
       a neat tag for numbering called, oddly enough, <xmltag>xsl:number</xmltag>.  It's a powerful way to generate number streams in a document. 
        But we're not going to get to it just yet, although we will do it before the end of this chapter.  You're going to like it.</p>
      
     <p>At the moment we need to continue our treatment of <xmltag>xsl:variable</xmltag> with conditional processing, and that's going to be fun enough for now.</p>
      
    </sect2>
    
    <sect2>
      <title>Variables Controlling Conditional Structures</title>
      
      <p>XSLT includes two instructions for making decisions about processing: <xmltag>xsl:if</xmltag> and <xmltag>xsl:choose</xmltag> 
        with its child elements <xmltag>xsl:when</xmltag> and <xmltag>xsl:otherwise</xmltag>.  The heart of these instructions is the <xmlattr>text</xmlattr> attribute,
      which specifies the conditions(s) under which to execute the contents of the tags.  Once again, let's get a quick formal rundown on these tags, then let's put them to work
      in some examples.</p>
      
      <dl>
        <dt><xmltag>xsl:if</xmltag></dt>
        <dd><p>This tag is used to wrap around content that may or may not be executed. The content of the <xmlattr>test</xmlattr> attribute, evaluated in the current context,
        determines whether the contents will be executed.</p>
          
          <p>Content in the <xmltag>xsl:if</xmltag> can be text, tags, and XSLT instructions in any combination. </p>
          
          <table style="hlines">
            <thead>
              <col>Attribute</col>
              <col>Required?</col>
              <col>Function</col>
            </thead>
            <row>
              <col><p><xmlattr>test</xmlattr></p></col>
              <col><p>Yes</p></col>
              <col><p>Contains an expression that evaluates to a boolean value. If the boolean value is <ic>true()</ic>, the contents of the <xmltag>xsl:if</xmltag> tag
              are executed. Otherwise, the contents of the tag are ignored.</p></col>
            </row>
           </table>
        </dd>
      </dl>
      
      <dl>
        <dt><xmltag>xsl:choose</xmltag></dt>
        <dd><p>This tag can only contain two types of instructions: <xmltag>xsl:when</xmltag> and <xmltag>xsl:otherwise</xmltag>. It also does not have any significant attributes.
          The purpose of <xmltag>xsl:choose</xmltag> is to hold one or more <xmltag>xsl:when</xmltag> tags and, optionally, a single <xmltag>xsl:otherwise</xmltag>.
        </p>
          <p>Each <xmltag>xsl:when</xmltag> functions like the <xmltag>xsl:if</xmltag> tag, containing a <xmlattr>test</xmlattr> attribute that may or may not evaluate to <ic>true()</ic>.
          If more than one <xmltag>xsl:when</xmltag> tag exists in the <xmltag>xsl:choose</xmltag>, the first one that evaluates to <ic>true()</ic> has its contents executed, and 
            the remainder of the tags are ignored.  If none of the <xmltag>xsl:when</xmltag> tags contains a condition that is true, and there is an <xmltag>xsl:otherwise</xmltag>,
            the contents of the <xmltag>xsl:otherwise</xmltag> will be executed.</p>
          <p>If none of the <xmltag>xsl:when</xmltag> tags are true and there is no <xmltag>xsl:otherwise</xmltag>, nothing in the <xmltag>xsl:choose</xmltag> tag is executed, and the processor 
            goes along to the next instruction as if nothing had happened. “These are not the droids you are looking for!”
          </p>
        </dd>
      </dl>
      
      <dl>
        <dt><xmltag>xsl:when</xmltag></dt>
        <dd><p> The purpose of <xmltag>xsl:when</xmltag> is to allow for the choice of a single option out of multiple options instead of just one. Otherwise, this tag works like the <xmltag>xsl:if</xmltag> tag.
          The <xmlattr>test</xmlattr> attribute fulfills exactly the same function, and the contents of the <xmltag>xsl:when</xmltag>
          are executed only when the <xmlattr>test</xmlattr> attribute is true.  The major difference between this tag and <xmltag>xsl:if</xmltag> is that this tag  exists only inside <xmltag>xsl:choose</xmltag>. 
        </p>
          <p>Each <xmltag>xsl:when</xmltag> contains a <xmlattr>test</xmlattr> attribute that may or may not evaluate to <ic>true()</ic>.
            If more than one <xmltag>xsl:when</xmltag> tag exists in the <xmltag>xsl:choose</xmltag>, the first one that evaluates to <ic>true()</ic> has its contents executed, and 
            the remainder of the tags are ignored.  If none of the <xmltag>xsl:when</xmltag> tags contains a condition that is true, and there is an <xmltag>xsl:otherwise</xmltag>,
            the contents of the <xmltag>xsl:otherwise</xmltag> will be executed.</p>
          
          <p>If none of the <xmltag>xsl:when</xmltag> tags are true and there is no <xmltag>xsl:otherwise</xmltag>, nothing in the <xmltag>xsl:choose</xmltag> tag is executed, and the processor 
            goes along to the next instruction as if nothing had happened. “These are not the droids you are looking for!”
          </p>
        </dd>
      </dl>
      
      <dl>
        <dt><xmltag>xsl:otherwise</xmltag></dt>
        <dd><p>The lowly <xmltag>xsl:otherwise</xmltag> tag does not get much choice in the conditional processing party. It can only appear once in the <xmltag>xsl:choose</xmltag>
        tag, and only after all of the <xmltag>xsl:when</xmltag> tags. It only has its contents executed if none of the <xmltag>xsl:when</xmltag> tags find anything of interest.
        At parties, it babbles on and on about Charles Dickens and stateless machines, and it gets to the beer keg only after it's down to the suds.  (Okay, that last part may be a stretch.)
        </p>
          <p>It also has no attributes. However, like the <xmltag>xsl:if</xmltag> and <xmltag>xsl:when</xmltag> tags, it can contain any sort of content for execution.  The <xmltag>xsl:otherwise</xmltag>
          tag is useful for providing fallback behavior when you aren't sure the conditions in the <xmltag>xsl:when</xmltag> tags are going to catch every case.
          </p>
        </dd>
      </dl>
      
      <p>But we're really here to talk about variables, so let's get a sense of what these guys can do for us by putting them to work on the XML sample give in <xref linkend="fig.task-steps"/>.</p>
      
      <p>First let's set ourselves a reasonable task. For each tag, we want to output the same number of asterisks as there are levels, plus the text, as we see in some forms of wiki markup. If that's all we
        need to do, we don't even need a separate template for the different elements in the XML. See what you can do with the problem first---define a variable that contains the value of the element's level,
        then use that variable in an <xmltag>xsl:choose</xmltag> instruction.
      </p>
      
      <p>I know, you can't stand the tension.  So here's what I've got:</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"*"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:variable</cokw> name=<costring>"tag-level"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw></codeline>
<codeline>       select=<costring>"count(ancestor::*[name() = 'task' or name() = 'step']) + 1"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:choose&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:when</cokw> test=<costring>"$tag-level = 1"</costring><cokw>&gt;</cokw>*<cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:when</cokw> test=<costring>"$tag-level = 2"</costring><cokw>&gt;</cokw>**<cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:when</cokw> test=<costring>"$tag-level = 3"</costring><cokw>&gt;</cokw>***<cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:when</cokw> test=<costring>"$tag-level = 4"</costring><cokw>&gt;</cokw>****<cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:choose&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:text&gt;</cokw>  <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"text()"</costring><cokw>&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@434 ?>

      
      <p>In this example we only want the characters to appear for the <xmltag>task</xmltag> or <xmltag>step</xmltag> tags, so we don't put in an <xmltag>xsl:otherwise</xmltag>
      instruction to catch any outliers. We add a couple of spaces with the <xmltag>xsl:text</xmltag> instruction, then we output the text of the tag.  The main point, though, is that 
      we've used our <ic>tag-level</ic> variable to good effect, selecting the correct number of asterisks to go with our text.</p>
        
      <p>We might also create a variable with a text string in it. One good use for a text string is when our XSLT needs to supply hard-coded text.  The problem is, you never know
      what language that text might need to appear in---the XML being processed might contain any sort of language, not just English.  If you need to supply a “NOTE” 
      or “WARNING” label to go with that text, you might need to make arrangements for multilingual processing.  One way to do that is to create a set of tags with
      a <xmlattr>language</xmlattr> attribute, so the tags contained the same word, but in different languages, like so:
      </p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;terms&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> id=<costring>"note"</costring> language=<costring>"de"</costring><cokw>&gt;</cokw>Hinweis<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> word=<costring>"note"</costring> language=<costring>"en"</costring><cokw>&gt;</cokw>Note<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> word=<costring>"note"</costring> language=<costring>"es"</costring><cokw>&gt;</cokw>Nota<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> word=<costring>"note"</costring> language=<costring>"fi"</costring><cokw>&gt;</cokw>Huomaa<cokw>&lt;/term&gt;</cokw></codeline>
<codeline>  <cokw>&lt;term</cokw> word=<costring>"note"</costring> language=<costring>"fr"</costring><cokw>&gt;</cokw>Remarque<cokw>&lt;/term&gt;</cokw></codeline>
<codeline><cokw>&lt;/terms&gt;</cokw></codeline>
</processedcode>
<?location values.pml@456 ?>

      
      <p>With this markup tucked away somewhere we can get to it during processing, we can set up a variable to bring in the correct form of the label.
      Let's say that the language we'll be processing is declared in an attribute in the root node of our XML document, something like, for example, <xmltag attrs="language=&quot;fi&quot;">document</xmltag>.
        Now we can set up the variable to bring in our correct note label when we match on a <xmltag>note</xmltag> tag, as in the following template:
      </p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"note"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:variable</cokw> name=<costring>"current-language"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"/document/@language"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:variable</cokw> name=<costring>"note-text"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"//terms/term[@language = $current-language]"</costring></codeline>
<codeline>  &lt;/xsl:variable<cokw>&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"$note-text"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:text&gt;</cokw>: <cokw>&lt;/xsl:text&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@479 ?>

      
      <p>In this arrangement, the use of the <ic>note-text</ic> variable gives us a level of abstraction from the actual wording. 
      All we need to do is send a little Finnish XML through the processor, and, sure enough, out comes our Huomaa.</p>
      
      <p>In this example we've used the variable for <ic>language</ic> within the definition of the variable for <ic>note-text</ic>. 
        We'll find this type of chaining of variables to be quite useful for handling complex situations. Breaking the problem down into bits and handling it with a long series of variables can be useful and necessary; however,
      we'll also need to check the variables at every step to make sure we're getting the expected values.  This sort of situation will be dealt with in <xref linkend="chap.troubleshooting"/>. </p>
      
      <p>We've now seen variables at work with numbers and text strings. The purposes they're put to and the expressions by which we create their values are as endless as our needs and imaginations want them to be.
        We'll find that we can also use variables with node-sets in a variety of ways.  The following two sections cover two of the more common uses of node-sets in variables.</p>
      
    </sect2>
    
    <sect2>
      <title>Testing for Nodes by Using a Variable</title>
      
      <p>As we've seen, conditional processing instructions allow us to test variables by means of expressions that evaluate to true or false.  One use we can make of this testing is to
      make choices based on the presence or absence of elements, attributes, or attribute values.  For example, we might not want to create an element in the output until we know that 
      the source includes an element or group of elements with a given attribute and attribute value. If this is a test that we need to perform many times, it would be helpful to capture the set of elements to be tested 
      in a variable one time, then perform testing on that variable many times.
      </p>
      
      <p>Let's say we need to feed some XML to a pharmaceutical label processing system, but there may be issues with confidentiality,
        relevance, or sheer data quantity in our source.  The following is an example of the type of XML we might need to handle. 
        It contains a section under the <xmltag>structure</xmltag> element that indicates the structure by which the content is related, then it contains another area consisting of one or more 
        (possibly dozens or hundres) of <xmltag>language</xmltag> tags that provide the language-specific contents for the labels, but in a flat structure for ease of translation. </p>
  
      <figure id="fig.labeling.xml">
        <title>XML Source for Labeling Pharmaceuticals</title>
<processedcode language="xml" showname="values/labeling.xml" style="normal" url="values/labeling.xml">
<codeline>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</codeline>
<codeline>&lt;?xml-stylesheet type="text/xsl" href="labeling.xsl"?&gt;</codeline>
<codeline><cokw>&lt;labels&gt;</cokw></codeline>
<codeline>  <cokw>&lt;structure</cokw> id=<costring>"label_1"</costring> name=<costring>"bottle"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;label&gt;</cokw></codeline>
<codeline>      <cokw>&lt;substance&gt;</cokw></codeline>
<codeline>        <cokw>&lt;name</cokw> ref_id=<costring>"01"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;form</cokw> ref_id=<costring>"02"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;dose</cokw> ref_id=<costring>"03"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/substance&gt;</cokw></codeline>
<codeline>      <cokw>&lt;packaging&gt;</cokw></codeline>
<codeline>        <cokw>&lt;date</cokw> ref_id=<costring>"06"</costring><cokw>/&gt;</cokw></codeline>
<codeline>        <cokw>&lt;type</cokw> ref_id=<costring>"07"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/packaging&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/label&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/structure&gt;</cokw></codeline>
<codeline>  <cokw>&lt;language</cokw> lang=<costring>"en"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-01"</costring><cokw>&gt;</cokw>Rosuvastatin<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-02"</costring><cokw>&gt;</cokw>film-coated tablets<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-03"</costring><cokw>&gt;</cokw>10mg<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-06"</costring><cokw>&gt;</cokw>11 December 2014<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-07"</costring><cokw>&gt;</cokw>OUTER CARTON BOTTLE AND LABEL<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"en-16"</costring><cokw>&gt;</cokw>Film-coated tablet.<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/language&gt;</cokw></codeline>
<codeline>  <cokw>&lt;language</cokw> lang=<costring>"fr"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-01"</costring><cokw>&gt;</cokw>Rosuvastatin<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-02"</costring><cokw>&gt;</cokw>comprimés pelliculés<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-03"</costring><cokw>&gt;</cokw>10mg<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-06"</costring><cokw>&gt;</cokw>11 Décembre 2014<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-07"</costring><cokw>&gt;</cokw>EMBALLAGE EXTERIEUR (ETUI FLACON)</codeline>
<codeline>      ET ETIQUETTE FLACON<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"fr-16"</costring><cokw>&gt;</cokw>Comprimé pelliculé.<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/language&gt;</cokw></codeline>
<codeline>  <cokw>&lt;language</cokw> lang=<costring>"de"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"de-01"</costring><cokw>&gt;</cokw>Rosuvastatin<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"de-02"</costring><cokw>&gt;</cokw>Filmtabletten<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"de-03"</costring><cokw>&gt;</cokw>10mg<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"de-06"</costring><cokw>&gt;</cokw>11. Dezember 2014<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;instance</cokw> id=<costring>"de-07"</costring><cokw>&gt;</cokw>FALTSCHACHTEL FLASCHE UND</codeline>
<codeline>      FLASCHENETIKETT<cokw>&lt;/instance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;template</cokw> id=<costring>"de16"</costring><cokw>&gt;</cokw>Filmtablette.<cokw>&lt;/template&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/language&gt;</cokw></codeline>
<codeline><cokw>&lt;/labels&gt;</cokw></codeline>
</processedcode>
<?location values.pml@509 ?>

      </figure>

      <p>When we transfer the file over to the processor, we may want to omit one or more elements within each <xmltag>language</xmltag> element.  In this case, we only want to copy over the elements that 
        have an <xmlattr>id</xmlattr> number that corresponds to a <xmlattr>ref_id</xmlattr> in the <xmltag>structure</xmltag> part of the XML.  We may not know ahead of time which items will be missing
        from the structure, so we can create a variable to capture the structure, then test that variable each time we process an <xmltag>instance</xmltag>. 
        Here's how the template for <xmltag>instance would look</xmltag>:</p>
      
<processedcode language="xml" showname="values/test-node-in-variable.xsl" style="normal" url="values/test-node-in-variable.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline calloutno="1" id="code.test-node.global-variable">  <cokw>&lt;xsl:variable</cokw> name=<costring>"structure"</costring> select=<costring>"/labels/structure"</costring><cokw>/&gt;</cokw> </codeline>
<codeline/>
<codeline calloutno="2" id="code.test-node.identity-transform">  <cokw>&lt;xsl:template</cokw> match=<costring>"/ | * | @*"</costring><cokw>&gt;</cokw>  </codeline>
<codeline>    <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"</costring> <costring>* | @*"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"instance"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:variable</cokw> name=<costring>"instance_id"</costring> select=<costring>"@id"</costring><cokw>/&gt;</cokw></codeline>
<codeline calloutno="3" id="code.test-node.test-variable">    <cokw>&lt;xsl:if</cokw> test=<costring>"$structure//*[@ref_id = $instance_id]"</costring><cokw>&gt;</cokw> </codeline>
<codeline>      <cokw>&lt;xsl:copy&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/xsl:copy&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:if&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location values.pml@517 ?>

     
      <p>You'll notice a couple of interesting new facts about <coref linkend="code.test-node.global-variable"/>. For one thing, it's not in a template!
        Is that even legal? Yes---in fact, in this case, it's also desirable.  We want to be able to use the variable in any template, so by defining it outside
        of a template, the variable now has <firstuse>global scope</firstuse>. When we define a variable inside a template, 
        it can only be used inside that template, which means it has <firstuse>local scope</firstuse>.</p>
      
      <p>To define a global variable, we have to remember that we are not yet inside the root of the document, 
      so any XPath expression first has to match on the root, as we've done here. </p>
      
      <p>Next, in <coref linkend="code.test-node.identity-transform"/>, we see our old friend the identity
      transform.  We're going to copy everything from the source---except the <xmltag>instance</xmltag> tags we 
      filter out in the next template.</p>
      
      <p>And finally, in the template for <xmltag>instance</xmltag>, we get the test in <coref linkend="code.test-node.test-variable"/>.
      Here we compare the <xmlattr>id</xmlattr> attribute of the current <xmltag>instance</xmltag> with the all the <xmlattr>ref_id</xmlattr> 
        attributes stored in the node-set in our <ic>structure</ic> variable. To retrieve the value of the variable,
        we have used the variable name preceded by $, as usual. Then we add a slash (or in this case a double slash 
        so we can cut to the chase) to start working our way down from the root of the node-set to the nodes we're 
        interested in.  Since several types of elements may have a <xmlattr>ref_id</xmlattr>, we use a wild-card (*) 
        for the node of interest, then we put our comparison expression in the predicate. If an <xmltag>instance</xmltag>
        doesn't have an element with a <xmlattr>ref_id</xmlattr> that corresponds to its <xmlattr>id</xmlattr>, we don't copy it.
      </p>
      
      <joeasks>
        <title>Why the <xmlattr>select</xmlattr> attribute in the variable for the node-set?</title>
        
        <p>One interesting aspect of <coref linkend="code.test-node.global-variable"/> is that we've used the <xmlattr>select</xmlattr> attribute to select
          the node-set for us.  Why?  It's complicated.  The short story is that if we used <xmltag>xsl:value-of</xmltag>, it would only give us the text values,
          and if we used <xmltag>xsl:copy-of</xmltag> or <xmltag>xsl:apply-templates</xmltag>, it would give us an aggravating type of data called a <firstuse>result tree fragment</firstuse>. A result tree fragment
          is kind of like a node-set, except that it can't be accessed by XPath expressions, which makes it fairly useless in XSLT 1.0.  In fact, it was so useless that by XSLT 2.0 it disappeared, so there are only
          node-sets.</p>
        
        <p>Result tree fragments can be accessed by XSLT extensions, but there's no guarantee that a browser is going to support the extension.</p>
        
        <p>If you're programming XSLT for browsers and stuck with XSLT 1.0, it's best just to pretend that result tree fragments don't exist. 
          And they won't exist, unless you happen to create them.</p>
      </joeasks>
      
      <p>In addition to testing for nodes in a variable with a node-set, we can also retrieve values, as we'll see in the next section.</p>
        
    </sect2>
    
    <sect2>
      <title>Retrieving Nodes from a Node-Set Stored in a Variable</title>
            
      <p>We've seen that when we want to re-use a node-set many times, placing it in a variable makes sense. 
        And we can retrieve the nodes in the variable much the same way we test them.  To check it out, we'll re-use 
        the example XML we set up in <xref linkend="fig.labeling.xml"/>.</p>
      
      <p>This time we actually want to populate the set of nodes in the <xmltag>structrue</xmltag> section
        with the corresponding text in each <xmltag>language</xmltag> section. We could do this a couple of different
      ways.  In one case, we could start by processing all the elements in the <xmltag>structure</xmltag> section, repeating the processing once for each
      <xmltag>language</xmltag> section. Or we could put the elements in the <xmltag>structure</xmltag> section into a variable, then process each <xmltag>language</xmltag>
        tag, using the elements from the <xmltag>structure</xmltag> tag where we need them.</p>
      
      <p>The advantage of the second method is that by creating the node-set variable, we can reduce the number of times the
        XSLT processor has to evaluate an XPath expression to retrieve content for each of the elements in <xmltag>structure</xmltag>. 
        Let's check it out:
      </p>
       
<processedcode language="xml" showname="values/labeling.xsl" style="normal" url="values/labeling.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring><cokw>&gt;</cokw></codeline>
<codeline/>
<codeline/>
<codeline calloutno="1" id="code.labeling.global-variable">  <cokw>&lt;xsl:variable</cokw> name=<costring>"structure"</costring> select=<costring>"/labels/structure"</costring><cokw>/&gt;</cokw> </codeline>
<codeline/>
<codeline calloutno="2" id="code.labeling.match-labels">  <cokw>&lt;xsl:template</cokw> match=<costring>"/labels"</costring><cokw>&gt;</cokw> </codeline>
<codeline>    <cokw>&lt;labels&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"language"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/labels&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"language"</costring><cokw>&gt;</cokw></codeline>
<codeline calloutno="3" id="code.labeling.attribute-value-template">    <cokw>&lt;label</cokw> language=<costring>"{@lang}"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;substance&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:apply-templates</cokw></codeline>
<codeline>          select=<costring>"*[contains(@id,'01')</costring></codeline>
<codeline>          <costring>or contains(@id,'02')</costring></codeline>
<codeline calloutno="4" id="code.labeling.match-3-elements">          <costring>or contains(@id,'03')]"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/substance&gt;</cokw></codeline>
<codeline>      <cokw>&lt;packaging&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"*[contains(@id,'06')</costring></codeline>
<codeline calloutno="5" id="code.labeling.match-2-elements">          <costring>or contains(@id,'07')]"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/packaging&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/label&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"instance"</costring><cokw>&gt;</cokw></codeline>
<codeline calloutno="6" id="code.labeling.ref-id-variable">    <cokw>&lt;xsl:variable</cokw> name=<costring>"ref_id"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-after(@id,'-')"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline/>
<codeline calloutno="7" id="code.labeling.element-name-variable">    <cokw>&lt;xsl:variable</cokw> name=<costring>"element_name"</costring><cokw>&gt;</cokw></codeline>
<codeline calloutno="8" id="code.labeling.use-node-set">      <cokw>&lt;xsl:value-of</cokw> select=<costring>"name($structure//*[@ref_id = $ref_id])"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:variable&gt;</cokw></codeline>
<codeline/>
<codeline calloutno="9" id="code.labeling.create-output-element">    <cokw>&lt;xsl:element</cokw> name=<costring>"{$element_name}"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:element&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location values.pml@578 ?>

      
      <p>The two lines to pay attention to are <coref linkend="code.labeling.global-variable"/> and <coref linkend="code.labeling.use-node-set"/>. In <coref linkend="code.labeling.global-variable"/> we define
        the <ic>structure</ic> variable that selects the <xmltag>structure</xmltag> element in the XML. When
        we select this element, we get that element and all its contents (elements, attributes, text, the
        works) in the variable.</p>
      
       
      <p>When we get to line <coref linkend="code.labeling.use-node-set"/>, we need to make use of our node-set. We want to create an element for each <xmltag>instance</xmltag> tag that corresponds
        to the <xmlattr>id</xmlattr> value of the <xmltag>instance</xmltag>. 
        We put the <ic>$structure</ic> variable into the <ic>name()</ic> function, and we add a //* with a predicate to the end of <ic>$structure</ic> to find the element that has the same <xmlattr>id</xmlattr>
        as the <xmltag>instance</xmltag> tag.  The <ic>name()</ic> function returns the name of that tag.   Since we've placed the element name in the variable at <coref linkend="code.labeling.element-name-variable"/>,
        we use that variable in the attribute value template at line <coref linkend="code.labeling.create-output-element"/>.  (Remember attribute value templates in <xref linkend="sect1.addingelements"/>?)
      </p>
      
      <p>The result is a handsome lineup of XML like the partial example here:</p>
      
<processedcode language="xml" showname="values/labeling-output.xml" style="normal" url="values/labeling-output.xml">
<codeline><cokw>&lt;labels&gt;</cokw></codeline>
<codeline>  <cokw>&lt;label</cokw> language=<costring>"en"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;substance&gt;</cokw></codeline>
<codeline>      <cokw>&lt;name&gt;</cokw>Rosuvastatin<cokw>&lt;/name&gt;</cokw></codeline>
<codeline>      <cokw>&lt;form&gt;</cokw>film-coated tablets<cokw>&lt;/form&gt;</cokw></codeline>
<codeline>      <cokw>&lt;dose&gt;</cokw>10mg<cokw>&lt;/dose&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/substance&gt;</cokw></codeline>
<codeline>    <cokw>&lt;packaging&gt;</cokw></codeline>
<codeline>      <cokw>&lt;date&gt;</cokw>11 December 2014<cokw>&lt;/date&gt;</cokw></codeline>
<codeline>      <cokw>&lt;type&gt;</cokw>OUTER CARTON BOTTLE AND LABEL<cokw>&lt;/type&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/packaging&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/label&gt;</cokw></codeline>
<codeline> ...</codeline>
<codeline><cokw>&lt;/labels&gt;</cokw></codeline>
</processedcode>
<?location values.pml@596 ?>

      
      <p>Node-sets in variables can take a little fidgeting to get used to them, but it sure beats writing out
        long XPath expressions when you need to use the same one over and over. </p>
    </sect2>      
    

  </sect1>
  
  <sect1>
    <title>Parameters and <xmltag>xsl:call-template</xmltag></title>
    <!-- <p>definition, scope, usage in templates.</p>
     <p>Talk about passing in parameters via the command line. Reference Stylesheets chapter for how to
     structure stylesheets to take advantage of parameters.</p> -->
    
    <p>We've talked a little about how variables have scope. Variables defined within a template are only valid for use within that template, which is kind of a pain if you've gone to the trouble to
    set up a complicate set of XSLT for a variable and you'd like to use it elsewhere.</p>
    
    <p>In this section, we're going to see how to use the values from variables (and other sources) in templates other than where they are defined. There are still some limitations on where the values can be used,
    but it adds flexibility and re-usability to our use of templates. </p>
    
    <p>The mechanism we'll use to pass values out of and into templates is called a <firstuse>parameter</firstuse>. Parameters are a little bit like variables in that they contain values (all sorts), but they are
      a bit different in that they can be used for the purpose of passing values between templates.  
    </p>
    
    <p>Speaking of flexibility and re-use, we'll also learn a new way of invoking templates in order to re-use our XSLT functionality.  The new invocation method is the <xmltag>xsl:call-templates</xmltag> instruction.
    With it, we will explicitly call a template to be used within another template. </p>
    
    <p>Eventually, we will see that the use of parameters and called templates are essential to the final goal of this chapter, which is to learn how to do recursive processing.</p>
    
    <sect2>
      <title>Parameters</title>
      
      <p>Parameters, as we said, are similar to variables.  In fact, you could define them and use them exactly the same way, if you'd like:</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:variable</cokw> name=<costring>"language"</costring> select=<costring>"/labels/language/@lang"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline>or</codeline>
<codeline/>
<codeline><cokw>&lt;xsl:param</cokw> name=<costring>"language"</costring> select=<costring>"/labels/language/@lang"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location values.pml@639 ?>

      
      <p>And you would invoke them both the same way:</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;p&gt;</cokw>The language we will be learning today is <cokw>&lt;xsl:value-of</cokw> select=<costring>"$language"</costring><cokw>/&gt;</cokw><cokw>&lt;/p&gt;</cokw></codeline>
</processedcode>
<?location values.pml@647 ?>

      
      <p>In fact, their definition and usage are so similar, giving them both the same name in the same scope would make our XSLT invalid.</p>
      
      <p>If they're so similar, what's the point of <xmltag>xsl:param</xmltag>?  As we mentioned, parameters do something that variables can't do, which is to pass their values between templates.
        When a new template is invoked from the current template, values can be passed from the current template to the next template by means of parameters.  To do this, though, we need to use
        two different instructions.  One is the <xmltag>xsl:with-param</xmltag> instruction in the <emph>invoking</emph> template, the other is the <xmltag>xsl:param</xmltag> instruction in the <emph>invoked</emph>
        template.
      </p>
      
      <p>Here's an example of how it works. Suppose we've worked out an indent level for a mixed list, and all the items within the list are going to need the information about that indent. We may have no idea
      what sorts of things are in our list, although we have templates for anything that might be possible. We need to pass along our hard-won indent information to any template that might need it.  As we see in the following
      code, we can place that information in an <xmltag>xsl:with-param</xmltag> tag.  The <xmltag>xsl:with-param</xmltag> goes within an <xmltag>xsl:apply-templates</xmltag> or <xmltag>xsl:call-template</xmltag> instruction
      and sends the value on its way.
      </p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"list"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:variable</cokw> name=<costring>"indent"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"concat(count(ancestor::list) * 0.5,'in')"</costring></codeline>
<codeline>  &lt;/xsl:variable<cokw>&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:apply-templates&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:with-param</cokw> name=<costring>"margin-indent"</costring> select=<costring>"$indent"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:apply-templates&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@675 ?>

      
      <p>But for this to work, there has to be a receiver for the parameter in the template or templates that are invoked.  Within our list we might have <xmltag>p</xmltag>, <xmltag>li</xmltag>, <xmltag>note</xmltag>
      or <xmltag>info</xmltag> tags (yes, there's a lot of weird XML out there). For the template for the <xmltag>p</xmltag> tag, we would then see something like this:
      </p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"p"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"margin-indent"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;li</cokw> margin-left=<costring>"{$margin-indent}"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw><cokw>/&gt;</cokw>&gt;</codeline>
<codeline>  <cokw>&lt;/li&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@691 ?>

      
      <p>The example above demonstrates a few rules about paramaters.  The first is that <xmltag>xsl:param</xmltag> has to be the first instruction following the <xmltag>xsl:template</xmltag>
      tag, or it will be invalid.  The second is that <xmlattr>name</xmlattr> in the <xmltag>xsl:param</xmltag> must be the same as the <xmlattr>name</xmlattr> in the <xmltag>xsl:with-param</xmltag> tag
        in the template that invoked this one.  A third rule is that the <xmltag>xsl:param</xmltag> tag does not have to specify a value, itself. You can assume that a value will be passed to is.  However,
        if you want to specify a back-up, default value for the <xmltag>xsl:param</xmltag> tag, just in case the <xmltag>xsl:with-param</xmltag> was a dud, you can specify the value with the <xmlattr>select</xmlattr>
        attribute. If a value does get passed to <xmltag>xsl:param</xmltag>, the default value will be ignored.
      </p>
      
      <p>Parameters, like variables, also work on a global scope.  You can specify <xmltag>xsl:param</xmltag> at the top level of a stylesheet, just the same as you can <xmltag>xsl:variable</xmltag>.
      Of course, that begs the question: if the purpose of <xmltag>xsl:param</xmltag> is to receive a value, what could possibly pass it a value at the global scope?  Variables and parameters at the global
        scope are evaluated before templates, so a template could not be the source of a value for <xmltag>xsl:param</xmltag>.
      </p>
      
      <p>Could something from outside the stylesheet pass a value into the stylesheet by way of a global parameter?  Yep, you've got it.  As we'll see in <xref linkend="chap.stylesheets"/>, the invoking mechanism
      for an XSLT stylesheet can pass in an external value.  This type of control is great for re-using stylesheets for different purposes.  For example, we could pass the language in for each time we processed
      our pharmaceutical labeling stylesheet, and we would only output the labels for the language we wanted. But we're getting a little ahead of ourselves...</p>
      
      <p>Now that we've seen parameters at work, let's take a look at <xmltag>xsl:call-templates</xmltag>.  We may or may not use parameters with named templates, but for an effective recursion processing strategy, we'll
      probably use both.</p>
      
    </sect2>
    
    
    <sect2>
      <title><xmltag>xsl:call-template</xmltag></title>
    </sect2>
    
    <p> The
    <xmltag>xsl:call-template</xmltag> instruction is equivalent to using <xmltag>xsl:apply-templates</xmltag>, but with a twist. The clue is in the plural “templates” part of <xmltag>xsl:apply-templates</xmltag>
      and the singular “template” part of <xmltag>xsl:call-template</xmltag>. When we use <xmltag>xsl:apply-templates</xmltag>, it will invoke any number of other templates, based on whatever XML tags are within the 
      current context.  For the <xmltag>xsl:call-template</xmltag> instruction, only one template is invoked---the one that is named.
      Where <xmltag>xsl:apply-templates</xmltag> matches elements within the current context of the XML, <xmltag>xsl:call-templates</xmltag> has no interest in current context. It doesn't match on anything,
      and it does't change the current context.  Instead, it uses the <firstuse>name</firstuse> of a template, and the template it calls uses the <xmlattr>name</xmlattr> attribute 
      rather than the <xmlattr>match</xmlattr> attribute. (A template can have both <xmlattr>match</xmlattr> and <xmlattr>name</xmlattr>, depending on how it is used.)</p>
    
    <p>Calling a named template is a great way to re-use logic that will
      be meaningful within more than one template.  For example, you might need to evaluate every element to determine whether it needs to have an <xmlattr>id</xmlattr> attribute generated for it, or whether it already has one.
      The logic for doing this is straightforward:
    </p>
    
<processedcode showname="no" style="normal">
<codeline>&lt;xsl:template match="p"&gt;</codeline>
<codeline>  &lt;para&gt;</codeline>
<codeline>    &lt;xsl:attribute name="id"&gt;</codeline>
<codeline>    &lt;xsl:choose&gt;</codeline>
<codeline>      &lt;xsl:when test="@id"&gt;</codeline>
<codeline>       &lt;xsl:value-of select="@id"/&gt;</codeline>
<codeline>      &lt;/xsl:when&gt;</codeline>
<codeline>      &lt;xsl:otherwise&gt;</codeline>
<codeline>        &lt;xsl:value-of select="generate-id()"</codeline>
<codeline>      &lt;/xsl:otherwise&gt;</codeline>
<codeline>    &lt;/xsl:choose&gt;</codeline>
<codeline>    &lt;/xsl:attribute&gt;</codeline>
<codeline>    ...</codeline>
<codeline>   &lt;/para&gt;</codeline>
<codeline>&lt;/xsl:template&gt;</codeline>
</processedcode>
<?location values.pml@750 ?>

    
    <p>But you wouldn't want to have to put all that into each and every template in your stylesheet.  Instead, it would be nice to place it in some re-usable area somewhere and just call it as needed:</p>
    
<processedcode showname="no" style="normal">
<codeline>&lt;xsl:template match="p"&gt;</codeline>
<codeline>  &lt;para&gt;</codeline>
<codeline>    &lt;xsl:call-template name="id-maker"/&gt;</codeline>
<codeline>    ...</codeline>
<codeline>  &lt;/para&gt;</codeline>
<codeline>  &lt;/xsl:template&gt;</codeline>
<codeline/>
<codeline>  &lt;xsl:template name="id-maker"&gt;</codeline>
<codeline>    &lt;xsl:attribute name="id"&gt;</codeline>
<codeline>      ...</codeline>
<codeline>    &lt;/xsl:attribute&gt;</codeline>
<codeline>&lt;/xsl:template&gt;</codeline>
</processedcode>
<?location values.pml@769 ?>

    
    <p>Now any template in the stylesheet, not just the one that matches on <xmltag>p</xmltag>, can make use of the code for creating <xmlattr>id</xmlattr> attributes.</p>
    
    <p>If you use <xmltag>xsl:call-template</xmltag> to call a template by a certain
      name, the XSLT processor expects a template with that name to exist, or it will post an error. Another thing to remember is to make sure the results of the called template make sense
      within the context of the <xmltag>xsl:call-template</xmltag> instruction.  For instance, in the code above, if we had put <xmltag>xsl:call-template</xmltag> after some other code rather than immediately
      after <xmltag>para</xmltag>, the XSLT processor would post an error to the effect that an attribute can't be created once an element has been formed. 
      So the lesson is: think about the code from the called template in the context where it is called.
    </p>
    
    <sect2>
      <title>Using Named Templates and Parameters Together</title>
      
      <p>One interesting aspect of a named template is that the current context in the XML is the same for the named template as for the template where <xmltag>xsl:call-template</xmltag> calls it. 
        That's the reason we could get away with using the <ic>@id</ic> token to retrieve the value of the <xmlattr>id</xmlattr> attribute when we were in the <ic>id-maker</ic> template in the example above.</p>
    
      <p>But what about variables?  Suppose we wanted all the ID values to be prefaced with a variable that we had defined in the calling template (and that we were actually going to use in the calling template).
        Rather than defining the variable twice, we could pass it in to the named template with a parameter, the same as we did with <xmltag>xsl:apply-templates</xmltag>.</p>
      
      <p> For example, we might take the first two letters of the element name and concatenate it with the level at which the element occurs in the XML hierarchy.  
        We need to use the level number elsewhere to calculate the indent amount, so we pass both the abbreviated element name and the element level to the called template
        for its own use. Since this approach does not use any new techniques for us, why not take a little break to work out how that would look.
      </p>
      
      <p>
        When using parameters with called templates, watch out for a couple of things. Make sure the parameters being passed in to the called template make sense for how the parameter is used in the template.  If 
        the template is doing numeric calculations on a parameter for a margin width, and you're capturing the margin width from an attribute that looks like <xmlattr value="3.5in">width</xmlattr>, 
        you'll need to strip the <ic>in</ic> part of the string off the value before passing it to the named template.
      </p>
      
      <p>Also, try to generalize the named template as much as possible to make sense for how it will be re-used in different parts of your stylesheet. A template that parses text for shortening might also be used
        to parse text for keywords---think about a processing method that will work for both, and define the parameters generically enough not to push yourself into a conceptual corner.  Named templates
        can be used successfully for several purposes and called from different types of contexts if they are carefully thought out.
      </p>
      
    </sect2>
  </sect1>

  <sect1>
    <title>Generated Values</title>
    
<!-- <p><xmltag>xsl:number</xmltag>, <ic>count()</ic>, <ic>position()</ic>, <ic>generate-id()</ic>,
<ic>id()</ic>, and </p> --> 
    <p>We've talked a good bit about variables and parameters, which are containers for values that we generate or derive by various means during runtime.
    But in general, we've created or derived those values without giving too much attention to the methods we've used for getting them.  Our primary methods
    have been either to find the value in the XML itself, or to count some aspect of the XML with the <ic>count()</ic> function.  That's all well and good,
      but there are occasions when we could use a little more help than that.
    </p>
    
    <p>XSLT provides several tools for generating values of different types, which we'll see here. These may be values that we place into variables or parameters, 
    or they may be values that we send directly to our output.</p>
    
    <p>Instructions and functions for generating values include:</p>
    
    <ul>
      <li><p><ic>count()</ic></p></li>
      <li><p><ic>position()</ic></p></li>
      <li><p><ic>last()</ic></p></li>
      <li><p><ic>number()</ic></p></li>
      <li><p><ic>format-number()</ic></p></li>
      <li><p><ic>generate-id()</ic></p></li>
       <li><p><xmltag>xsl:number</xmltag></p></li>
    </ul>
    
    <p>We're not going to spend a lot of time creating elaborate structures with these guys.  Other than the <xmltag>xsl:number</xmltag> instruction, they're fairly straightforward.
    Let's go through the vital statistics of all but the last of these, saving <xmltag>xsl:number</xmltag> for a separate section so we can spend a little extra time on it.
    </p>
    
    <dl>
      <dt newline="yes"><ic>count()</ic></dt>
      <dd><p>We've seen <ic>count()</ic> work before.  It takes a single argument, which is a node or node-set, usually defined by an XPath expression.  The nice thing about <ic>count()</ic>
      is that the XPath expression allows us to count just about anything anywhere. We just need to remember our XPath chops, and off we go.</p>
      <p>One temptation with <ic>count()</ic> is to use it for numbering sequences in an output.  It would probably be okay for simple arrangements, but try to resist the temptation.
        We'll find <xmltag>xsl:number</xmltag> offers a lot more functionality than <ic>count(</ic> for numbering things.</p>
      </dd>
      <dt newline="yes"><ic>position()</ic></dt>
      <dd><p><ic>position()</ic> is another handy tool for generating numbers, but it can be deceptive. It takes no arguments, and it returns a number equal to the position of its current context
      within the sequence of nodes the current context belongs to.  In a sense, it sounds like we should be able to use this for creating numbers for a numbered list, but beware: the kinds of things
      that are in the current context's sequence may be more than you expect. There may be spaces between the nodes you want to number, and spaces create <ic>text()</ic> nodes.  Many is the XSLT coder
      who has been dismayed to find his numbered steps coming out with the sequence 2, 4, 6, 8.... </p>
        <p>The value associated with the first position in the sequence is 1, not 0, so plan accordingly.</p>
        <p>The <ic>position()</ic> function is an ideal counter if you need to know the true position of the current context in its sequence,
        regardless of what else is being counted, or if you know that the current sequence holds no surprises. You can also make sure the sequence holds no 
        surprises with a little extra fidgeting (see <xref linkend="sidebar.strip-space"/>.</p>     
      </dd>
      <dt><ic>last()</ic></dt>
      <dd><p>The <ic>last()</ic> function holds the same caveats as the <ic>position()</ic> function: it takes its value from the sequence of peers containing the current context. Only in this case,
      it doesn't return the value of the current context, it returns the value of the position of the last item in the sequence. This makes it great for things like long lists, where you need to inform
      the reader, “You are now viewing item 3 of 750,487.” And again, be sure you understand what is counted: your reader might be disgusted to find out that 750,000 of those items 
      were just line returns.</p></dd>
      <dt newline="yes"><ic>number()</ic></dt>
      <dd><p>The <ic>number()</ic> function is a little different from the previous three functions because it doesn't take its value from a node-set. Instead, it takes a single argument, which can be
      any of the four data types, and returns a value depending on the input. The argument can also take optional whitespace and a minus sign (-) before the rest of the argument.</p>
      
      <p>For the four data types, the results are:</p>
      <dl>
         <dt>Number</dt>
        <dd><p>Returns the number that was input</p></dd>
        <dt>Boolean</dt>
        <dd><p>Returns a 1 for <ic>true()</ic> and a 0 for <ic>false()</ic></p></dd>
         <dt>String</dt>
        <dd><p>Returns a number if the string can be converted to a number according to the rules of the IEEE 754 specification.<footnote><p><url>en.wikipedia.org/wiki/IEEE_754-1985</url></p></footnote>
        Basically, if it's digit-like and doesn't have weird characters in the string, it will give you the number you expect. For any other string, it will return the string <ic>NaN</ic> (Not a Number). 
        </p></dd>
        <dt>Node-set</dt>
        <dd><p>If we put a node-set in <ic>number()</ic>, the node-set is first converted to a string, then the string is evaluated the same as described above for a string.  Otherwise we'll get the deadly <ic>NaN</ic>.</p>
          <p>To see how a node-set is converted to a string, check out the <ic>string()</ic> function <xref linkend="app.functions"/>.</p>
        </dd>
       </dl>
      </dd>
       <dt newline="yes"><ic>generate-id()</ic></dt>
      <dd><p>We've seen <ic>generate-id()</ic> at work---it generates a unique string based on the position of the context node within the current document.
        We frequently use this function to provide a value for an <xmlattr>id</xmlattr> attribute, typically for the purpose of acting as a reference point for some additional XSLT processing.
      </p>
        <p>One interesting aspect of <ic>generate-id()</ic>
        is that no matter how many times you invoke it, from whatever part of the stylesheet or by whatever XPath expression it takes, it will always generate the same value for a given node.
        For example, if we're in the root node and do <ic>generate-id()</ic> for that context, we might get a value like <ic>d10001</ic>.  Then, if we're almost finished processing all the XML, and we use an XPath expression
          to point from the last node back to the root, the <ic>generate-id()</ic> value for the root will again be <ic>d10001</ic>. If the context for <ic>generate-id()</ic> is the same in both cases, 
          the value will be the same.
          We can take advantage of this fact to create references between nodes, such as textual cross-references, wherever we need to.  
          <author>Seems like there's an example of this already in the book, but I can't remember where at the moment.</author>
        </p>
        <p>As a secondary note: The XSLT specification does not require an XSLT processor to generate the same value for a 
          given node every time it processes the XML document---it only has to give a consistent value within the scope
        of a single processing pass. Even if the XML does not change between processing passes, we can't assume the returned value will be the same each time. 
        I've seen that typically it does stay the same, but I wouldn't bet my paycheck on it happening every time. 
        (Just in case you were starting to try to think outside the box. XSLT is a very boxy language.)</p>
      </dd>
    </dl> 
    <sidebar id="sidebar.strip-space">
      <title>The Extermination of Whitespace Text Nodes</title>
      <p>Line breaks are good for formatting output and reading source, but they create <firstuse>whitespace</firstuse> (blank characters of various sorts), which are treat as text.
        This means our XML contains text nodes where we might not expect them. When we use a function like <ic>position()</ic>, which is sensitive to the presence of nodes,
        the results can also be unexpected.  
      </p>
        <p>One way of removing whitespace is to add <xmltag attrs="elements=&quot;*&quot;">xsl:strip-space</xmltag> to the top of our stylesheet. 
          (Put it before any template.) This will strip spaces from every element.  If there are elements where we need to preserve whitespace (for instance, a <xmltag>code</xmltag> element containing code),
          we could add the <xmltag attrs="elements=&quot;code&quot;">xsl&gt;:preserve-space</xmltag> tag, also at the top of the stylesheet.  The <xmlattr>elements</xmlattr> attribute for both instructions
          can contain a space-delimited set of element names, so we can handle many elements with a single instance of each instruction.
        </p>    
    </sidebar>
    <sect2>
      <title><xmltag>xsl:number</xmltag></title>
      <p>I saved the best for last: <xmltag>xsl:number</xmltag> is a powerful, multifaceted tool for counting nodes. It derives its value from the position of the current node for the template in which it is active. 
        It also has several attributes that work together to provide some pretty sophisticated
      output for numbering.  Have you ever seen a document that uses Milspec (U.S. military standard) numbering?  The numbers look like a thesis outline gone berserk: consider appendix paragraph A.4.2.1.3.e.
      Ouch!  But no sweat: that's a piece of cake for <xmltag>xsl:number</xmltag>.
      </p>
      
      <p>I've seen full-grown programmers make some pretty odd assumptions about this tag, so it does bear a little extra scrutiny. Let's try to pin in down as best we can. 
        Once again, let's take a look at its vitals, then proceed to some examples. The attributes we want to pay careful attention to are <xmlattr>count</xmlattr>,
      <xmlattr>from</xmlattr>, and <xmlattr>level</xmlattr>.  These three work together to determine what value is returned.  The rest have mostly to do with formatting.
      </p>
      
      <sect3>
        <title><xmltag>xsl:number</xmltag> Attributes</title>
     
      <dl>
        <dt><xmltag>xsl:number</xmltag></dt>
        <dd><p/>
          <p/>
          <p>Following are the most important attributes that can be used with <xmltag>xsl:number</xmltag>. 
            (To save space I've omitted attributes relating to different languages, but you can learn about them at <url>http://www.w3schools.com/xsl/el_number.asp</url>.) 
            Don't despair if these descriptions don't click immediately---we'll see examples in short order.</p>
          <table style="hlines">
            <thead>
              <col>Attribute</col>
              <col>Required?</col>
              <col>Function</col>
            </thead>
            <row>
              <col><p><xmlattr>count</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This attribute takes an XPath expression to specify what nodes will be counted.  If it is omitted, the current node is counted
              along with any other node with the same node type.  For example, if our node is the seventh element in a group of mixed elements, it will generate a value of 7.
              </p></col>
            </row>
            <row>
              <col><p><xmlattr>from</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>The <xmlattr>from</xmlattr> attribute takes another XPath expression.  It specifies the <emph>ancestor node</emph> that constrains the scope of the counting.  For example, if we
              only want to count within the parent of the current node, we give the name of the parent; if we want to count within the grandparent of the current node, we give the name of the grandparent.</p>
                <p>It's as if this value has a phantom <ic>ancestor::</ic> axis added to the expression we give--you don't need to give it yourself, and it will be rejected if you do. And you'll want to be careful: 
                the counting scope is defined at the first match found in the chain of ancestors going up from the current node. If the element occurs at multiple levels, the scope is defined at the first match
                in the ancestor chain up from the current context.</p> 
              </col>
            </row>
            <row>
              <col><p><xmlattr>level</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This attribute specifies what levels of the XML hierarchy will be considered in returning the number or set of numbers. It can take one of three values:</p>
              <dl>
                <dt>single (default value)</dt>
                <dd><p>This setting constrains the count to a single level in the XML hierarchy, and it returns only a single number. If <xmlattr>from</xmlattr> is absent, 
                  counting is limited to nodes within the current parent that match the <xmlattr>count</xmlattr> pattern.  If <xmlattr>from</xmlattr> is present, counting occurs
                  within all of the nodes that are descendants of the node that matches the <xmlattr>from</xmlattr>, but only if they are at the same level in the XML as the current node.
                  <author>Need to test this and show an example.</author>
                </p></dd>
                <dt>any</dt>
                <dd><p>This value also returns only a single number, but it counts the nodes that match <xmlattr>count</xmlattr> no matter what level they are at. If <xmlattr>from</xmlattr>
                is present, counting only occurs within the descendants of the node that matches <xmlattr>from</xmlattr>.
                </p></dd>
                <dt>multiple</dt>
                <dd><p>With <xmlattr value="multiple">level</xmlattr>, we get into Milspec territory. With this value, multiple numbers may be returned, with one number for each level of the XML hierarchy
                that is being counted. Again, <xmlattr>from</xmlattr> determines the scope of what is counted, and <xmlattr>count</xmlattr> determines what is counted.  
                </p>
                  <p>As a quick example: if <xmlattr>count</xmlattr> matches five nodes at the top level within our scope, then matches three nodes at the next level, then matches two nodes (including our context node)
                  at the current level, the value it returns is 5.3.2.  (The periods are the default number separator.)</p>
                </dd>
               </dl>
              </col>
            </row>
            <row>
              <col><p><xmlattr>format</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This attribute determines how the value will be formatted for output. It takes a string of tokens that represent the format of the number. The tokens can be as follows:</p>
              <ul>
                <li><p>1—gives traditional Arabic numerals for output.</p></li>
                <li><p>A—gives uppercase alphabet characters for the output. At value 27, the output goes to AA.</p></li>
                <li><p>a—gives lowercase alphabet characters for the output.</p></li>
                <li><p>I—gives uppercase Roman numerals for the output.</p></li>
                <li><p>i—gives lowercase Roman numerals for the output. </p></li>
                <li><p>Other characters—The interpretation of other characters is processor-dependent.  In general, though, you can add punctuation characters after the value to give it the punctuation you want.
                Prefixes are also possible.  For these types of additional text, though, I would place the text outside the <xmltag>xsl:number</xmltag> tag. Just let the tag do what it does best: count stuff.</p></li>
              </ul>
              </col>
            </row>
            <row>
              <col><p><xmlattr>value</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This variable allows you to specify a value to be output instead of having the value based on the position of the context node.</p></col>
            </row>
            <row>
              <col><p><xmlattr>grouping-separator</xmlattr></p></col>
              <col><p>No</p></col>
              <col><p>This attribute allows you to specify a separator character to use between the numbers in a multi-level number.  The default, as we have seen, is a period.</p></col>
            </row>
          </table> 
        </dd>
      </dl>
      </sect3>
      <sect3>
        <title>Examples with <xmltag>xsl:number</xmltag></title>
  
      <p>Okay, that was a lot of crazy talk.  Wouldn't an example be easier?  Sure---formal definitions can cover a lot of ground, but they do tend to be a little abstract. So let's 
        see what it all means in the real world. First we need a chunk of XML that wants numbering:</p>
      
<processedcode language="xml" showname="values/number-instruction-1.xml" style="normal" url="values/number-instruction-1.xml">
<codeline prefix="Line 1">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</codeline>
<codeline prefix="-">&lt;?xml-stylesheet type="text/xsl" href="number-instruction-1.xsl"?&gt;</codeline>
<codeline id="code.numbering.top-section" lineno="3" prefix="-"><cokw>&lt;section&gt;</cokw>                                </codeline>
<codeline prefix="-">  <cokw>&lt;title&gt;</cokw>Examples of XSLT Templates<cokw>&lt;/title&gt;</cokw></codeline>
<codeline prefix="5">  <cokw>&lt;p&gt;</cokw>What are some of the more common forms of XSLT templates?<cokw>&lt;/p&gt;</cokw></codeline>
<codeline id="code.numbering.second-section-1" lineno="6" prefix="-">  <cokw>&lt;section&gt;</cokw>                              </codeline>
<codeline prefix="-">    <cokw>&lt;title&gt;</cokw>Simple templates to change tags<cokw>&lt;/title&gt;</cokw></codeline>
<codeline calloutno="1" id="code.numbering.example-1" prefix="-">    <cokw>&lt;example&gt;</cokw>                         </codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;xsl:template match="/labels"&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="10">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;category&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>    &amp;lt;xsl:apply-templates select="language"/&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;/category&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;/xsl:template&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/example&gt;</cokw></codeline>
<codeline id="code.numbering.example-2" lineno="15" prefix="15">    <cokw>&lt;example&gt;</cokw>                         </codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;xsl:template match="/labels"&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;element name="category"&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>    &amp;lt;xsl:apply-templates select="language"/&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;/element&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="20">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;/xsl:template&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/example&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/section&gt;</cokw></codeline>
<codeline id="code.numbering.second-section-2" lineno="23" prefix="-">  <cokw>&lt;section&gt;</cokw>                              </codeline>
<codeline prefix="-">    <cokw>&lt;title&gt;</cokw>Base template for identity transform<cokw>&lt;/title&gt;</cokw></codeline>
<codeline id="code.numbering.example-3" lineno="25" prefix="25">    <cokw>&lt;example&gt;</cokw>                         </codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;xsl:template match="/ | * | @*"&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;xsl:copy&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>    &amp;lt;xsl:apply-templates select=" * | @*"/&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw>  &amp;lt;/xsl:copy&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="30">      <cokw>&lt;codeline&gt;</cokw>&amp;lt;/xsl:template&gt;<cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw><cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">      <cokw>&lt;codeline&gt;</cokw><cokw>&lt;/codeline&gt;</cokw></codeline>
<codeline prefix="-">    <cokw>&lt;/example&gt;</cokw></codeline>
<codeline prefix="-">  <cokw>&lt;/section&gt;</cokw></codeline>
<codeline prefix="35"><cokw>&lt;/section&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1017 ?>

           
        
        <p>For the first example, let's do something easy.  We just want to number the lines of code, so our template for the <xmltag>codeline</xmltag> tag
        should include an item like this:
        </p>
        
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:number</cokw> count=<costring>"."</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1028 ?>

        
        <p>Simple enough. Since our context is <xmltag>codeline</xmltag>, we're going to count other tags with the same name. And since we haven't specified the <xmlattr>from</xmlattr> or <xmlattr>level</xmlattr>
        attributes, we're going to get a single level that starts from the parent.  Just what we wanted.  
        </p>
        <p>Now let's crank it up a notch.  We want the code numbering to be continuous within a given section, so having <xmlattr>from</xmlattr> be the default of <ic>parent::</ic> won't get the job done. 
          How about this?
        </p>
        
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:number</cokw> count=<costring>"."</costring> from=<costring>"section"</costring><cokw>/&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1041 ?>

        
        <p>This version takes its scope from the <xmltag>section</xmltag> tag in line <cref linkend="code.numbering.second-section-1"/> of our example XML,  so all the <xmltag>codeline</xmltag>
          tags in the examples in lines <cref linkend="code.numbering.example-1"/> and <cref linkend="code.numbering.example-2"/> will be numbered continuously,  
          even though they are in two different <xmltag>example</xmltag> tags. When we get to the  <xmltag>codeline</xmltag>
          tags in the example in line <cref linkend="code.numbering.example-3"/>, the numbering starts over.</p>
        
        <p>What about that fancy MilSpec numbering? This is a good opportunity for <xmltag>xsl:number</xmltag> to really shine.  Let's say we want numbering on both levels of <xmltag>section</xmltag>, alphabetic
        counting on the <xmltag>example</xmltag> tags, and numeric counting again on the <xmltag>codeline</xmltag> tags. We know we're going to use <xmlattr value="multiple">level</xmlattr>,
          and <xmlattr>from</xmlattr> has got to be from the root (“/”) to get the top-level <xmltag>section</xmltag> tag, right? So now give a little 
          thought to what you would put for the <xmlattr>count</xmlattr> and <xmlattr>format</xmlattr> attributes before you peek at the code example below.</p>
        
        <p>Here's my take on the templates for a stylesheet that does nothing but output the numbers for <xmltag>section</xmltag>, <xmltag>example</xmltag>, and <xmltag>codeline</xmltag>:</p>
        
<processedcode language="xml" showname="values/number-instruction-1.xsl" style="normal" url="values/number-instruction-1.xsl">
<codeline><cokw>&lt;xsl:stylesheet</cokw> xmlns:xsl=<costring>"http://www.w3.org/1999/XSL/Transform"</costring> version=<costring>"1.0"</costring> <cokw>&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"</costring> <costring>/ | * "</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"</costring> <costring>* "</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:template</cokw> match=<costring>"section | example | codeline"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:text&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:text&gt;</cokw><cokw>&lt;xsl:number</cokw> level=<costring>"multiple"</costring> from=<costring>"/"</costring></codeline>
<codeline>      count=<costring>"section | example | codeline"</costring> format=<costring>"1.1.a.1."</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> select=<costring>"</costring> <costring>* "</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:template&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:stylesheet&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1055 ?>

        
        <p>And here is the output, as you would expect:</p>
        
<processedcode language="plain" showname="no" style="normal">
<codeline>1.</codeline>
<codeline>1.1.</codeline>
<codeline>1.1.a.</codeline>
<codeline>1.1.a.1.</codeline>
<codeline>1.1.a.2.</codeline>
<codeline>1.1.a.3.</codeline>
<codeline>1.1.a.4.</codeline>
<codeline>1.1.a.5.</codeline>
<codeline>1.1.b.</codeline>
<codeline>1.1.b.1.</codeline>
<codeline>1.1.b.2.</codeline>
<codeline>1.1.b.3.</codeline>
<codeline>1.1.b.4.</codeline>
<codeline>1.1.b.5.</codeline>
<codeline>1.2.</codeline>
<codeline>1.2.a.</codeline>
<codeline>1.2.a.1.</codeline>
<codeline>1.2.a.2.</codeline>
<codeline>1.2.a.3.</codeline>
<codeline>1.2.a.4.</codeline>
<codeline>1.2.a.5.</codeline>
<codeline>1.2.a.6.</codeline>
<codeline>1.2.a.7.</codeline>
</processedcode>
<?location values.pml@1083 ?>

       <p>And that's the power of <xmltag>xsl:number</xmltag>!</p> 
        
        <p>As an afterthought, let's think about how would handle it if the requirement was to have, say, the same numbering scheme we have in the example above, but instead of the codelines having their
        numbers restarted with each new <xmltag>example</xmltag> tag, we want them numbered continuously throughout the document. This sort of thing occasionally happens with figures and tables in some documents,
        where the chapter number is followed by the figure number, but the figure numbering is continuous throughout the book rather than being reset at each chapter.</p>
        <p>With this sort of Franken-number, we're best off combining two <xmltag>xsl:number</xmltag> tags, each following the rules for its own numbering stream. 
          I'll leave that exercise for you to have fun with---you've probably gotten the hang of it by now.</p>
      </sect3>
    
    </sect2>
    
  </sect1>
   
  <sect1 id="sect1.values.recursion">
    <title>Putting It All Together with Recursion</title>
    
    
    <p>Recursion is about doing something until you get it right.</p>
    
    <p>There's no big secret to the definition of recursion: it's simply the act of doing something over and over, 
    usually acting on the same piece of content, or on some variation of a piece of content.</p>
    
    <p>For instance, we might want to take a string of words and place each word in its own tag. 
    That's a perfect situation for using recursion. We just define a template to lop off the first word, place it in a tag, then call the same template again with the original string, minus its first word.
    Lather, rinse, repeat.</p>
    
    
 <p> We know that a template with a <xmltag>match</xmltag> statement will repeat any time it matches its target, but it will only execute one time per match.  But by using a named template, we can call the
   template from <emph>inside itself</emph> using its own template name. In fact, here's the simplest recursive template you could imagine:
 </p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> name=<costring>"recursor"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:call-template</cokw> name=<costring>"recursor"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1121 ?>

    
    <p>Of course, you'll notice at once that this little monument to bad coding contains two fatal flaws. For one thing, it doesn't do anything other than call itself. For another thing, it creates
    an endless loop.  You might think that it will never end, but it will---when the memory stack overflows and the XSLT processor dies of dizziness. The lesson to take from this: always set a condition
    that will ensure that the recursion ends.
    </p>
     <p>The word “condition” should give a clue as to how recursive templates are normally set up. Ttypically, the inclusion of <xmltag>xsl:choose</xmltag> or <xmltag>xsl:if</xmltag> statements allow you to specify
      conditions that will alter the sequence of processing one a given end-condition tests true or false. 
     </p>
    
    <p>Let's have a look at the problem we talked about earlier, wrapping each word in a text string with a tag. Thinking it through, our template needs to have one thing going into it and another thing coming out of it.
    Going into the template, we need the text string.  Coming out of it, we need the tagged text.
    </p>
    
    <p>As we saw earlier, one way to pass a value into a named template is with an <xmltag>xsl:param</xmltag> instruction. So initially, let's say we are in a template for a <xmltag>commandlist</xmltag> tag,
    and the contents of the tag are several command names in a space-separated list.  The template we'll use to kick off our named, recursive template would look like this:</p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> match=<costring>"commandlist"</costring><cokw>&gt;</cokw></codeline>
<codeline>   <cokw>&lt;xsl:call-template</cokw> name=<costring>"word-tagger"</costring><cokw>&gt;</cokw></codeline>
<codeline>     <cokw>&lt;xsl:with-param</cokw> name=<costring>"string"</costring> select=<costring>"normalize-space(.)"</costring><cokw>/&gt;</cokw></codeline>
<codeline>   <cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
<codeline> <cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1146 ?>

    
    <p>The <xmltag>xsl:with-param</xmltag> tag creates the <ic>string</ic> parameters and takes the value of the current context, the <xmltag>commandlist</xmltag> tag. Note the use of the <ic>normalize-space()</ic>
      function.  We don't know what kind of whitespace we might have in our string; the great thing about <ic>normalize-space()</ic> is that it chops off all leading and trailing whitespace, it removes linebreaks,
      and it reduces all incidents of multiple spaces to a single space. We're using it to condition our text going in so we know there is only one space between each word, and nothing else.</p>
      
    <p> Any time we pass a parameter with <xmltag>xsl:with-param</xmltag>, we also need to define a receiver in another template. So let's set up the <ic>word-tagger</ic> template with a parameter:
    </p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> name=<costring>"word-tagger"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"string"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1161 ?>

    
    <p>Again, this template doesn't do anything (yet), but at least it doesn't crash the memory stack every time we run it.</p>
    
    <p>Notice that we've kept the names of the template and parameter fairly generic. Our template might not always be used for tagging commands in a list.  We might want to generalize it later to create any
    type of tag we need (based on a name we pass in from our originating template, possibly by way of a second parameter). So let's keep the names as general as possible, to reflect its potential for re-use.
  </p>
    <p>Still, for the moment, let's just tag every word with a <xmltag>command</xmltag> tag.</p>
    
    <p>To do that, we're going to have to get hold of just the first word in the string.  That's easy enough---we'll use the <ic>substring-before()</ic> function. To emit the command with the first
    word in the string, the complete section of code looks like this:
    </p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;command&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before($string,' ')"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/command&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1180 ?>

    
    <p>We don't have our recursion yet, and we don't have our condition for stopping, either.  If we put this line into the template above, it will execute perfectly, but only once. So what's next?</p>
    
    <p>Well, we know we're going to need a call back to our same template, so we could go ahead an add that to the template. But we'll also need to pass in the string for it to operate on. If we pass
    it the original <ic>string</ic> parameter, it will just snag the same first word again, and around and around we'll go. Instead, we'll need to pass it a version of the original string with the first word
      lopped off.  Again, we'll use a substring function to preserve the part of the string we want. With all that in mind, our call to the template should look like this:
    </p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:call-template</cokw> name=<costring>"word-tagger"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:with-param</cokw> name=<costring>"string"</costring> select=<costring>"substring-after($string,' ')"</costring><cokw>/&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1195 ?>

    
    <p>The second time the template is called, it is calling itself (recursion!), but this time with a shorter string. The next word is snagged and tagged (the XML version of polar bears!), and the template
    is called a third time with yet a shorter string.  This goes on and on and on...</p>
    
    <p>What happens if we run out of string?  Our control mechanism doesn't really have a stopping point, even if the string it keeps passing around is empty.  So we need to figure out what the end condition will be,
    then devise a way of testing for it.</p>
    
    <p>In our case, we know that when we get to the last word there shouldn't be any spaces left in the string. So before we execute the <xmltag>xsl:call-template</xmltag>, we can test for the presence of a space
      in the string.  If there is a space, we'll keep executing, otherwise we stop.  We could do our testing a couple of ways, but let's keep it simple and just wrap an <xmltag>xsl:if</xmltag> around the 
      <xmltag>xsl:call-template</xmltag>.  With that extra piece of code, we should have our complete string tagger in place:
    </p>
    
    <figure id="fig.code.word-tagger">
      <title>The Word Tagger Template</title>
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> name=<costring>"word-tagger"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"string"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;command&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before($string,' ')"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/command&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:if</cokw> test=<costring>"contains($string,' ')"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:call-template</cokw> name=<costring>"word-tagger"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:with-param</cokw> name=<costring>"string"</costring> select=<costring>"substring-after($string,' ')"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:if&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1225 ?>

    </figure>
  
    <p>And that, my friends, is recursion in action.</p>
    
    <p>Recursion is a great way to handle situations where there is a need for repetition that can't be handled by simply letting templates match on elements.
    Several examples come to mind.  We've seen the notion of recursing through words---we could also use this method to match on words and do word substitutions. We might also need
    to intercept special characters in the text: for example, in the DITA Open Toolkit, the preference is not to use the ™ symbol, but to use the markup &lt;tm tmtype="trademark"/&gt;. (I believe
    the point is to be able to support alternative trademark characters in other languages when the text is translated.) If we need to convert some legacy text to DITA markup, we could include a template to recurse 
    through every letter until we match ™, then substitute the DITA version for it.
    </p>
    
    <p>Recursion through XML elements in a list is another possible use.  For the most part, repeating an action in a list of tags can be done with matching templates, but we may find special cases
    where matching is a little more difficult than we'd like.  Suppose, for instance, we only want to process the first ten tags in a parent tag. Those tags may or may not be the same type of tag. One way to do 
    it would be to call a template and pass in a number representing the ending count for the elements we want to process, and another number starting at 1 that we will use as a counter.  
    We'll add 1 to the count each time the template calls itself.  Within the template, we match on the element at that position by means of a predicate containing the counter
    We include a test for when our counter reaches the number where we wanted to stop, and that's the end of it. 
    </p>
    <p>Let's take a look at that idea in actual code:</p>
    
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> name=<costring>"partial-list-processor"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"end-count"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"counter"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:if</cokw> test=<costring>"$counter </costring>&amp;lt;<costring>= $end-count"</costring><cokw>&gt;</cokw></codeline>
<codeline>    <cokw>&lt;xsl:apply-templates</cokw> match=<costring>"*[$counter]"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline>    <cokw>&lt;xsl:call-template</cokw> name=<costring>"partial-list-processor"</costring><cokw>&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:with-param</cokw> name=<costring>"end-count"</costring> select=<costring>"$end-count"</costring><cokw>/&gt;</cokw></codeline>
<codeline>      <cokw>&lt;xsl:with-param</cokw> name=<costring>"counter"</costring> select=<costring>"$counter + 1"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:if&gt;</cokw></codeline>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1261 ?>

    
    <p>A couple of things to think about here: The test in the <xmltag>xsl:if</xmltag> is set up to allow the processing to continue until <ic>counter</ic> is equal to <ic>end-count</ic>, 
      then to call the template one more time before it stops.  Can you think of a way so that it stops when they are equal to each other, so the template isn't called an extra time? 
      (Consider using the <xmltag>xsl:choose</xmltag> tag rather than <xmltag>xsl:if</xmltag>.) </p>
    
    <p>Also, notice that the <xmltag>xsl:call-template</xmltag> tag contains an 
      <xmltag>xsl:with-param</xmltag> tag for the <ic>end-count</ic> parameter. If we defined it once, and we're not changing it, shouldn't it just stay the same value?  No---because when
      we use the <xmltag>xsl:call-template</xmltag> tag, we are losing the scope of the parameter, even if it is calling its containing template. We need to pass in the value just the same
      as if we were calling the template from some other template.
    </p>
    
    <sect2>
      <title>Parsing Strings with Recursion</title>
    <p>Recursion is an excellent tool for parsing through strings of text to replace words or letters.  The secret is to pass the string in to a “right-side string” parameter, 
      then slowly parse off the first word (as we did in the word-tagger template in <xref linkend="fig.code.word-tagger"/>), 
      and concatenate that value in a parameter that accumulates the processed “left-side string” value.  Add a condition that tests for a particular word, 
      and you can substitute a new string for that word in the process. </p>
     
      <p>To make the recursive template
        general enough to be handle a variety of situations, we'll create <ic>original</ic> and <ic>replacement</ic> parameters to allow us to pass in the word we want to change and the word we want to change it to.
        Our calling template places the subject string into the <ic>right-side-string</ic> parameter to start the process, then the recursion takes over to parse through the whole string.</p>
      
<processedcode language="xml" showname="no" style="normal">
<codeline><cokw>&lt;xsl:template</cokw> name=<costring>"word-substituter"</costring><cokw>&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"original"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"replacement"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"left-side-string"</costring><cokw>/&gt;</cokw></codeline>
<codeline>  <cokw>&lt;xsl:param</cokw> name=<costring>"right-side-string"</costring><cokw>/&gt;</cokw></codeline>
<codeline/>
<codeline>  <cokw>&lt;xsl:choose&gt;</cokw></codeline>
<codeline calloutno="1" id="code.string-parsing.test-continue">    <cokw>&lt;xsl:when</cokw> test=<costring>"contains($right-side-string,' ')"</costring><cokw>&gt;</cokw>    </codeline>
<codeline>      <cokw>&lt;xsl:variable</cokw> name=<costring>"first-word"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-before($right-side-string,' ')"</costring></codeline>
<codeline>      &lt;/xsl:variable<cokw>&gt;</cokw></codeline>
<codeline/>
<codeline>      <cokw>&lt;xsl:variable</cokw> name=<costring>"remaining-string"</costring><cokw>&gt;</cokw></codeline>
<codeline>        <cokw>&lt;xsl:value-of</cokw> select=<costring>"substring-after($right-side-string,' ')"</costring></codeline>
<codeline>      &lt;/xsl:variable<cokw>&gt;</cokw></codeline>
<codeline/>
<codeline>      <cokw>&lt;xsl:choose&gt;</cokw></codeline>
<codeline calloutno="2" id="code.string-parsing.test-for-word">        <cokw>&lt;xsl:when</cokw> test=<costring>"$first-word = $original"</costring><cokw>&gt;</cokw>  </codeline>
<codeline>          <cokw>&lt;xsl:call-template</cokw> name=<costring>"word-substituter"</costring><cokw>&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"original"</costring> select=<costring>"$original"</costring><cokw>/&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"replacement"</costring> select=<costring>"$replacement"</costring><cokw>/&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"left-side-string"</costring></codeline>
<codeline calloutno="3" id="code.string-parsing.add-replacement">              select=<costring>"concat($left-side-string,$replacement,' ')"</costring><cokw>/&gt;</cokw>  </codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"right-side-string"</costring> select=<costring>"$remaining-string"</costring><cokw>/&gt;</cokw></codeline>
<codeline>          <cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline/>
<codeline>        <cokw>&lt;xsl:otherwise&gt;</cokw></codeline>
<codeline>          <cokw>&lt;xsl:call-template</cokw> name=<costring>"word-substituter"</costring><cokw>&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"original"</costring> select=<costring>"$original"</costring><cokw>/&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"replacement"</costring> select=<costring>"$replacement"</costring><cokw>/&gt;</cokw></codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"left-side-string"</costring></codeline>
<codeline calloutno="4" id="code.string-parsing.add-old-word">              select=<costring>"concat($left-side-string,$first-word,' ')"</costring><cokw>/&gt;</cokw> </codeline>
<codeline>            <cokw>&lt;xsl:with-param</cokw> name=<costring>"right-side-string"</costring> select=<costring>"$remaining-string"</costring><cokw>/&gt;</cokw></codeline>
<codeline>          <cokw>&lt;/xsl:call-template&gt;</cokw></codeline>
<codeline>        <cokw>&lt;/xsl:otherwise&gt;</cokw></codeline>
<codeline>      <cokw>&lt;/xsl:choose&gt;</cokw></codeline>
<codeline/>
<codeline>    <cokw>&lt;/xsl:when&gt;</cokw></codeline>
<codeline calloutno="5" id="code.string-parsing.ending">    <cokw>&lt;xsl:otherwise&gt;</cokw></codeline>
<codeline>       <cokw>&lt;xsl:value-of</cokw> select=<costring>"concat($left-side-string,$right-side-string)"</costring><cokw>/&gt;</cokw></codeline>
<codeline>    <cokw>&lt;/xsl:otherwise&gt;</cokw></codeline>
<codeline>  <cokw>&lt;/xsl:choose&gt;</cokw></codeline>
<codeline/>
<codeline><cokw>&lt;/xsl:template&gt;</cokw></codeline>
</processedcode>
<?location values.pml@1330 ?>

      
      <p>Just going through it quickly: in <cref linkend="code.string-parsing.test-continue"/> we test for a condition that means we need to continue.  If this is not true, we end the process 
        with our <xmltag>xsl:otherwise</xmltag> at <cref linkend="code.string-parsing.ending"/>.  If it is true, we create a couple of variables with our familiar substring functions, then we set
        up yet a second <xmltag>xsl:choose</xmltag> to test whether the first word matches the word we want to replace (<cref linkend="code.string-parsing.test-for-word"/>).</p>
      <p>If it's the word of interest,
        we put together the existing left-side string (which will be null when we start), the replacement string, and a space to replace the one we used for our substring identification 
        (<cref linkend="code.string-parsing.add-replacement"/>), which we pass as a value to the left-side string for the next iteration of the template. If the first word is not the word of interest,
        we do almost the same thing, except we add the original word back to the left-side string, leaving things just as we found them.  In both cases, the <ic>remaiing-string</ic> value gets passed back to the template 
        as the right-side string.  The template moves through the string, space by space, inch by inch, until there are no spaces left. 
      </p>
      
      <p>Recursion can be used for doing math as well as handling
        strings and tags---see if you can do a Fibonacci series (<lower subscript="n"><emph>F</emph></lower>) = <lower subscript="n-1"><emph>F</emph></lower> + <lower subscript="n-2"><emph>F</emph></lower> 
        to 10 iterations. Just be sure to give the template a clear way to end the processing, or it will speed along like a runaway train until the Java stack blows up.</p>
      
      
      <p>Recursion is a useful tool in situations where it is difficult or impossible to create a template to allow the processor to do repeated processing for you. It has its limitations, as we've seen---it needs
      a clear ending, and you may find that with very long content, even with a well-defined end condition, the number of repetitions is still too much for the Java stack.  In a situation like this, you might need
      to find a way to divide the content into more manageable chunks, if possible.  Or you might consider alternative to recursive processing.</p>
      <p>In some cases, the content may just be too much for XSLT to handle
      on a computer with finite memory (which is most of them in the universe, so far).  In that case, there is the alternative to hand off the processing to another program---a desperate,
      last-ditch strategy that we try to avoid when possible. And if you do need it, you will need to use an XSLT extension. The core XSLT funtionality does not support external program calls.
      </p>
    </sect2>
   
  </sect1>

  <sect1>
    <title>What Did We Do?</title>
   
    <p>We've covered a lot in this chapter! The management of values in XSLT programming is a broad topic. We had a look at the types of values availabe, each with its own idiosyncracies.
    We checked out variables, taking a look at how they can be manipulated, and how in turn they can be used in conditional structures and boolean tests, among other things. We even wrestled with
    nodes in variables for a while. When it came to parameters, we also introduced the <xmltag>xsl:call-template</xmltag> tag and had a look at how named templates work.  Then we looked at a variety of functions
      that are used to generate values, including the (ahem) valuable <xmltag>xsl:number</xmltag> instruction.
    </p>
    <p>Finally, we put several parts of our new knowledge to work with a processing strategy called recursion. Here we used parameters, functions for manipulating string values, and numeric counters to
      control a little code machine for repeating instructions until it reached a specified end condition.</p> 
      
      <p>Recursion is one of the more complex XSLT processing structures we have seen so far. With this technique in hand, 
        we are well on our way to understanding XSLT templates and how to use them. This is a great time to stop for a moment and look back over all the scenery we've covered.
      We aren't done yet, but by this point you should be able to see real progress---our starting point is just a little stream of smoke down in the valley below, and maybe a couple of rooftops in the trees.</p>
   
    <p> Find a rock, take a breather, and relax a while. We still need to cover some of the strategies for handling stylesheets at a higher 
      level than just the templates. Once we get over that peak, though, the view should be well worth the effort.</p>
  </sect1>
  
  

</chapter>
<?location stylesheets.pml@3 ?>

<chapter id="chap.stylesheets">
  <title>Large-Scale Stylesheet Strategies</title>

  <sect1>
    <title>Looking Beyond the Template to Stylesheet Structure</title>

    <p>Rested up? All right, let's get back on the trail. The top is just in sight.</p>

    <p>So far we've talked mostly about the mechanics of templates: template matching, called templates,
      things that go on inside templates, values that get passed between templates, along with various kinds
      of problems we can solve with template-based processing. But stylesheets consist of more than just
      templates. We've already seen a couple of instructions that work at the top level of the stylesheet with
      <xmltag>xsl:template</xmltag>, namely <xmltag>xsl:key</xmltag> and <xmltag>xsl:param</xmltag>. There are
      a variety of other instructions that work at the the top level of the stylesheet, and they bring a host
      of global functions with them. In this chapter, we'll take a look at what they're good for.</p>

    <p>Among other things, we'll see that we can control global formatting of our output in various ways.
      We'll also see strategies for grouping attributes into named sets so we can reuse them, much the same
      way rules are set up in HTML's CSS syntax. We'll go even further by using the
      <xmltag>xsl:include</xmltag> tag to place templates and attribute sets in separate files, and we'll get
      an understanding of how this approach can add flexibility to our aability to reuse our stylesheets for
      different situations. </p>

    <p> While we're breaking out of the confines of the <xmltag>xsl:template</xmltag> tag, we'll also break
      out of the confines of our XML source file. The <xmltag>xsl:document</xmltag> tag provides a way to
      bring in information from an additional source file. Using data from more than one document tremedously
      enhances our abilities to process complex XML or to produce complex results. </p>

    <p>Now that we've mastered some of the basics, let's get a bigger picture of stylesheets and what we can
      do with them.</p>

  </sect1>

  <sect1>
    <title>Global Controls in the Stylesheet</title>

    <p>First, let's mention two attributes on the <xmltag>xsl:stylesheet</xmltag> tag itself. These two
      control namespace prefixes in the output: </p>

    <dl>
      <dt><xmlattr>extension-element-prefixes</xmlattr></dt>
      <dd>
        <p>Use this attribute to specify what namespaces are associated with XSLT extensions.</p>
      </dd>
      <dt><xmlattr>exclude-result-prefixes</xmlattr></dt>
      <dd>
        <p>Use this attribute to exclude namespace prefixes from the output.</p>
      </dd>
    </dl>

    <p>Neither of these are heavily used, although if you see that certain tags in your output are getting
      annoying namespaces attached to them, specify the namespace in
      <xmlattr>exclude-result-prefixes</xmlattr>. (It takes a space-separated list of namespace prefixes.) The
      annoyance vanishes. </p>

    <p>Moving along from the attributes on the <xmltag>xsl:stylesheet</xmltag> tag, here's the list of
      instructions that can be used at the top level of a stylesheet. Some of these we already know; others we
      will be getting to shortly.</p>
    <dl>
      <dt newline="yes"><xmltag>xsl:output</xmltag></dt>
      <dd>
        <p>Controls various aspects of the output format, including things like character encoding, XML
          doctype statements, indentation, and output method (for example, HTML- or XML-type output).</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:preserve-space</xmltag></dt>
      <dd>
        <p>Specifies the names of elements in the source XML whose whitespace in the output will be left
          exactly as it is in the source. It takes a space-separated list.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:strip-space</xmltag></dt>
      <dd>
        <p>Specifies the names of elements in the source that will have all extraneous whitespace removed in
          the output. It takes a space-separated list.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:decimal-format</xmltag></dt>
      <dd>
        <p>Defines how numbers will be converted to strings when using <ic>format-number()</ic>.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:attribute-set</xmltag></dt>
      <dd>
        <p>Contains a set of <xmltag>xsl:attribute</xmltag> tags. The name of the attribute set can be used to
          associate the attributes with elements that are created by the stylesheet.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:include</xmltag></dt>
      <dd>
        <p>Provides a method of inserting templates from another stylesheet file into the location of this
          instruction in the current stylesheet.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:namespace-alias</xmltag></dt>
      <dd>
        <p>Allows us to map a namespace from the stylesheet into a different namespace in the output
          document.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:key</xmltag></dt>
      <dd>
        <p>Look back at <ref linkend="chap.order-order-2"/> for the definition and examples of this
          instruction.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:variable</xmltag></dt>
      <dd>
        <p>We've seen <xmltag>xsl:variable</xmltag> in <ref linkend="chap.values"/>, but we saw it used inside
          templates. It does the same thing outside templates, but, as with parameters, the variable is
          available to all templates when it is defined outside of a template. </p>
      </dd>
      <dt newline="yes"><xmltag>xsl:param</xmltag></dt>
      <dd>
        <p>We described this instruction in <ref linkend="chap.values"/>.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:template</xmltag></dt>
      <dd>
        <p>This is the workhorse of the stylesheet. You know a good bit about this instruction already.</p>
      </dd>
      <dt newline="yes"><xmltag>xsl:transform</xmltag></dt>
      <dd>
        <p>This is a synonym for <xmltag>xsl:stylesheet</xmltag>, generally not used. It's safe to ignore this
          one. It's included here only for the sake of completion.</p>
      </dd>
    </dl>

    <p>We'll have a look at a few of these in depth. The output controls will be particularly important
      because output requirements vary considerably from output type to output type.</p>

  </sect1>

  <sect1>
    <title>Output Controls</title>

    <p>The majority of the output controls are fairly self-explanatory, but we'll take a deeper dive into the
      <xmltag>xsl:output</xmltag> tag and the <xmlattr>exclude-result-prefixes</xmlattr> attribute to explore
      some of the more useful properties for output control. In particular, the <xmltag>xsl:output</xmltag>
      instruction has a large number of attributes, so it gets a lot of use. </p>

    <p> <xmltag>xsl:output</xmltag> can appear anywhere at the top level in a stylesheet, and it can appear
      multiple times. During runtime, all the <xmltag>xsl:output</xmltag> tags are merged into the equivalent
      of a single statement. For this reason, the attributes and attribute values should not be repeated in
      the multiple instance. But in general, it's best to create the <xmltag>xsl:output</xmltag> statement
      just once at the top of the stylesheet, before the templates, and have done with it. </p>

    <p>Here are the <xmltag>xsl:output</xmltag> attributes:</p>
    <dl>
      <dt newline="yes"><xmlattr>cdata-section-elements</xmlattr></dt>
      <dd>
        <p>Contains a space-separated list of elements whose contents are to be treated according to the XML
          definition of CDATA. This allows you to include things like &lt; and &amp; without having to
          represent them with character entities.</p>
      </dd>
      <dt newline="yes"><xmlattr>doctype-public</xmlattr></dt>
      <dd>
        <p>When the output is XML, a DOCTYPE declaration may be needed. This attribute specifies the public
          identifier in the XML DOCTYPE declaration.</p>
      </dd>
      <dt newline="yes"><xmlattr>doctype-system</xmlattr></dt>
      <dd>
        <p>Specifies the system identifier in the DOCTYPE declaration.</p>
      </dd>
      <dt newline="yes"><xmlattr>encoding</xmlattr></dt>
      <dd>
        <p>Specifies what type of character encoding to use for the output. If the attribute is not present,
          the default encoding is utf-8. If you have characters that are coming out weird, check the encoding.
          XSLT processors are only required to respect the values utf-8 and utf-16 for this attribute, but
          read the fine print for the processor you are using. Saxon, for instance, supports ASCII, US-ASCII,
          iso-8859-1, utf-8, utf8, KOI8R, and cp1251. </p>
      </dd>
      <dt newline="yes"><xmlattr>indent</xmlattr></dt>
      <dd>
        <p>Specifies whether to indent the output. It takes the values yes or no. For XML output, the default
          value is no, but for HTML, the default value is yes. (Go figure.) This attribute is valid only for
          well-formed XML output. The use of indenting is supposed to be whitespace-friendly, but care should
          be exercised in its use, especially if you have elements that contain both text and elements at the
          same level (that is, the dreaded “mixed content”). </p>
      </dd>
      <dt newline="yes"><xmlattr>media-type</xmlattr></dt>
      <dd>
        <p>Specifies the <firstuse>Internet media type.</firstuse><footnote>
          <p><url>http://en.wikipedia.org/wiki/Internet_media_type</url></p>
          </footnote> The default value is text/xml. This setting has no impact on the output itself, but it
          may be used by the XSLT processor as part of its instructions to other programs to identify what
          type of content the output is. In general, this isn't something you'll need to worry about. </p>
      </dd>
      <dt newline="yes"><xmlattr>method</xmlattr></dt>
      <dd>
        <p>Specifies the output format. Valid values are <emph>xml</emph>, <emph>html</emph>, and
          <emph>text</emph>, although XSLT processors may support other values and output methods. The use of
          <emph>text</emph> means that you can't use XSLT instructions (like <xmltag>xsl:element</xmltag> that
          output well-formed XML tags. Using the <emph>html</emph> value, the HTML output will be indented.
        </p>
      </dd>
      <dt newline="yes"><xmlattr>omit-xml-declaration</xmlattr></dt>
      <dd>
        <p>With the XML output method, set this attribute to <emph>yes</emph> to omit the XML declaration from
          the beginning of the output. The default value of this attribute is <emph>no</emph>. </p>
      </dd>
      <dt newline="yes"><xmlattr>standalone</xmlattr></dt>
      <dd>
        <p>Used with the XML output method, this attribute inserts a <xmlattr>standalone</xmlattr> attribute
          in the XML declaration at the top of the output file. Set the value to <emph>yes</emph> or
          <emph>no</emph>; this value then appears in the attribute in the XML declaration in the output. </p>
      </dd>
      <dt newline="yes"><xmlattr>version</xmlattr></dt>
      <dd>
        <p>Specifies the version of HTML or XML that will be output. For the XML output method, the XML
          version appears in the XML declaration in the output. For HTML, the effect on the output varies by
          the version number. </p>
      </dd>
    </dl>
    
    <p>But you know by now that this book isn't about regurgitating the specifications.  We're here to solve problems
    so we can learn along the way. So let's ask: what problems does <xmltag>xsl:output</xmltag> solve for us?
    </p>
    
    <p>Let's key off of the three values we can set for the <xmlattr>method</xmlattr> attribute: <emph>text</emph>, <emph>html</emph>, and <emph>xml</emph>. 
    What sorts of controls do we typically need for creating these three types of output? The answer, especially for HTML, turns out not to be quite as straightforward 
    as we might like.     
    </p>


  </sect1>

  <sect1>
    <title>Attribute Sets</title>
    <p/>
  </sect1>

  <sect1>
    <title>External Stylesheet Inclusions</title>
    <p/>
  </sect1>

  <sect1>
    <title>External Data Sources</title>
    <p/>
  </sect1>


</chapter>
<?location troubleshooting.pml@3 ?>

<chapter id="chap.troubleshooting">
  <title>Troubleshooting</title>
  <storymap>
    <dl style="bold">
      <dt>Why do I want to read this?</dt>
      <dd>
        <p>Things inevitably go wrong.  No matter what you do, nothing comes out, or a template gives absolutely
        nonsensical results. Fortunately, there are some strategies for teasing out the causes and finding solutions.</p>
      </dd>
      <dt>What will I learn?</dt>
      <dd>
        <ul>
          <li><p>Common problem patterns and what to do about them.</p></li>
          <li><p>Common troubleshooting techniques.</p></li>
          <li><p>Anticipating problems, and how to deal with them in advance.</p></li>
        </ul>
        
      </dd>
      <dt>What will I be able to do?</dt>
      <dd>
        <p>Recognize certain basic types of problems.</p>
        <p>Use some simple troubleshooting techniques to identify problems and resolve them.</p>
        <p>Set up structures to handle some kinds of problems before they occur.</p>
      </dd>
      <dt>Where are we going next?</dt>
      <dd>
        <p>To the appendices!  You're done!</p>
      </dd>
    </dl>
  </storymap>


</chapter>
<?location xsl-elements.pml@3 ?>

<appendix>

  <title>XSLT Element Reference</title>

  <sect1>
    <title>List of XSLT 1.0 Elements</title>
    <table style="outerlines">
      <row>	<col>	xsl:apply-imports	</col>	<col>	xsl:for-each	</col>	<col>	xsl:processing-instruction 	</col>	</row>
      <row>	<col>	xsl:apply-templates	</col>	<col>	xsl:if	</col>	<col>	xsl:sort	</col>	</row>
      <row>	<col>	xsl:attribute	</col>	<col>	xsl:import	</col>	<col>	xsl:strip-space 	</col>	</row>
      <row>	<col>	xsl:attribute-set	</col>	<col>	xsl:include	</col>	<col>	xsl:stylesheet 	</col>	</row>
      <row>	<col>	xsl:call-template	</col>	<col>	xsl:key	</col>	<col>	xsl:template 	</col>	</row>
      <row>	<col>	xsl:choose	</col>	<col>	xsl:message	</col>	<col>	xsl:text 	</col>	</row>
      <row>	<col>	xsl:comment	</col>	<col>	xsl:namespace-alias	</col>	<col>	xsl:transform 	</col>	</row>
      <row>	<col>	xsl:copy	</col>	<col>	xsl:number 	</col>	<col>	xsl:value-of 	</col>	</row>
      <row>	<col>	xsl:copy-of	</col>	<col>	xsl:otherwise	</col>	<col>	xsl:variable 	</col>	</row>
      <row>	<col>	xsl:decimal-format	</col>	<col>	xsl:output 	</col>	<col>	xsl:when	</col>	</row>
      <row>	<col>	xsl:element	</col>	<col>	xsl:param	</col>	<col>	xsl:with-param 	</col>	</row>
      <row>	<col>	xsl:fallback	</col>	<col>	xsl:preserve-space 	</col>	<col>		</col>	</row>
    </table>
  </sect1>
  <sect1>
    <title>Syntax of XSLT 1.0 Elements</title>
    <table style="hlines">
      <colspec col="1" width="1.5in"/>
      <colspec col="2" width="3.5in"/>
       <row>
        <col><p>xsl:apply-imports</p></col>
        <col><syntax><![CDATA[<xsl:apply-imports />]]></syntax></col>
      </row>
      <row>
        <col><p>xsl:apply-templates</p></col>
        <col><syntax><![CDATA[<xsl:apply-templates
select = node-set-expression
mode = qname>
<!-- Content: (xsl:sort | xsl:with-param)* -->
</xsl:apply-templates>]]></syntax> </col>
      </row>
      <row>
        <col> <p>xsl:attribute</p></col>
        <col><syntax><![CDATA[<xsl:attribute
name = { qname }
namespace = { uri-reference }>
<!-- Content: template -->
</xsl:attribute>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:attribute-set</p></col>
        <col><syntax><![CDATA[<xsl:attribute-set
name = qname
use-attribute-sets = qnames>
<!-- Content: xsl:attribute* -->
</xsl:attribute-set>        
]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:call-template</p></col>
        <col><syntax><![CDATA[<xsl:call-template
name = qname>
<!-- Content: xsl:with-param* -->
</xsl:call-template>                ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:choose</p></col>
        <col><syntax><![CDATA[<xsl:choose>
<!-- Content: (xsl:when+, xsl:otherwise?) -->
</xsl:choose>]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:comment</p></col>
        <col><syntax><![CDATA[<xsl:comment>
<!-- Content: template -->
</xsl:comment>]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:copy</p></col>
        <col><syntax><![CDATA[<xsl:copy
use-attribute-sets = qnames>
<!-- Content: template -->
</xsl:copy>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:copy-of</p></col>
        <col><syntax><![CDATA[<xsl:copy-of select = expression />       ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:decimal-format</p></col>
        <col><syntax><![CDATA[<xsl:decimal-format        
name = qname
decimal-separator = char
grouping-separator = char
infinity = string
minus-sign = char
NaN = string
percent = char
per-mille = char
zero-digit = char
digit = char
pattern-separator = char />]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:element</p></col>
        <col><syntax><![CDATA[<xsl:element
name = { qname }
namespace = { uri-reference }
use-attribute-sets = qnames>
<!-- Content: template -->
</xsl:element>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:fallback</p></col>
        <col><syntax><![CDATA[<xsl:fallback>
<!-- Content: template -->
</xsl:fallback>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:for-each</p></col>
        <col><syntax><![CDATA[<xsl:for-each
select = node-set-expression>
<!-- Content: (xsl:sort*, template) -->
</xsl:for-each>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:if</p></col>
        <col><syntax><![CDATA[<xsl:if
test = boolean-expression>
<!-- Content: template -->
</xsl:if>]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:import</p></col>
        <col><syntax><![CDATA[<xsl:import
href = uri-reference />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:include</p></col>
        <col><syntax><![CDATA[<xsl:include
href = uri-reference />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:key</p></col>
        <col><syntax><![CDATA[<xsl:key
name = qname
match = pattern
use = expression />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:message</p></col>
        <col><syntax><![CDATA[<xsl:message
terminate = "yes" | "no">
<!-- Content: template -->
</xsl:message>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:namespace-alias</p></col>
        <col><syntax><![CDATA[<xsl:namespace-alias        
stylesheet-prefix = prefix | "#default"
result-prefix = prefix | "#default" />]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:number</p></col>
        <col><syntax><![CDATA[<xsl:number
level = "single" | "multiple" | "any"
count = pattern
from = pattern
value = number-expression
format = { string }
lang = { nmtoken }
letter-value = { "alphabetic" | "traditional" }
grouping-separator = { char }
grouping-size = { number } />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:otherwise</p> </col>
        <col><syntax><![CDATA[<xsl:otherwise>
<!-- Content: template -->
</xsl:otherwise>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:output</p></col>
        <col><syntax><![CDATA[<xsl:output
method = "xml" | "html" | "text" | qname-but-not-ncname
version = nmtoken
encoding = string
omit-xml-declaration = "yes" | "no"
standalone = "yes" | "no"
doctype-public = string
doctype-system = string
cdata-section-elements = qnames
indent = "yes" | "no"
media-type = string />        
]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:param</p></col>
        <col><syntax><![CDATA[<xsl:param
name = qname
select = expression>
<!-- Content: template -->
</xsl:param>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:preserve-space</p></col>
        <col><syntax><![CDATA[<xsl:preserve-space
elements = tokens />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:processing-instruction</p></col>
        <col><syntax><![CDATA[<xsl:processing-instruction
name = { ncname }>
<!-- Content: template -->
</xsl:processing-instruction>       ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:sort</p></col>
        <col><syntax><![CDATA[<xsl:sort
select = string-expression
lang = { nmtoken }
data-type = { "text" | "number" | qname-but-not-ncname }        
order = { "ascending" | "descending" }
case-order = { "upper-first" | "lower-first" } />]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:strip-space</p></col>
        <col><syntax><![CDATA[<xsl:strip-space
elements = tokens />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:stylesheet</p></col>
        <col><syntax><![CDATA[<xsl:stylesheet
id = id
extension-element-prefixes = tokens
exclude-result-prefixes = tokens
version = number>
<!-- Content: (xsl:import*, top-level-elements) -->
</xsl:stylesheet>         ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:template</p></col>
        <col><syntax><![CDATA[<xsl:template
match = pattern
name = qname
priority = number
mode = qname>
<!-- Content: (xsl:param*, template) -->
</xsl:template>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:text</p></col>
        <col><syntax><![CDATA[<xsl:text
disable-output-escaping = "yes" | "no">
<!-- Content: #PCDATA -->
</xsl:text>        ]]>
          </syntax></col>
      </row>
      <row>
        <col> <p>xsl:transform</p></col>
        <col><syntax><![CDATA[<xsl:transform
id = id
extension-element-prefixes = tokens
exclude-result-prefixes = tokens
version = number>
<!-- Content: (xsl:import*, top-level-elements) -->
</xsl:transform>        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:value-of</p></col>
        <col><syntax><![CDATA[<xsl:value-of
select = string-expression
disable-output-escaping = "yes" | "no" />        ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:variable</p></col>
        <col><syntax><![CDATA[<xsl:variable
name = qname
select = expression>
<!-- Content: template -->
</xsl:variable>      ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:when</p></col>
        <col><syntax><![CDATA[<xsl:when
test = boolean-expression>
<!-- Content: template -->
</xsl:when>     ]]></syntax></col>
      </row>
      <row>
        <col> <p>xsl:with-param</p></col>
        <col><syntax><![CDATA[<xsl:with-param
name = qname
select = expression>
<!-- Content: template -->
</xsl:with-param>        ]]></syntax></col>
      </row>
    </table>
  </sect1>
  <sect1>
    <title>Common Attributes of XSLT Elements</title>
  </sect1>
  <sect1>
    <title>XSLT Elements by Category</title>
    <table>
      <thead>
        <col>XSLT Element</col>
        <col>"Official" Category</col>
        <col>Functional Category</col>
      </thead>
      <row>	<col>	xsl:choose	</col>	<col>	instruction	</col>	<col>	conditional control	</col>	</row>
      <row>	<col>	xsl:if 	</col>	<col>	instruction	</col>	<col>	conditional control	</col>	</row>
      <row>	<col>	xsl:otherwise 	</col>	<col>	instruction	</col>	<col>	conditional control	</col>	</row>
      <row>	<col>	xsl:when 	</col>	<col>		</col>	<col>	conditional control	</col>	</row>  
      <row>	<col>	xsl:attribute	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:comment	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:copy	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:copy-of	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:decimal-format	</col>	<col>	top-level element	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:element	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:message	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:namespace-alias 	</col>	<col>	top-level element	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:number 	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:output	</col>	<col>	top-level element	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:preserve-space	</col>	<col>	top-level element	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:processing-instruction	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:strip-space	</col>	<col>	top-level element	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:text 	</col>	<col>	instruction	</col>	<col>	output	</col>	</row>
      <row>	<col>	xsl:value-of 	</col>	<col>	instruction	</col>	<col>	output/processing	</col>	</row>
      <row>	<col>	xsl:apply-templates	</col>	<col>	instruction	</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:for-each	</col>	<col>	instruction	</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:key 	</col>	<col>	top-level element	</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:sort 	</col>	<col>		</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:template 	</col>	<col>	top-level element	</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:variable 	</col>	<col>	top-level element and instruction	</col>	<col>	processing	</col>	</row>
      <row>	<col>	xsl:apply-imports	</col>	<col>	instruction	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:attribute-set	</col>	<col>	top-level element	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:call-template	</col>	<col>	instruction	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:fallback	</col>	<col>	instruction	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:import 	</col>	<col>	instruction	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:include	</col>	<col>	top-level element	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:param	</col>	<col>	top-level element	</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:stylesheet	</col>	<col>		</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:transform 	</col>	<col>		</col>	<col>	stylesheet management	</col>	</row>
      <row>	<col>	xsl:with-param	</col>	<col>		</col>	<col>	stylesheet management	</col>	</row>
    </table>
  </sect1>
  
</appendix>
<?location xsl-functions.pml@3 ?>

<appendix id="app.functions">
  <title>XSLT Function and Expression Reference</title>
  <sect1 id="sect1.functions">
    <title>List of XSLT 1.0 Functions</title>
    <table style="outerlines">
      <colspec col="1" width="33%"/>
      <colspec col="2" width="33%"/>
      <colspec col="3" width="33%"/>
      <row>
        <col>boolean</col>
        <col>id</col>
        <col>round</col>
      </row>
      <row>
        <col>ceiling</col>
        <col>key</col>
        <col>starts-with</col>
      </row>
      <row>
        <col>comment</col>
        <col>lang</col>
        <col>string</col>
      </row>
      <row>
        <col>concat</col>
        <col>last</col>
        <col>string-length</col>
      </row>
      <row>
        <col>contains</col>
        <col>local-name</col>
        <col>substring</col>
      </row>
      <row>
        <col>count</col>
        <col>name</col>
        <col>substring-after</col>
      </row>
      <row>
        <col>current</col>
        <col>namespace-uri</col>
        <col>substring-before</col>
      </row>
      <row>
        <col>document</col>
        <col>node</col>
        <col>sum</col>
      </row>
      <row>
        <col>element-available</col>
        <col>normalize-space</col>
        <col>system-property</col>
      </row>
      <row>
        <col>false</col>
        <col>not</col>
        <col>text</col>
      </row>
      <row>
        <col>floor</col>
        <col>number</col>
        <col>translate</col>
      </row>
      <row>
        <col>format-number</col>
        <col>position</col>
        <col>true</col>
      </row>
      <row>
        <col>function-available</col>
        <col>processing-instruction</col>
        <col>unparsed-entity-uri</col>
      </row>
      <row>
        <col>generate-id</col>
      </row>

    </table>
  </sect1>
  <sect1>
    <title>Syntax of XSLT 1.0 Functions</title>
    <p><author>The descriptions of functions given here are taken from the W3C specification. These are
      place-holders. I will be supplying something closer to recent, standard, written American English as a
      substitute.</author></p>
    <dl>
      <dt newline="yes">boolean(object) </dt>
      <dd>
        <p> The boolean function converts its argument to a boolean as follows:</p>
        <ul>
          <li>
            <p>a number is true if and only if it is neither positive or negative zero nor NaN</p>
          </li>
          <li>
            <p>a node-set is true if and only if it is non-empty</p>
          </li>
          <li>
            <p>a string is true if and only if its length is non-zero</p>
          </li>
          <li>
            <p>an object of a type other than the four basic types (number, string, node-set, and boolean) is
              converted to a boolean in a way that is dependent on that type</p>
          </li>
        </ul>
      </dd>
      <dt newline="yes">ceiling(number) </dt>
      <dd>
        <p> The ceiling function returns the smallest (closest to negative infinity) number that is not less
          than the argument and that is an integer. </p>
      </dd>
      <dt newline="yes">concat(string, string, string*) </dt>
      <dd>
        <p> The concat function returns the concatenation of its arguments. </p>
      </dd>
      <dt newline="yes">contains(string, string) </dt>
      <dd>
        <p> The contains function returns true if the first argument string contains the second argument
          string, and otherwise returns false. </p>
      </dd>
      <dt newline="yes">count(node-set) </dt>
      <dd>
        <p> The count function returns the number of nodes in the argument node-set. </p>
      </dd>
      <dt>document(object, node-set?)</dt>
      <dd><p>The document function allows access to XML documents other than the main source document.
        
        When the document function has exactly one argument and the argument is a node-set, then the result is the union, for each node in the argument node-set, of the result of calling the document function with the first argument being the string-value of the node, and the second argument being a node-set with the node as its only member. When the document function has two arguments and the first argument is a node-set, then the result is the union, for each node in the argument node-set, of the result of calling the document function with the first argument being the string-value of the node, and with the second argument being the second argument passed to the document function.
        
        When the first argument to the document function is not a node-set, the first argument is converted to a string as if by a call to the string function. This string is treated as a URI reference; the resource identified by the URI is retrieved. The data resulting from the retrieval action is parsed as an XML document and a tree is constructed in accordance with the data model (see [3 Data Model]). If there is an error retrieving the resource, then the XSLT processor may signal an error; if it does not signal an error, it must recover by returning an empty node-set. One possible kind of retrieval error is that the XSLT processor does not support the URI scheme used by the URI. An XSLT processor is not required to support any particular URI schemes. The documentation for an XSLT processor should specify which URI schemes the XSLT processor supports.
        </p>
      </dd>
      <dt newline="yes">false() </dt>
      <dd>
        <p> The false function returns false. </p>
      </dd>
      <dt newline="yes">floor(number) </dt>
      <dd>
        <p> The floor function returns the largest (closest to positive infinity) number that is not greater
          than the argument and that is an integer. </p>
      </dd>
      <dt newline="yes">id(object) </dt>
      <dd>
        <p> The id function selects elements by their unique ID (see [5.2.1 Unique IDs]). When the argument to
          id is of type node-set, then the result is the union of the result of applying id to the
          string-value of each of the nodes in the argument node-set. When the argument to id is of any other
          type, the argument is converted to a string as if by a call to the string function; the string is
          split into a whitespace-separated list of tokens (whitespace is any sequence of characters matching
          the production S); the result is a node-set containing the elements in the same document as the
          context node that have a unique ID equal to any of the tokens in the list. </p>
        <ul>
          <li>
            <p>id("foo") selects the element with unique ID foo</p>
          </li>
          <li>
            <p>id("foo")/child::para[position()=5] selects the fifth para child of the element with unique ID
              foo </p>
          </li>
        </ul>
      </dd>
      <dt>key()</dt>
      <dd>
        <p>"The key() function returns a node-set from the document, using the index specified by an xsl:key element."(http://www.w3schools.com/xsl/func_key.asp)</p>
        <p>The key function does for keys what the id function does for IDs. The first argument specifies the name of the key. The value of the argument must be a QName, which is expanded as described in [2.4 Qualified Names]. When the second argument to the key function is of type node-set, then the result is the union of the result of applying the key function to the string value of each of the nodes in the argument node-set. When the second argument to key is of any other type, the argument is converted to a string as if by a call to the string function; it returns a node-set containing the nodes in the same document as the context node that have a value for the named key equal to this string.</p>
      </dd>
      <dt newline="yes">lang(string) </dt>
      <dd>
        <p> The lang function returns true or false depending on whether the language of the context node as
          specified by xml:lang attributes is the same as or is a sublanguage of the language specified by the
          argument string. The language of the context node is determined by the value of the xml:lang
          attribute on the context node, or, if the context node has no xml:lang attribute, by the value of
          the xml:lang attribute on the nearest ancestor of the context node that has an xml:lang attribute.
          If there is no such attribute, then lang returns false. If there is such an attribute, then lang
          returns true if the attribute value is equal to the argument ignoring case, or if there is some
          suffix starting with - such that the attribute value is equal to the argument ignoring that suffix
          of the attribute value and ignoring case. For example, lang("en") would return true if the context
          node is any of these five elements:</p>
<processedcode showname="no" style="normal">
<codeline>&lt;para xml:lang="en"/&gt;</codeline>
<codeline>&lt;div xml:lang="en"&gt;&lt;para/&gt;&lt;/div&gt;</codeline>
<codeline>&lt;para xml:lang="EN"/&gt;</codeline>
<codeline>&lt;para xml:lang="en-us"/&gt;</codeline>
</processedcode>
<?location xsl-functions.pml@186 ?>

      </dd>
      <dt newline="yes">last() </dt>
      <dd>
        <p> The last function returns a number equal to the context size from the expression evaluation
          context. </p>
      </dd>
      <dt newline="yes">local-name(node-set?) </dt>
      <dd>
        <p> The local-name function returns the local part of the expanded-name of the node in the argument
          node-set that is first in document order. If the argument node-set is empty or the first node has no
          expanded-name, an empty string is returned. If the argument is omitted, it defaults to a node-set
          with the context node as its only member </p>
      </dd>
      <dt newline="yes">name(node-set?) </dt>
      <dd>
        <p> The name function returns a string containing a QName representing the expanded-name of the node
          in the argument node-set that is first in document order. The QName must represent the expanded-name
          with respect to the namespace declarations in effect on the node whose expanded-name is being
          represented. Typically, this will be the QName that occurred in the XML source. This need not be the
          case if there are namespace declarations in effect on the node that associate multiple prefixes with
          the same namespace. However, an implementation may include information about the original prefix in
          its representation of nodes; in this case, an implementation can ensure that the returned string is
          always the same as the QName used in the XML source. If the argument node-set is empty or the first
          node has no expanded-name, an empty string is returned. If the argument it omitted, it defaults to a
          node-set with the context node as its only member. NOTE: The string returned by the name function
          will be the same as the string returned by the local-name function except for element nodes and
          attribute nodes. </p>
      </dd>
      <dt newline="yes">namespace-uri(node-set?) </dt>
      <dd>
        <p> The namespace-uri function returns the namespace URI of the expanded-name of the node in the
          argument node-set that is first in document order. If the argument node-set is empty, the first node
          has no expanded-name, or the namespace URI of the expanded-name is null, an empty string is
          returned. If the argument is omitted, it defaults to a node-set with the context node as its only
          member. NOTE: The string returned by the namespace-uri function will be empty except for element
          nodes and attribute nodes. </p>
      </dd>
      <dt newline="yes">normalize-space(string?) </dt>
      <dd>
        <p> The normalize-space function returns the argument string with whitespace normalized by stripping
          leading and trailing whitespace and replacing sequences of whitespace characters by a single space.
          Whitespace characters are the same as those allowed by the S production in XML. If the argument is
          omitted, it defaults to the context node converted to a string, in other words the string-value of
          the context node. </p>
      </dd>
      <dt newline="yes">not(boolean) </dt>
      <dd>
        <p> The not function returns true if its argument is false, and false otherwise. </p>
      </dd>
      <dt newline="yes">number(object?) </dt>
      <dd>
        <p> The number function converts its argument to a number as follows: a string that consists of
          optional whitespace followed by an optional minus sign followed by a Number followed by whitespace
          is converted to the IEEE 754 number that is nearest (according to the IEEE 754 round-to-nearest
          rule) to the mathematical value represented by the string; any other string is converted to NaN
          boolean true is converted to 1; boolean false is converted to 0 a node-set is first converted to a
          string as if by a call to the string function and then converted in the same way as a string
          argument an object of a type other than the four basic types is converted to a number in a way that
          is dependent on that type If the argument is omitted, it defaults to a node-set with the context
          node as its only member. NOTE: The number function should not be used for conversion of numeric data
          occurring in an element in an XML document unless the element is of a type that represents numeric
          data in a language-neutral format (which would typically be transformed into a language-specific
          format for presentation to a user). In addition, the number function cannot be used unless the
          language-neutral format used by the element is consistent with the XPath syntax for a Number. </p>
      </dd>
      <dt newline="yes">position() </dt>
      <dd>
        <p> The position function returns a number equal to the context position from the expression
          evaluation context. </p>
      </dd>
      <dt newline="yes">round(number) </dt>
      <dd>
        <p> The round function returns the number that is closest to the argument and that is an integer. If
          there are two such numbers, then the one that is closest to positive infinity is returned. If the
          argument is NaN, then NaN is returned. If the argument is positive infinity, then positive infinity
          is returned. If the argument is negative infinity, then negative infinity is returned. If the
          argument is positive zero, then positive zero is returned. If the argument is negative zero, then
          negative zero is returned. If the argument is less than zero, but greater than or equal to -0.5,
          then negative zero is returned. NOTE: For these last two cases, the result of calling the round
          function is not the same as the result of adding 0.5 and then calling the floor function. </p>
      </dd>
      <dt newline="yes">starts-with(string, string) </dt>
      <dd>
        <p> The starts-with function returns true if the first argument string starts with the second argument
          string, and otherwise returns false. </p>
      </dd>
      <dt newline="yes">string-length(string?) </dt>
      <dd>
        <p> The string-length returns the number of characters in the string (see [3.6 Strings]). If the
          argument is omitted, it defaults to the context node converted to a string, in other words the
          string-value of the context node. </p>
      </dd>
      <dt newline="yes">string(object?) </dt>
      <dd>
        <p> The string function converts an object to a string as follows: A node-set is converted to a string
          by returning the string-value of the node in the node-set that is first in document order. If the
          node-set is empty, an empty string is returned. A number is converted to a string as follows NaN is
          converted to the string NaN positive zero is converted to the string 0 negative zero is converted to
          the string 0 positive infinity is converted to the string Infinity negative infinity is converted to
          the string -Infinity if the number is an integer, the number is represented in decimal form as a
          Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is
          negative otherwise, the number is represented in decimal form as a Number including a decimal point
          with at least one digit before the decimal point and at least one digit after the decimal point,
          preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the
          decimal point apart possibly from the one required digit immediately before the decimal point;
          beyond the one required digit after the decimal point there must be as many, but only as many, more
          digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. The
          boolean false value is converted to the string false. The boolean true value is converted to the
          string true. An object of a type other than the four basic types is converted to a string in a way
          that is dependent on that type. If the argument is omitted, it defaults to a node-set with the
          context node as its only member. NOTE: The string function is not intended for converting numbers
          into strings for presentation to users. The format-number function and xsl:number element in [XSLT]
          provide this functionality. </p>
      </dd>
      <dt newline="yes">substring-after(string, string) </dt>
      <dd>
        <p> The substring-after function returns the substring of the first argument string that follows the
          first occurrence of the second argument string in the first argument string, or the empty string if
          the first argument string does not contain the second argument string. For example,
          substring-after("1999/04/01","/") returns 04/01, and substring-after("1999/04/01","19") returns
          99/04/01. </p>
      </dd>
      <dt newline="yes">substring-before(string, string) </dt>
      <dd>
        <p> The substring-before function returns the substring of the first argument string that precedes the
          first occurrence of the second argument string in the first argument string, or the empty string if
          the first argument string does not contain the second argument string. For example,
          substring-before("1999/04/01","/") returns 1999. </p>
      </dd>
      <dt newline="yes">substring(string, number, number?) </dt>
      <dd>
        <p> The substring function returns the substring of the first argument starting at the position
          specified in the second argument with length specified in the third argument. For example,
          substring("12345",2,3) returns "234". If the third argument is not specified, it returns the
          substring starting at the position specified in the second argument and continuing to the end of the
          string. For example, substring("12345",2) returns "2345".More precisely, each character in the
          string (see [3.6 Strings]) is considered to have a numeric position: the position of the first
          character is 1, the position of the second character is 2 and so on. NOTE: This differs from Java
          and ECMAScript, in which the String.substring method treats the position of the first character as
          0. The returned substring contains those characters for which the position of the character is
          greater than or equal to the rounded value of the second argument and, if the third argument is
          specified, less than the sum of the rounded value of the second argument and the rounded value of
          the third argument; the comparisons and addition used for the above follow the standard IEEE 754
          rules; rounding is done as if by a call to the round function. The following examples illustrate
          various unusual cases: </p>
        <ul>
          <li>
            <p>substring("12345", 1.5, 2.6) returns "234" </p>
          </li>
          <li>
            <p>substring("12345", 0, 3) returns "12"</p>
          </li>
          <li>
            <p>substring("12345", 0 div 0, 3) returns "" </p>
          </li>
          <li>
            <p>substring("12345", 1, 0 div 0) returns "" </p>
          </li>
          <li>
            <p>substring("12345", -42, 1 div 0) returns "12345" </p>
          </li>
          <li>
            <p>substring("12345", -1 div 0, 1 div 0) returns ""</p>
          </li>
        </ul>
      </dd>
      <dt newline="yes">sum(node-set) </dt>
      <dd>
        <p> The sum function returns the sum, for each node in the argument node-set, of the result of
          converting the string-values of the node to a number. </p>
      </dd>
      <dt newline="yes">translate(string, string, string) </dt>
      <dd>
        <p> The translate function returns the first argument string with occurrences of characters in the
          second argument string replaced by the character at the corresponding position in the third argument
          string. For example, translate("bar","abc","ABC") returns the string BAr. If there is a character in
          the second argument string with no character at a corresponding position in the third argument
          string (because the second argument string is longer than the third argument string), then
          occurrences of that character in the first argument string are removed. For example,
          translate("--aaa--","abc-","ABC") returns "AAA". If a character occurs more than once in the second
          argument string, then the first occurrence determines the replacement character. If the third
          argument string is longer than the second argument string, then excess characters are ignored.NOTE:
          The translate function is not a sufficient solution for case conversion in all languages. A future
          version of XPath may provide additional functions for case conversion. </p>
      </dd>
      <dt newline="yes">true()</dt>
      <dd>
        <p> The true function returns true.</p>
      </dd>
    </dl>
  </sect1>
  <sect1 id="sect1.expressions">
    <title>Expression Syntax Elements</title>
    <author>The following needs structure and work.  Taken from http://www.w3schools.com/xpath/xpath_operators.asp.  Also refer to http://www.w3.org/TR/xpath/#section-Expressions</author>
  <!--   <p>| 	Computes two node-sets 	//book | //cd
      + 	Addition 	6 + 4
      - 	Subtraction 	6 - 4
      * 	Multiplication 	6 * 4
      div 	Division 	8 div 4
      = 	Equal 	price=9.80
      != 	Not equal 	price!=9.80
      &lt; 	Less than 	price &lt;9.80
      &lt;= 	Less than or equal to 	price&lt;=9.80
        > 	Greater than 	price>9.80
        >= 	Greater than or equal to 	price>=9.80
        or 	or 	price=9.80 or price=9.70
        and 	and 	price>9.00 and price&lt;9.90
        mod 	Modulus (division remainder) 	5 mod 2</p>--> 
  </sect1>
  
</appendix>
<?location xsl-extensions.pml@3 ?>

<appendix id="app.extensions">

  <title>XSLT Extensions</title>
  
  

 </appendix>
  </mainmatter>


</book>
